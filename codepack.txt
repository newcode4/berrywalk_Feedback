===== META =====
Repo: https://github.com/newcode4/berrywalk_Feedback.git
Branch: main  |  Tag: 0.4.5  |  Commit: c51103e
Generated: 2025-09-17 13:56:25

===== FILE: pack-code.ps1 (4063 bytes, 113 lines) =====
`$ext
param(
  [string]$Root = ".",
  [string]$Out = "codepack.txt",
  [string]$IncludeExt = ".php,.js,.ts,.css,.scss,.html,.htm,.json,.md,.yml,.yaml,.xml,.sh,.ps1,.ini,.txt,.sql,.twig,.vue",
  # 제외할 디렉터리들 (쉼표로 구분)
  [string]$ExcludeDirs = "node_modules,dist,build,vendor,.git,.github,.idea,.vscode,.next,.cache,growth-checklist\plugin-update-checker",
  # 제외할 파일 패턴들 (쉼표로 구분)
  [string]$ExcludeFiles = "*.min.js,*.min.css,*.map,*.lock,*.zip,*.tar,*.gz,*.png,*.jpg,*.jpeg,*.gif,*.webp,*.svg,*.woff,*.woff2,*.ttf,*.eot,*.pdf",
  # 용량 한도
  [int]$MaxFileBytes = 1000000,    # 파일당 최대 1MB
  [int]$MaxTotalBytes = 20000000,  # 전체 최대 20MB
  # 변경 파일만 모드
  [switch]$ChangedOnly,
  [string]$GitRange = ""
)

$ErrorActionPreference = "Stop"
$Root = (Resolve-Path $Root).Path
$include = $IncludeExt.Split(",") | ForEach-Object { $_.Trim().ToLower() } | Where-Object { $_ -ne "" }
$exDirs  = $ExcludeDirs.Split(",")  | ForEach-Object { $_.Trim() }        | Where-Object { $_ -ne "" }
$exFiles = $ExcludeFiles.Split(",") | ForEach-Object { $_.Trim() }        | Where-Object { $_ -ne "" }

function IsTextExt($path) {
  $ext = [IO.Path]::GetExtension($path).ToLower()
  return $include -contains $ext
}
function IsExcludedDir($path) {
  foreach ($d in $exDirs) {
    if ($path -like "*$d*") { return $true }
  }
  return $false
}
function IsExcludedFile($file) {
  foreach ($p in $exFiles) {
    if ([IO.Path]::GetFileName($file) -like $p) { return $true }
  }
  return $false
}

# 파일 목록 수집
$files = @()
if ($ChangedOnly) {
  $gitArgs = @("diff","--name-only")
  if ($GitRange) { $gitArgs += $GitRange }
  $changed = & git @gitArgs 2>$null
  foreach ($rel in $changed) {
    $p = Join-Path $Root $rel
    if (Test-Path $p -PathType Leaf) { $files += (Resolve-Path $p).Path }
  }
} else {
  $files = Get-ChildItem -Path $Root -Recurse -File | ForEach-Object { $_.FullName }
}

# 필터링
$files = $files | Where-Object {
  -not (IsExcludedDir $_) -and
  -not (IsExcludedFile $_) -and
  (IsTextExt $_)
}

# 출력 빌드
$sb = New-Object System.Text.StringBuilder
$totalBytes = 0
$nl = [Environment]::NewLine

# 상단 메타
try {
  $repoUrl = (git -C $Root config --get remote.origin.url)
  $branch  = (git -C $Root rev-parse --abbrev-ref HEAD)
  $tag     = (git -C $Root describe --tags --abbrev=0) 2>$null
  $commit  = (git -C $Root rev-parse --short HEAD)
  $time    = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
  $null = $sb.AppendLine("===== META =====")
  $null = $sb.AppendLine("Repo: $repoUrl")
  $null = $sb.AppendLine("Branch: $branch  |  Tag: $tag  |  Commit: $commit")
  $null = $sb.AppendLine("Generated: $time")
  $null = $sb.AppendLine("")
} catch {}

foreach ($f in $files) {
  try {
    $fi = Get-Item $f
    $size = $fi.Length
    if ($size -gt $MaxFileBytes) {
      $rel = $f.Substring($Root.Length+1)
      $null = $sb.AppendLine("===== FILE: $rel ($size bytes) SKIPPED: > $MaxFileBytes =====$nl")
      continue
    }
    if (($totalBytes + $size) -gt $MaxTotalBytes) {
      $null = $sb.AppendLine("===== STOP: total size would exceed $MaxTotalBytes bytes. Remaining files omitted. =====$nl")
      break
    }

    $rel = $f.Substring($Root.Length+1)
    $content = (Get-Content -Path $f -Raw -Encoding UTF8)
    $lineCount = ($content -split "`r?`n").Count
    $ext = [IO.Path]::GetExtension($f).TrimStart(".").ToLower()
    if (-not $ext) { $ext = "text" }

    $null = $sb.AppendLine("===== FILE: $rel ($size bytes, $lineCount lines) =====")
    $null = $sb.AppendLine("```$ext")
    $null = $sb.AppendLine($content)
    $null = $sb.AppendLine("```$nl")

    $totalBytes += $size
  } catch {
    $null = $sb.AppendLine("===== FILE: $f ERROR: $($_.Exception.Message) =====$nl")
  }
}

[IO.File]::WriteAllText((Join-Path $Root $Out), $sb.ToString(), [Text.Encoding]::UTF8)
"생성 완료: $(Join-Path $Root $Out)  (총 approx $totalBytes bytes)"

`$nl
===== FILE: berrywalk-feedback\berrywalk-feedback.php (2746 bytes, 70 lines) =====
`$ext
<?php
/**
 * Plugin Name: Berrywalk Feedback
 * Description: 대표 질문 수집 → 고객 서술형 피드백 → 관리자 검토까지 한 번에 연결하는 MVP 플러그인.
 * Version: 0.4.5
 * Author: Berrywalk
 */

if (!defined('ABSPATH')) exit;

define('BWF_VER', '0.4.5');
define('BWF_DIR', plugin_dir_path(__FILE__));
define('BWF_URL', plugin_dir_url(__FILE__));

/** 업데이트 체크러 (GitHub) */
require_once __DIR__ . '/plugin-update-checker/plugin-update-checker.php';
use YahnisElsts\PluginUpdateChecker\v5\PucFactory;
try {
  $updateChecker = PucFactory::buildUpdateChecker(
    'https://github.com/newcode4/berrywalk_Feedback/',
    __FILE__,
    'berrywalk-feedback'
  );
  $updateChecker->setBranch('main');

  $updateChecker->getVcsApi()->enableReleaseAssets();
} catch (Throwable $e) {}

/** includes */
require_once BWF_DIR.'includes/helper.php';
require_once BWF_DIR.'includes/signup.php';              // ✅ 가입 폼
// require_once BWF_DIR.'includes/representative-form.php'; // 구버전
require_once BWF_DIR.'includes/feedback-form.php';       // 고객 피드백 (저장 단일화)
require_once BWF_DIR.'includes/crm.php';                 // CRM 테이블
require_once BWF_DIR.'includes/admin-users.php';         // ✅ 사용자 화면(컬럼/프로필)
require_once BWF_DIR.'includes/questions-admin.php';
require_once BWF_DIR.'includes/my-questions.php';
require_once BWF_DIR.'includes/view-question.php';
require_once BWF_DIR. '/includes/admin-owner-form-settings.php'; // 관리자에서 질문지 문구/글자수 수정
require_once BWF_DIR. '/includes/admin-profile-fix.php'; //관리자 프로필 화면 – 저장 버튼 없음 + “WP-Members 추가 필드” 오류 표시
require_once BWF_DIR. '/includes/owner-questions.php'; //대표 질문지 – 저장/보기/검증






/** Assets */
add_action('wp_enqueue_scripts', function () {
  wp_register_style ('bwf-forms',    BWF_URL.'public/css/style.css', [], BWF_VER);
  wp_register_script('bwf-js',        BWF_URL.'public/js/feedback.js', ['jquery'], BWF_VER, true);
  wp_register_script('bwf-owner',     BWF_URL.'public/js/feedback.js', ['jquery'], BWF_VER, true);
  wp_register_script('bwf-feedback',  BWF_URL.'public/js/feedback.js', ['jquery'], BWF_VER, true);
});


register_activation_hook(__FILE__, function(){
  // 보기용 페이지 자동 생성
  if (!get_page_by_path('my-question-view')){
    $pid = wp_insert_post([
      'post_title'   => '내 질문 보기',
      'post_name'    => 'my-question-view',
      'post_status'  => 'publish',
      'post_type'    => 'page',
      'post_content' => '[bwf_owner_view]'
    ]);
  }
  flush_rewrite_rules();
});

`$nl
===== FILE: berrywalk-feedback\readme.txt (780 bytes, 23 lines) =====
`$ext
=== Berrywalk Feedback Survey (MVP) ===
Contributors: berrywalk
Requires at least: 5.8
Tested up to: 6.6
Stable tag: 0.1.0
License: GPLv2 or later

대표 질문 수집 → 고객 서술형 피드백 → 관리자 검토까지 한 번에 연결하는 MVP 플러그인.

== 사용법 ==
1) 페이지 A(대표용): [bw_owner_form]
   - 제출 시 고객 피드백용 고유 링크 생성 → 관리자 이메일로 발송

2) 페이지 B(고객용): [bw_feedback_form]
   - URL에 ?ref=토큰 포함되어야 대표 질문이 자동 노출됨
   - 각 문항 최소 100자

3) 감사 페이지: /feedback-thanks/ (원하는 문구로 페이지 생성)

== 업데이트 ==
- /plugin-update-checker 포함.
- inc/update.php에서 GitHub URL/Branch/Token 설정.

`$nl
===== FILE: berrywalk-feedback\includes\admin-owner-form-settings.php (17584 bytes, 331 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/* ------------------------------
   대표 질문지 빌더 – 옵션(JSON) 저장
   option_name: bwf_owner_builder_json
   ------------------------------ */

/** 기본 JSON */
function bwf_owner_builder_default_json(){
  $json = [
    "title" => "대표님 핵심 질문지",
    "intro_html" => "사업의 본질을 파악하고 고객에게 정말 묻고 싶은 질문을 구체화합니다. 각 문항은 <strong>최소 {MIN}자</strong>입니다. <em>(단, <strong>“고객에게 물어보고 싶은 3가지”</strong>는 글자수 제한 없음)</em>",
    "min_length" => 200,
    "questions" => [
      [
        "id"=>"problem","type"=>"textarea","label"=>"1. 지금, 우리 사업의 가장 큰 고민은 무엇인가요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 현재 가장 답답하거나 성장이 정체되었다고 느끼는 구체적인 상황을 한두 문장으로 설명해 주세요. 예: “광고는 많이 했는데…” 등 <strong>숫자</strong>/<strong>행동</strong> 기반.",
        "examples_html"=>"<ul><li>“최근 인스타그램 광고 효율이 너무 안 나와요. 클릭은 많은데, 웹사이트 체류가 1분도 안 돼요.”</li><li>“재구매율이 낮아 신규 고객 유입 부담이 큽니다.”</li></ul>"
      ],
      [
        "id"=>"value","type"=>"textarea","label"=>"2. 우리 서비스는 고객의 ‘어떤 문제’를 해결해주고 있나요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 고객의 전/후 변화를 떠올려 가장 중요한 <strong>가치</strong>를 한 문장으로.",
        "examples_html"=>"<ol><li>“서류 작업을 5분 만에 자동화 → 본업 집중.”</li><li>“바쁜 직장인에게 집밥 같은 건강한 한 끼 제공.”</li></ol>"
      ],
      [
        "id"=>"ideal_customer","type"=>"textarea","label"=>"3. 우리 서비스를 ‘누가’ 이용해야 하나요? 왜 우리를 선택하나요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 가장 잘 맞는 사람의 특징 + 우리를 고를 <strong>결정적 이유</strong>.",
        "examples_html"=>"<p>“시간·비용이 부족한 <strong>20대 대학생</strong> → 15분 홈트 영상으로 해결.”</p>"
      ],
      [
        "id"=>"ask3","type"=>"group","label"=>"4. 고객에게 물어보고 싶은 3가지","required"=>true,"count_as"=>1,
        "desc_html"=>"고객의 <strong>실제 경험</strong>을 바탕으로 구체적으로 묻는 3개의 질문을 작성하세요.",
        "examples_html"=>"<p><strong>상품</strong></p><ul><li>“첫인상(포장/디자인/첫 사용)?”</li><li>“가장 만족/아쉬웠던 점?”</li></ul><p><strong>서비스</strong></p><ul><li>“무료체험 때 최고의 포인트/아쉬움?”</li></ul>",
        "sub" => [
          ["id"=>"q1","label"=>"질문 1","placeholder"=>"예: 우리 서비스를 알게 된 경로는 무엇이었나요?","required"=>true,"minlength"=>0],
          ["id"=>"q2","label"=>"질문 2","placeholder"=>"예: 결심 포인트는 무엇이었나요?","required"=>true,"minlength"=>0],
          ["id"=>"q3","label"=>"질문 3","placeholder"=>"예: 사용 중 가장 불편했던 점은?","required"=>true,"minlength"=>0]
        ]
      ],
      [
        "id"=>"competitors","type"=>"textarea","label"=>"5. 현재 경쟁사는 어디이며, 그들과의 차별점은 무엇이라고 생각하시나요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 주요 경쟁사 1~2곳과 비교해 강·약점을 정리.",
        "examples_html"=>"<p>“A는 저렴하지만 품질이 낮고, B는 비싸지만 품질이 높다 → 우리는 <strong>적정 가격 + 높은 만족</strong>.”</p>"
      ]
    ]
  ];
  return wp_json_encode($json, JSON_UNESCAPED_UNICODE|JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT);
}

/* 옵션 등록(저장 시 JSON 정합성 보정) */
add_action('admin_init', function(){
  register_setting('bwf_owner_builder_group','bwf_owner_builder_json', [
    'type'=>'string',
    'sanitize_callback'=>function($raw){
      $raw = wp_unslash($raw);               // 1) 슬래시 제거
      $try = json_decode($raw, true);
      if (json_last_error() !== JSON_ERROR_NONE) {
        // 깨졌으면 기본값으로 되돌림(안전)
        return bwf_owner_builder_default_json();
      }
      // 2) 정렬/정상화해서 저장
      return wp_json_encode($try, JSON_UNESCAPED_UNICODE|JSON_UNESCAPED_SLASHES|JSON_PRETTY_PRINT);
    }
  ]);
});

/* 메뉴 */
add_action('admin_menu', function(){
  add_submenu_page('bwf_crm','질문지 빌더','질문지 빌더','manage_options','bwf_owner_builder','bwf_owner_builder_page');
});

/* 관리자 페이지 */
function bwf_owner_builder_page(){
  $raw = get_option('bwf_owner_builder_json');
  if(!$raw) $raw = bwf_owner_builder_default_json();
  ?>
  <div class="wrap">
    <h1>대표 질문지 빌더</h1>
    <p>문항 추가/삭제/이동, 타입 변경, 그룹(소문항) 구성까지 지원합니다.</p>

    <style>
      /* 빌더 전용 스타일(관리자) */
      .bwf-bui-wrap{max-width:980px}
      .bwf-bui-row{background:#fff;border:1px solid #e5e7eb;border-radius:10px;padding:12px 14px;margin:10px 0}
      .bwf-bui-row h3{margin:0 0 8px;display:flex;align-items:center;gap:8px}
      .bwf-bui-grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
      .bwf-bui-grid label{display:block;font-weight:600;margin:6px 0}
      .bwf-bui-grid input[type=text],.bwf-bui-grid input[type=number],.bwf-bui-grid textarea,.bwf-bui-grid select{width:100%}
      .bwf-bui-actions{display:flex;gap:6px}
      .bwf-bui-sub{background:#f8fafc;border:1px dashed #cbd5e1;border-radius:8px;padding:10px;margin:8px 0}
      .bwf-bui-sub h4{margin:0 0 6px;display:flex;align-items:center;gap:6px}
      .bwf-bui-sublist .item{background:#fff;border:1px solid #e2e8f0;border-radius:8px;padding:8px;margin:6px 0}
      .bwf-bui-sublist .row{display:grid;grid-template-columns:1fr 1fr 120px;gap:8px}
      .bwf-bui-sublist label{display:block;font-weight:600;margin:4px 0}
      .bwf-bui-note{color:#475569}
      .button.gray{background:#f3f4f6;border-color:#e5e7eb;color:#111827}
    </style>

    <div class="bwf-bui-wrap" id="bwfBui"></div>

    <form method="post" action="options.php" id="bwfBuiForm">
      <?php settings_fields('bwf_owner_builder_group'); ?>
      <input type="hidden" name="bwf_owner_builder_json" id="bwfOwnerJson" value="<?php echo esc_attr($raw); ?>">
      <?php submit_button('저장'); ?>
    </form>

    <script>
    (function(){
      const container = document.getElementById('bwfBui');
      const hidden = document.getElementById('bwfOwnerJson');

      // 안전 파서
      function parseJSON(s, fallback){ try{ return JSON.parse(s); }catch(e){ return fallback; } }
      let state = parseJSON(hidden.value, null);
      if(!state || !state.questions){ state = parseJSON(`<?php echo addslashes(bwf_owner_builder_default_json()); ?>`, {}); }

      // 도우미
      const uid = p => (p||'q')+'_'+Math.random().toString(36).slice(2,8);
      const syncHidden = () => hidden.value = JSON.stringify(state); // ★ 모든 변경 즉시 반영

      // 공통 렌더
      function render(){
        container.innerHTML = '';
        const wrap = document.createElement('div');

        // 공통 설정
        const g = document.createElement('div');
        g.className='bwf-bui-row';
        g.innerHTML = `
          <h3>공통 설정</h3>
          <div class="bwf-bui-grid">
            <div>
              <label>폼 제목</label>
              <input type="text" data-global="title" value="${state.title||''}">
            </div>
            <div>
              <label>최소 글자수(기본값)</label>
              <input type="number" min="0" data-global="min_length" value="${state.min_length||200}">
            </div>
            <div style="grid-column:1/-1">
              <label>인트로(HTML 가능) <span class="bwf-bui-note">※ {MIN}은 최소 글자수로 치환</span></label>
              <textarea rows="3" data-global="intro_html">${state.intro_html||''}</textarea>
            </div>
          </div>
        `;
        wrap.appendChild(g);

        // 문항들
        state.questions = state.questions || [];
        state.questions.forEach((q, idx)=>{
          const isGroup = q.type === 'group';
          const row = document.createElement('div');
          row.className = 'bwf-bui-row';
          row.dataset.idx = idx;

          row.innerHTML = `
            <h3>
              <span>문항 ${idx+1}</span>
              <span class="bwf-bui-actions">
                <button class="button button-small" data-act="up">위</button>
                <button class="button button-small" data-act="down">아래</button>
                <button class="button button-small" data-act="del">삭제</button>
              </span>
            </h3>
            <div class="bwf-bui-grid">
              <div>
                <label>라벨(제목)</label>
                <input type="text" data-field="label" value="${q.label||''}">
              </div>
              <div>
                <label>타입</label>
                <select data-field="type">
                  <option value="textarea" ${q.type==='textarea'?'selected':''}>텍스트영역</option>
                  <option value="text" ${q.type==='text'?'selected':''}>한 줄 입력</option>
                  <option value="group" ${q.type==='group'?'selected':''}>그룹(소문항)</option>
                </select>
              </div>
              <div>
                <label>필수</label>
                <select data-field="required">
                  <option value="1" ${(q.required!==false)?'selected':''}>예</option>
                  <option value="0" ${(q.required===false)?'selected':''}>아니오</option>
                </select>
              </div>
              <div>
                <label>최소 글자수(빈칸=공통)</label>
                <input type="number" min="0" data-field="minlength" value="${(q.minlength===''||q.minlength==null)?'':q.minlength}">
              </div>
              <div>
                <label>진행률 카운트(몇 문항으로 계산?)</label>
                <input type="number" min="0" data-field="count_as" value="${(q.count_as==null)?1:q.count_as}">
              </div>
              <div style="grid-column:1/-1">
                <label>설명(HTML 가능)</label>
                <textarea rows="3" data-field="desc_html">${q.desc_html||''}</textarea>
              </div>
              <div style="grid-column:1/-1">
                <label>예시(HTML 가능)</label>
                <textarea rows="4" data-field="examples_html">${q.examples_html||''}</textarea>
              </div>
            </div>

            ${isGroup ? `
              <div class="bwf-bui-sub">
                <h4>소문항 <button class="button button-small" data-act="addSub">추가</button></h4>
                <div class="bwf-bui-sublist">
                  ${(q.sub||[]).map((s,si)=>`
                    <div class="item" data-si="${si}">
                      <div class="row">
                        <div>
                          <label>라벨</label>
                          <input type="text" data-sub="label" value="${s.label||''}">
                        </div>
                        <div>
                          <label>플레이스홀더</label>
                          <input type="text" data-sub="placeholder" value="${s.placeholder||''}">
                        </div>
                        <div>
                          <label>필수</label>
                          <select data-sub="required">
                            <option value="1" ${(s.required!==false)?'selected':''}>예</option>
                            <option value="0" ${(s.required===false)?'selected':''}>아니오</option>
                          </select>
                        </div>
                      </div>
                      <div class="row">
                        <div>
                          <label>서브 ID</label>
                          <input type="text" data-sub="id" value="${s.id||('s_'+si)}">
                        </div>
                        <div>
                          <label>최소 글자수(빈칸=제한없음)</label>
                          <input type="number" min="0" data-sub="minlength" value="${(s.minlength===''||s.minlength==null)?'':s.minlength}">
                        </div>
                        <div class="bwf-bui-actions" style="align-items:end;">
                          <button class="button button-small gray" data-act="subUp">위</button>
                          <button class="button button-small gray" data-act="subDown">아래</button>
                          <button class="button button-small" data-act="subDel">삭제</button>
                        </div>
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : '' }
          `;
          wrap.appendChild(row);
        });

        // 문항 추가 버튼
        const addWrap = document.createElement('p');
        addWrap.innerHTML = `<button class="button button-primary" id="bwfAddQ">문항 추가</button>`;
        wrap.appendChild(addWrap);

        container.appendChild(wrap);
        syncHidden(); // 렌더 후 상태 동기화

        /* 이벤트: 위임 방식으로 안정화 */
        wrap.addEventListener('click', function(e){
          const t = e.target;
          // 문항 추가
          if(t.id==='bwfAddQ'){ e.preventDefault();
            state.questions.push({id:uid('q'),type:'textarea',label:'새 문항',required:true,minlength:'',count_as:1,desc_html:'',examples_html:''});
            render(); return;
          }
          // 행/인덱스 탐색
          const row = t.closest('.bwf-bui-row[data-idx]');
          if(!row) return;
          const i = parseInt(row.dataset.idx,10);
          const q = state.questions[i];

          // 행 액션
          const act = t.dataset.act;
          if(act==='del'){ e.preventDefault(); state.questions.splice(i,1); render(); return; }
          if(act==='up'){ e.preventDefault(); if(i>0){ [state.questions[i-1],state.questions[i]]=[state.questions[i],state.questions[i-1]]; render(); } return; }
          if(act==='down'){ e.preventDefault(); if(i<state.questions.length-1){ [state.questions[i+1],state.questions[i]]=[state.questions[i],state.questions[i+1]]; render(); } return; }
          if(act==='addSub'){ e.preventDefault(); q.sub=q.sub||[]; q.sub.push({id:uid(q.id||'s'),label:'소문항',placeholder:'',required:true,minlength:''}); render(); return; }

          // 소문항 액션
          const item = t.closest('.item[data-si]');
          if(item){
            const si = parseInt(item.dataset.si,10);
            if(act==='subDel'){ e.preventDefault(); q.sub.splice(si,1); render(); return; }
            if(act==='subUp'){ e.preventDefault(); if(si>0){ [q.sub[si-1],q.sub[si]]=[q.sub[si],q.sub[si-1]]; render(); } return; }
            if(act==='subDown'){ e.preventDefault(); if(si<q.sub.length-1){ [q.sub[si+1],q.sub[si]]=[q.sub[si],q.sub[si+1]]; render(); } return; }
          }
        });

        // 값 변경(입력/선택) – 위임
        wrap.addEventListener('input', function(e){
          const el = e.target;
          // 글로벌
          if(el.matches('[data-global]')){
            const k = el.getAttribute('data-global');
            state[k] = (k==='min_length') ? Math.max(0,parseInt(el.value||'0',10)) : el.value;
            syncHidden(); return;
          }
          // 문항
          const row = el.closest('.bwf-bui-row[data-idx]'); if(!row) return;
          const i = parseInt(row.dataset.idx,10); const q = state.questions[i];
          if(el.matches('[data-field]')){
            const k = el.getAttribute('data-field');
            if(k==='required'){ q[k] = (el.value==='1'); }
            else if(k==='minlength' || k==='count_as'){ q[k] = (el.value===''? '' : Math.max(0,parseInt(el.value,10))); }
            else if(k==='type'){ q[k] = el.value; if(q[k]!=='group') delete q.sub; render(); return; } // 타입 변경 즉시 재렌더
            else { q[k] = el.value; }
            syncHidden(); return;
          }
          // 소문항
          const item = el.closest('.item[data-si]');
          if(item && q.type==='group'){
            const si = parseInt(item.dataset.si,10); const s = q.sub[si];
            const sk = el.getAttribute('data-sub');
            if(sk==='required'){ s[sk] = (el.value==='1'); }
            else if(sk==='minlength'){ s[sk] = (el.value===''? '' : Math.max(0,parseInt(el.value,10))); }
            else { s[sk] = el.value; }
            syncHidden(); return;
          }
        });

        // 제출 전 최종 동기화(이중 안전장치)
        document.getElementById('bwfBuiForm').addEventListener('submit', function(){ syncHidden(); });
      }
      render();
    })();
    </script>
  </div>
  <?php
}

`$nl
===== FILE: berrywalk-feedback\includes\admin-profile-fix.php (3755 bytes, 98 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/**
 * 관리자 프로필 UI 복구
 * - WP-Members가 출력하는 문제 섹션/오류 블록 제거(가능하면 서버단 후크도 제거)
 * - 저장 버튼 없을 때 자동 삽입(#your-profile, #createuser 모두 커버)
 */

/* 1) 가능하면 서버단에서 WP-Members 프로필 후크 제거 */
add_action('admin_init', function(){
  foreach (['show_user_profile','edit_user_profile'] as $hook){
    global $wp_filter;
    if (!isset($wp_filter[$hook])) continue;
    $callbacks = $wp_filter[$hook]->callbacks ?? [];
    foreach ($callbacks as $prio => $items){
      foreach ($items as $key => $cb){
        $fn = $cb['function'];
        // 함수명/클래스명/콜러블 문자열에 'wpmem'이 포함되면 제거
        $name = '';
        if (is_string($fn)) $name = $fn;
        elseif (is_array($fn) && is_object($fn[0])) $name = get_class($fn[0]).'::'.$fn[1];
        elseif (is_array($fn)) $name = implode('::', $fn);
        if (stripos($name, 'wpmem') !== false) {
          remove_action($hook, $fn, $prio);
        }
      }
    }
  }
});

/* 2) 프론트 단에서 섹션 숨김 + 저장 버튼 보장 */
function bwf_admin_profile_fix_footer(){
  ?>
  <style>
    /* WP-Members 오류 블록/추가 필드 섹션 숨김(보여도 무해, 저장 방해만 막음) */
    h2:has(+ p + div + p + p + p + p + p + p + p + p + p + p + p + p) {}
  </style>
  <script>
  (function(){
    function ensureSubmit(form){
      if(!form) return;
      if(!form.querySelector('p.submit input[type=submit], .submit input[type=submit]')){
        const p = document.createElement('p'); p.className='submit';
        const btn = document.createElement('input');
        btn.type='submit'; btn.className='button button-primary';
        btn.value='프로필 업데이트';
        p.appendChild(btn);
        form.appendChild(p);
      }
    }
    document.addEventListener('DOMContentLoaded', function(){
      // 1) WP-Members 섹션 헤더 텍스트 찾으면 해당 섹션부터 다음 H2 전까지 숨김
      const headers = Array.from(document.querySelectorAll('h2'));
      headers.forEach(h=>{
        const t = h.textContent.trim();
        if (/WP-?Members\s*추가\s*필드/i.test(t)){
          let el = h; el.style.display='none';
          while (el && el.nextElementSibling && el.nextElementSibling.tagName !== 'H2'){
            el = el.nextElementSibling; el.style.display='none';
          }
        }
      });
      // 2) 저장 버튼 없으면 강제 삽입
      ensureSubmit(document.querySelector('form#your-profile'));
      ensureSubmit(document.querySelector('form#createuser'));
    });
  })();
  </script>
  <?php
}
add_action('admin_footer-profile.php','bwf_admin_profile_fix_footer');
add_action('admin_footer-user-edit.php','bwf_admin_profile_fix_footer');
add_action('admin_footer-user-new.php','bwf_admin_profile_fix_footer');


// 'native' 메타가 배열이면 저장 전에 문자열로 정규화
add_filter('sanitize_user_meta_native', function($val){
  if (is_array($val)) {
    $val = implode(', ', array_filter(array_map('sanitize_text_field', $val)));
  }
  return sanitize_text_field($val);
});

add_action('admin_init', function(){
  if (!current_user_can('manage_options')) return;
  if (!isset($_GET['fix_native'])) return;

  global $wpdb;
  $rows = $wpdb->get_results("SELECT user_id, meta_value FROM {$wpdb->usermeta} WHERE meta_key='native'");
  foreach ($rows as $r) {
    $v = maybe_unserialize($r->meta_value);
    if (is_array($v)) {
      update_user_meta($r->user_id, 'native', implode(', ', array_map('sanitize_text_field',$v)));
    }
  }
});

`$nl
===== FILE: berrywalk-feedback\includes\admin-users.php (2574 bytes, 67 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/** Users 목록 컬럼 */
add_filter('manage_users_columns', function($cols){
  $cols['bw_company_name']='회사명';
  $cols['bw_industry']='업종';
  $cols['bw_phone']='휴대폰';
  $cols['bw_contact']='연락 가능 시간';
  $cols['bw_discover']='유입 경로';
  return $cols;
});
add_filter('manage_users_custom_column', function($val,$col,$user_id){
  switch($col){
    case 'bw_company_name': return esc_html(get_user_meta($user_id,'bw_company_name',true));
    case 'bw_industry':     return esc_html(get_user_meta($user_id,'bw_industry',true));
    case 'bw_phone':        return esc_html(get_user_meta($user_id,'bw_phone',true));
    case 'bw_contact':      return esc_html(get_user_meta($user_id,'bw_contact_window',true));
    case 'bw_discover':     return esc_html(get_user_meta($user_id,'bw_discover',true));
  }
  return $val;
},10,3);

/** 프로필 화면(수정 가능) */
function bwf_admin_profile_block($user){
  $f = function($key,$label) use($user){
    $v = get_user_meta($user->ID,$key,true);
    echo '<tr><th>'.$label.'</th><td><input name="'.$key.'" type="text" class="regular-text" value="'.esc_attr($v).'"></td></tr>';
  };
  echo '<h2>Berrywalk 가입 정보</h2><table class="form-table">';
  $f('bw_company_name','회사명'); $f('bw_industry','업종');
  $f('bw_employees','직원 수');   $f('bw_phone','휴대폰');
  $f('bw_contact_window','연락 가능 시간'); $f('bw_discover','유입 경로');
  echo '</table>';
}
add_action('show_user_profile','bwf_admin_profile_block');
add_action('edit_user_profile','bwf_admin_profile_block');

/** 저장 */
function bwf_save_profile($user_id){
  foreach(['bw_company_name','bw_industry','bw_employees','bw_phone','bw_contact_window','bw_discover'] as $k){
    if (isset($_POST[$k])) update_user_meta($user_id, $k, sanitize_text_field($_POST[$k]));
  }
}
add_action('personal_options_update','bwf_save_profile');
add_action('edit_user_profile_update','bwf_save_profile');

// WP-Members 추가 필드 섹션 임시 숨김(UX 보호)
add_action('admin_print_footer_scripts', function(){
  ?>
  <script>
  jQuery(function($){
    $("h2:contains('WP-Members 추가 필드')").nextUntil("h2").hide().end().hide();
  });
  </script>
  <?php
});


add_action('admin_head', function(){
  echo '<style>
  h2:has(+ table) + .notice-error:has(.error), 
  h2:contains("WP-Members 추가 필드"), 
  h2:contains("WP-Members 추가 필드") ~ * { display:none !important; }
  </style>';
});

`$nl
===== FILE: berrywalk-feedback\includes\crm.php (5786 bytes, 135 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/** 메뉴 */
add_action('admin_menu', function(){
  add_menu_page('베리워크 CRM','베리워크 CRM','manage_options','bwf-crm','bwf_render_crm_page','dashicons-list-view',56);
});

/** 데이터 로더 */
function bwf_get_all_feedbacks(){
  $all = get_option('bwf_feedbacks', []);
  return is_array($all) ? $all : [];
}

/** 화면 */
function bwf_render_crm_page(){
  if (!current_user_can('manage_options')) return;

  /* 일괄 삭제 */
  if ($_SERVER['REQUEST_METHOD']==='POST' && isset($_POST['bwf_crm_bulk'])){
    check_admin_referer('bwf_crm_bulk');
    $ids = array_filter((array)($_POST['sel'] ?? []), 'is_string');
    if ($ids){
      $all = bwf_get_all_feedbacks();
      $all = array_values(array_filter($all, function($r) use($ids){
        $rid = (string)($r['id'] ?? '');
        return ($rid==='' || !in_array($rid,$ids,true));
      }));
      update_option('bwf_feedbacks', $all, false);
      echo '<div class="updated notice is-dismissible"><p>선택 항목을 삭제했습니다.</p></div>';
    }
  }

  /* 검색 */
  $keyword = sanitize_text_field($_GET['s'] ?? '');
  $raw = array_reverse(bwf_get_all_feedbacks());
  $rowsAll = array_filter($raw, function($r) use($keyword){
    if ($keyword==='') return true;
    $u   = get_userdata((int)($r['rep'] ?? 0));
    $hay = implode(' ', array_filter([
      $u? $u->display_name : '',
      $u? $u->user_email   : '',
      wp_json_encode($r['answers'] ?? [], JSON_UNESCAPED_UNICODE)
    ]));
    return mb_stripos($hay, $keyword) !== false;
  });

  /* 페이징 */
  $per=20; $total=count($rowsAll);
  $pages=max(1,(int)ceil($total/$per));
  $paged=max(1,(int)($_GET['paged']??1));
  $start=($paged-1)*$per;
  $rows=array_slice($rowsAll,$start,$per);

  echo '<div class="wrap"><h1>베리워크 CRM</h1>';

  /* 검색폼 */
  echo '<form method="get" style="margin:8px 0 14px"><input type="hidden" name="page" value="bwf-crm">';
  echo '<input type="search" name="s" value="'.esc_attr($keyword).'" placeholder="대표명/이메일/내용 검색"> ';
  echo '<button class="button">검색</button></form>';

  /* 테이블 */
  echo '<form method="post">';
  wp_nonce_field('bwf_crm_bulk');
  echo '<table class="widefat striped"><thead><tr>';
  echo '<th style="width:24px"><input type="checkbox" id="bwfChkAll"></th>';
  echo '<th>시각(서울)</th><th>대표</th><th>작성자ID</th><th>요약</th><th>동작</th>';
  echo '</tr></thead><tbody>';

  if (!$rows){
    echo '<tr><td colspan="6">데이터가 없습니다.</td></tr>';
  } else {
    foreach ($rows as $r){
      $rid = (string)($r['id'] ?? '');
      $rep = (int)($r['rep'] ?? 0);
      $usr = (int)($r['user'] ?? 0);
      $ans = (array)($r['answers'] ?? []);

      // 요약
      $flat=[]; $stack=[$ans];
      while ($stack){ $cur=array_pop($stack); foreach($cur as $v){ is_array($v)?$stack[]=$v:$flat[]=trim((string)$v);} }
      $short = mb_substr(implode(' ', array_filter($flat)),0,120) . (count($flat)?'…':'');

      // 시간(서울)
      $ts = isset($r['ts']) ? (int)$r['ts'] : strtotime((string)($r['t'] ?? 'now'));
      $t_local = function_exists('bwf_fmt') ? bwf_fmt($ts) : wp_date('Y-m-d H:i:s',$ts);

      // 대표명
      $repname=''; if($rep){ $u=get_userdata($rep); if($u){ $repname=$u->display_name.' ('.$u->user_email.')'; } }

      // 개별 삭제
      $del = $rid!=='' ? wp_nonce_url(admin_url('admin-post.php?action=bwf_crm_del&id='.$rid),'bwf_crm_del_'.$rid) : '';

      echo '<tr>';
      echo '<td>'.($rid!==''?'<input type="checkbox" name="sel[]" value="'.esc_attr($rid).'">':'').'</td>';
      echo '<td>'.esc_html($t_local).'</td>';
      echo '<td>'.esc_html($repname).'</td>';
      echo '<td>'.esc_html($usr).'</td>';
      echo '<td>'.esc_html($short).'</td>';
      echo '<td>'.($rid!==''?'<a class="button button-small" href="'.$del.'" onclick="return confirm(\'삭제할까요?\')">삭제</a>':'').'</td>';
      echo '</tr>';
    }
  }
  echo '</tbody></table>';
  echo '<p><button class="button button-secondary" name="bwf_crm_bulk" value="1" onclick="return confirm(\'선택 항목을 삭제할까요?\')">선택 삭제</button></p>';
  echo '</form>';

  /* 페이지네이션 */
  if ($pages>1){
    $base = remove_query_arg('paged');
    echo '<div class="tablenav"><div class="tablenav-pages">';
    echo '<span class="displaying-num">총 '.intval($total).'개</span> <span class="pagination-links">';
    if ($paged>1) echo '<a class="tablenav-pages-navspan" href="'.esc_url(add_query_arg('paged',$paged-1,$base)).'">‹</a> ';
    echo '<span class="paging-input">'.$paged.' / '.$pages.'</span>';
    if ($paged<$pages) echo ' <a class="tablenav-pages-navspan" href="'.esc_url(add_query_arg('paged',$paged+1,$base)).'">›</a>';
    echo '</span></div></div>';
  }
  echo '</div>';

  /* 전체선택 스크립트 */
  echo '<script>document.getElementById("bwfChkAll")?.addEventListener("change",e=>{document.querySelectorAll(\'input[name="sel[]"]\').forEach(c=>c.checked=e.target.checked);});</script>';
}

/** 개별 삭제 핸들러 */
add_action('admin_post_bwf_crm_del', function(){
  if (!current_user_can('manage_options')) wp_die('forbidden');
  $id = sanitize_text_field($_GET['id'] ?? '');
  $ok = isset($_GET['_wpnonce']) && wp_verify_nonce($_GET['_wpnonce'], 'bwf_crm_del_'.$id);
  if (!$ok || !$id){ wp_safe_redirect(admin_url('admin.php?page=bwf-crm')); exit; }
  $all = bwf_get_all_feedbacks();
  $all = array_values(array_filter($all, fn($r)=>(string)($r['id']??'')!==$id));
  update_option('bwf_feedbacks', $all, false);
  wp_safe_redirect(admin_url('admin.php?page=bwf-crm')); exit;
});

`$nl
===== FILE: berrywalk-feedback\includes\feedback-form.php (6625 bytes, 126 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

add_shortcode('bw_feedback_form', function () {
  wp_enqueue_style('bwf-forms');
  wp_enqueue_script('bwf-feedback');

  $rep_id = intval($_GET['rep'] ?? 0);
if (!$rep_id) return '<p>유효하지 않은 요청입니다.</p>';

    // ✅ 대표가 저장한 질문 세트 로드
    $qset = get_user_meta($rep_id, 'bwf_questions', true);
    $qset = is_array($qset) ? $qset : [];
    $problem   = $qset['problem']        ?? '';
    $value     = $qset['value']          ?? '';
    $ideal     = $qset['ideal_customer'] ?? '';
    $q1        = $qset['q1'] ?? '';
    $q2        = $qset['q2'] ?? '';
    $q3        = $qset['q3'] ?? '';
    $oneQ      = $qset['one_question']   ?? '';
    $diff      = $qset['competitors']    ?? '';

  // 대표가 작성한 3가지 질문 불러오기(예: user_meta 또는 post_meta에서 가져오는 부분은 기존 로직 유지)
  // 아래는 예시. 실제 저장 위치에 맞춰 수정하세요.
  $q1 = get_user_meta($rep_id, 'bw_q1', true);
  $q2 = get_user_meta($rep_id, 'bw_q2', true);
  $q3 = get_user_meta($rep_id, 'bw_q3', true);

  // 저장 처리
  if ($_SERVER['REQUEST_METHOD']==='POST' && isset($_POST['bwf_submit'])) {
    $answers = array_map('sanitize_textarea_field', $_POST['answer'] ?? []);
    $all = get_option('bwf_feedbacks', []);
    if (!is_array($all)) $all = [];
    $all[] = [
      'id'      => uniqid('fb_', true),
      'ts'      => bwf_now_ts(),          // ← 숫자 타임스탬프
      't'       => bwf_now_str(),         // ← 문자열(가독용)
      'rep'     => $rep_id,
      'user'    => get_current_user_id(),
      'answers' => $answers,
    ];
    update_option('bwf_feedbacks', $all, false);
    wp_redirect(home_url('/feedback-thanks/'));
    exit;
  }

  ob_start(); ?>
  <form method="post" class="bwf-form">
    <div class="bwf-sticky bwf-col-full">
      <div class="bwf-topcount">작성 <span class="done">0</span>/<span class="total">0</span>문항</div>
      <div id="bwf-progress"><div class="bar"></div><span class="label"></span></div>
    </div>

    <h2 class="bwf-col-full">대표 질문 요약</h2>
    <ul class="bwf-rep">
    <li><b>① 가장 큰 고민:</b> <?php echo esc_html($problem); ?></li>
    <li><b>② 핵심 가치(대표 생각):</b> <?php echo esc_html($value); ?></li>
    <li><b>③ 이상적 타겟:</b> <?php echo esc_html($ideal); ?></li>
    <li><b>④-1 맞춤 질문:</b> <?php echo esc_html($q1); ?></li>
    <li><b>④-2 맞춤 질문:</b> <?php echo esc_html($q2); ?></li>
    <li><b>④-3 맞춤 질문:</b> <?php echo esc_html($q3); ?></li>
    <li><b>⑤ 1:1 한 가지:</b> <?php echo esc_html($oneQ); ?></li>
    <li><b>⑥ 경쟁사/차별:</b> <?php echo esc_html($diff); ?></li>
    </ul>


    <!-- 1 -->
    <div class="bwf-col-full bwf-field">
      <label>현재 비즈니스에서 가장 큰 고민은 무엇인가요? <span class="bwf-required">*</span></label>
      <textarea name="answer[biggest_pain]" data-minlength="100" rows="5" placeholder="예: 신규 고객 유입이 너무 어렵습니다. 광고 효율이 안 나와요."></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>

    <!-- 2 -->
    <div class="bwf-col-full bwf-field">
      <label>우리 서비스가 고객의 ‘어떤 문제’를 해결하나요? <span class="bwf-required">*</span></label>
      <textarea name="answer[problem_to_solve]" data-minlength="100" rows="5" placeholder="예: 바쁜 직장인에게 집밥처럼 건강한 한 끼를 배달해주는 것"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>

    <!-- 3 -->
    <div class="bwf-col-full bwf-field">
      <label>이 서비스를 ‘누가’ 이용해야 하나요? 왜 우리를 선택하나요? <span class="bwf-required">*</span></label>
      <textarea name="answer[target_why]" data-minlength="100" rows="5" placeholder="예: 운동은 하고 싶지만 시간/비용이 부족한 20대 대학생…"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>

    <!-- 4: 고객에게 물어보고 싶은 3가지(=1문항으로 카운트) -->
    <div class="bwf-col-full">
      <h3>고객에게 물어보고 싶은 3가지 (아래 3개가 모두 작성되면 1문항으로 계산)</h3>
    </div>
    <div class="bwf-col-full bwf-field">
      <textarea name="answer[q1]" data-minlength="100" data-group="ask3" rows="4" placeholder="질문 1"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>
    <div class="bwf-col-full bwf-field">
      <textarea name="answer[q2]" data-minlength="100" data-group="ask3" rows="4" placeholder="질문 2"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>
    <div class="bwf-col-full bwf-field">
      <textarea name="answer[q3]" data-minlength="100" data-group="ask3" rows="4" placeholder="질문 3"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>

    <!-- 5 -->
    <div class="bwf-col-full bwf-field">
      <label>타겟 고객 1:1로 단 한 가지를 묻는다면? <span class="bwf-required">*</span></label>
      <textarea name="answer[one_question]" data-minlength="100" rows="4" placeholder="예: 우리 서비스의 어떤 점이 가장 도움이 되었나요?"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>

    <!-- 6 -->
    <div class="bwf-col-full bwf-field">
      <label>경쟁사와의 차별점은? <span class="bwf-required">*</span></label>
      <textarea name="answer[differentiation]" data-minlength="100" rows="4" placeholder="예: A사는 저렴하지만 품질 낮음… 우리는 적정 가격에 높은 만족도…"></textarea>
      <div class="bwf-helper"><span class="bwf-guide">최소 100자</span><span class="bwf-counter"></span></div>
    </div>

    <div class="bwf-col-full bwf-actions">
      <button type="submit" name="bwf_submit">저장</button>
      <p class="bwf-hint">각 항목 최소 100자 이상 작성</p>
    </div>
  </form>
  <?php return ob_get_clean();
});

`$nl
===== FILE: berrywalk-feedback\includes\helper.php (2199 bytes, 49 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/** 옵션 셋 */
function bwf_industry_options(){
  return [
    'it_saas'=>'IT / SaaS','commerce'=>'커머스/쇼핑몰','food'=>'외식/식품','beauty'=>'뷰티/헬스',
    'education'=>'교육/강의','local'=>'로컬서비스','consulting'=>'컨설팅/대행','finance'=>'금융/핀테크','etc'=>'기타'
  ];
}

function bwf_tz(){ return new DateTimeZone('Asia/Seoul'); }
function bwf_now_ts(){ return (new DateTime('now', bwf_tz()))->getTimestamp(); }
function bwf_now_str(){ return wp_date('Y-m-d H:i:s', null, bwf_tz()); }
function bwf_fmt($ts,$fmt='Y-m-d H:i:s'){ return wp_date($fmt, $ts, bwf_tz()); }

function bwf_source_options(){
  return [
    'instagram'=>'인스타그램','youtube'=>'유튜브','search'=>'검색(네이버/구글)',
    'referral'=>'지인 추천','blog'=>'블로그/커뮤니티','event'=>'세미나/이벤트','ads'=>'광고(배너/DA/SA)',
    'etc'=>'기타(직접 입력)'
  ];
}
function bwf_social_fields(){
  return [
    'instagram_url'=>'인스타그램','facebook_url'=>'페이스북','youtube_url'=>'유튜브',
    'naver_blog_url'=>'네이버 블로그','kakao_channel_url'=>'카카오 채널','tiktok_url'=>'틱톡'
  ];
}

/** 안전 출력/입력 */
function bwf_esc($v){ return esc_html(trim((string)$v)); }
function bwf_post($k,$default=''){ return isset($_POST[$k]) ? wp_unslash($_POST[$k]) : $default; }
function bwf_text($k,$default=''){ return sanitize_text_field(bwf_post($k,$default)); }
function bwf_textarea($k,$default=''){ return sanitize_textarea_field(bwf_post($k,$default)); }

/** 휴대폰 하이픈 자동 포맷 */
function bwf_format_phone($digits){
  $n = preg_replace('/\D+/','',$digits);
  if (strpos($n,'02') === 0) { // 서울번호 예외
    if (strlen($n) >= 10) return preg_replace('/^(\d{2})(\d{4})(\d{4}).*/','$1-$2-$3',$n);
    if (strlen($n) >= 9)  return preg_replace('/^(\d{2})(\d{3})(\d{4}).*/','$1-$2-$3',$n);
  }
  // 010 등
  if (strlen($n) >= 11) return preg_replace('/^(\d{3})(\d{4})(\d{4}).*/','$1-$2-$3',$n);
  if (strlen($n) >= 10) return preg_replace('/^(\d{3})(\d{3})(\d{4}).*/','$1-$2-$3',$n);
  return $n;
}

`$nl
===== FILE: berrywalk-feedback\includes\my-questions.php (3551 bytes, 90 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

add_shortcode('bw_my_questions', function(){
  if (!is_user_logged_in()) return '<div class="bwf-form"><p>로그인 후 이용해주세요.</p></div>';
  wp_enqueue_style('bwf-forms');

  $uid  = get_current_user_id();
  $page = max(1, intval($_GET['pg'] ?? 1));
  $per  = 10;

  $q = new WP_Query([
    'post_type'      => 'bwf_owner_answer',
    'author'         => $uid,
    'posts_per_page' => $per,
    'paged'          => $page,
    'orderby'        => 'date',
    'order'          => 'DESC',
  ]);

  ob_start();
  echo '<style>.bwf-topwrap{display:none!important}</style>';  // 이 페이지에서만 진행현황 숨김

  echo '<div class="bwf-form"><h2>내 질문 저장본</h2>';

  if (!$q->have_posts()){
    echo '<p>아직 저장한 질문이 없습니다.</p></div>'; return ob_get_clean();
  }

  echo '<ul class="bwf-list">';
  while ($q->have_posts()){ $q->the_post();
    $pid  = get_the_ID();
    $ans  = (array) get_post_meta($pid,'bwf_answers', true);

    // 요약(문자만 뽑기)
    $flat = [];
    $stack = [$ans];
    while ($stack) {
      $cur = array_pop($stack);
      foreach ($cur as $v) {
        if (is_array($v)) $stack[] = $v;
        else $flat[] = trim((string)$v);
      }
    }
    $short = mb_substr(implode(' ', array_filter($flat)), 0, 140) . (count($flat) ? '…' : '');

    $view = esc_url( add_query_arg(['id'=>$pid], home_url('/my-question-view/')) ); // [bwf_owner_view id=".."] 페이지에 매핑
    $del  = esc_url( wp_nonce_url( admin_url('admin-post.php?action=bwf_owner_delete&id='.$pid),
                                   'bwf_owner_delete_'.$pid ) );

    $u = get_post_time('U', true, $pid);           // GMT 기준 타임스탬프
    $time_local = wp_date('Y-m-d H:i', $u);        // 사이트 타임존으로 포맷

    echo '<li>';
    echo '<span class="bwf-time">'.esc_html($time_local).'</span>';
    echo '<span class="bwf-sum">'.esc_html($short).'</span> ';
    echo '<a class="bwf-btn-secondary" href="'.$view.'">보기</a> ';
    echo '<a class="bwf-btn-secondary" href="'.$del.'" onclick="return confirm(\'삭제할까요?\')">삭제</a>';
    echo '</li>';
  }
  wp_reset_postdata();
  echo '</ul>';

  // 페이지네이션
  $maxp = max(1, intval($q->max_num_pages));
  echo '<div class="bwf-pager">';
  if ($page>1) echo '<a class="bwf-btn-secondary" href="'.esc_url(add_query_arg('pg',$page-1)).'">이전</a>';
  echo '<span class="bwf-page"> '.$page.' / '.$maxp.' </span>';
  if ($page<$maxp) echo '<a class="bwf-btn-secondary" href="'.esc_url(add_query_arg('pg',$page+1)).'">다음</a>';
  echo '</div>';

  echo "<p style='margin-top:14px'><a class='bwf-btn' href='".esc_url(home_url('/owner-questions/'))."'>새 질문 작성</a></p></div>";
  return ob_get_clean();
});

add_action('admin_post_bwf_owner_delete', function(){
  if (!is_user_logged_in()) wp_safe_redirect( home_url('/') );
  $pid = absint($_GET['id'] ?? 0);
  if (!$pid || get_post_type($pid) !== 'bwf_owner_answer') wp_safe_redirect( home_url('/') );

  $nonce_ok = isset($_GET['_wpnonce']) && wp_verify_nonce($_GET['_wpnonce'], 'bwf_owner_delete_'.$pid);
  if (!$nonce_ok) wp_safe_redirect( home_url('/') );

  $author = (int) get_post_field('post_author', $pid);
  if ( get_current_user_id() === $author || current_user_can('delete_others_posts') ) {
    wp_delete_post($pid, true);
  }
  wp_safe_redirect( wp_get_referer() ?: home_url('/my-questions/') ); exit;
});

`$nl
===== FILE: berrywalk-feedback\includes\owner-questions.php (21038 bytes, 447 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/**
 * 대표 질문지: 개별 저장(CPT) + 필수 검증 + 중복 방지 + 보기 템플릿
 * - CPT: bwf_owner_answer (비공개, 관리자에서만 목록 확인)
 * - Shortcode: [bwf_owner_questions]  (작성 폼)
 * - Shortcode: [bwf_owner_view id="123"] (보기 화면)
 * - 저장 성공 후 리다이렉트 URL: BWF_OWNER_AFTER_SAVE_URL 상수로 제어
 */

if (!defined('BWF_OWNER_AFTER_SAVE_URL')) {
  define('BWF_OWNER_AFTER_SAVE_URL', home_url('/')); // ← 저장 후 보낼 URL(원하면 바꿔)
}

/* --------------------------------------------------------------------------
   0) 질문지 구성 로드 (관리자 빌더 옵션 사용, 없으면 기본값)
-------------------------------------------------------------------------- */
function bwf_owner_default_config_array(){
  return [
    "title" => "대표님 핵심 질문지",
    "intro_html" => "사업의 본질을 파악하고 고객에게 정말 묻고 싶은 질문을 구체화합니다. 각 문항은 최소 <strong>{MIN}</strong>자입니다. <em>(단, <strong>“고객에게 물어보고 싶은 3가지”</strong>는 글자수 제한 없음)</em>",
    "min_length" => 200,
    "questions" => [
      [
        "id"=>"problem","type"=>"textarea","label"=>"1. 지금, 우리 사업의 가장 큰 고민은 무엇인가요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 현재 가장 답답하거나 성장이 정체되었다고 느끼는 구체적인 상황을 한두 문장으로 설명해 주세요. 예: “광고는 많이 했는데…” 등 숫자/행동 기반.",
        "examples_html"=>"<ul><li>“최근 인스타그램 광고 효율이 너무 안 나와요. 클릭은 많은데, 저희 웹사이트에 1분도 머물지 않고 나가는 사람이 많아요.”</li><li>“기존 고객들의 재구매율이 낮아서, 항상 새로운 고객을 찾아야 하는 부담이 큽니다.”</li></ul>"
      ],
      [
        "id"=>"value","type"=>"textarea","label"=>"2. 우리 서비스는 고객의 ‘어떤 문제’를 해결해주고 있나요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 고객의 전/후 변화를 떠올려 가장 중요한 <strong>가치</strong>를 한 문장으로.",
        "examples_html"=>"<ol><li>“서류 작업을 5분 만에 자동화 → 본업 집중.”</li><li>“바쁜 직장인에게 집밥 같은 건강한 한 끼 제공.”</li></ol>"
      ],
      [
        "id"=>"ideal_customer","type"=>"textarea","label"=>"3. 우리 서비스를 ‘누가’ 이용해야 하나요? 왜 우리를 선택하나요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 가장 잘 맞는 사람의 특징 + 우리를 고를 <strong>결정적 이유</strong>.",
        "examples_html"=>"<p>“시간·비용이 부족한 <strong>20대 대학생</strong> → 15분 홈트 영상으로 해결.”</p>"
      ],
      [
        "id"=>"ask3","type"=>"group","label"=>"4. 고객에게 물어보고 싶은 3가지","required"=>true,"count_as"=>1,
        "desc_html"=>"대표님이 고객에게 직접 묻고 싶은 핵심 질문 3가지를 작성하세요. 경험한 내용을 바탕으로 구체적으로.",
        "examples_html"=>"<p><strong>상품</strong></p><ul><li>“처음 받았을 때 어떤 느낌이었나요? (포장/디자인/첫 경험)”</li><li>“가장 만족/아쉬웠던 점은?”</li></ul><p><strong>서비스</strong></p><ul><li>“무료체험 때 최고의 포인트/아쉬웠던 점?”</li></ul>",
        "sub" => [
          ["id"=>"q1","label"=>"질문 1","placeholder"=>"예: 우리 서비스를 알게 된 경로는 무엇이었나요?","required"=>true,"minlength"=>0],
          ["id"=>"q2","label"=>"질문 2","placeholder"=>"예: 결심 포인트는 무엇이었나요?","required"=>true,"minlength"=>0],
          ["id"=>"q3","label"=>"질문 3","placeholder"=>"예: 사용 중 가장 불편했던 점은?","required"=>true,"minlength"=>0]
        ]
      ],
      [
        "id"=>"competitors","type"=>"textarea","label"=>"5. 현재 경쟁사는 어디이며, 그들과의 차별점은 무엇이라고 생각하시나요?","required"=>true,"minlength"=>200,"count_as"=>1,
        "desc_html"=>"설명: 주요 경쟁사 1~2곳과 비교해 강·약점을 정리.",
        "examples_html"=>"<p>“A는 저렴하지만 품질이 낮고, B는 비싸지만 품질이 높다 → 우리는 <strong>적정 가격 + 높은 만족</strong>.”</p>"
      ]
    ]
  ];
}
function bwf_owner_get_config(){
  $raw = get_option('bwf_owner_builder_json', '');
  if (!$raw) return bwf_owner_default_config_array();
  $arr = json_decode($raw, true);
  if (!is_array($arr) || empty($arr['questions'])) return bwf_owner_default_config_array();
  return $arr;
}



/* --------------------------------------------------------------------------
   1) CPT 등록: bwf_owner_answer (개별 저장)
-------------------------------------------------------------------------- */
add_action('init', function(){
  register_post_type('bwf_owner_answer', [
    'labels' => ['name'=>'대표 질문','singular_name'=>'대표 질문'],
    'public' => false,
    'show_ui' => true,
    'show_in_menu' => true,
    'menu_icon' => 'dashicons-feedback',
    'supports' => ['title','author'],
    'capability_type' => 'post',
    'map_meta_cap' => true,
  ]);
});

/* --------------------------------------------------------------------------
   2) 단건 보기: [bwf_owner_view id="123"]
   - 예시는 숨기고 질문/답변만 표시 (폼과 동일 톤)
-------------------------------------------------------------------------- */
add_shortcode('bwf_owner_view', function($atts){
  $id = intval($atts['id'] ?? ($_GET['id'] ?? 0)); // ← GET?id= 도 허용
  if (!$id) return '';
  $post = get_post($id);
  if (!$post || $post->post_type!=='bwf_owner_answer') return '';
  wp_enqueue_style('bwf-forms');


  $cfg = bwf_owner_get_config();
  $answers = (array) get_post_meta($id, 'bwf_answers', true);

  ob_start(); ?>
  <div class="bwf-form bwf-owner">
    <h2 class="bwf-title"><?php echo esc_html($cfg['title'] ?? '대표 질문 보기'); ?></h2>

    <?php foreach(($cfg['questions'] ?? []) as $q): ?>
      <div class="bwf-field">
        <label><?php echo esc_html($q['label']); ?></label>
        <?php if(($q['type'] ?? 'textarea') === 'group'): ?>
          <?php foreach(($q['sub'] ?? []) as $sub): 
            $v = trim((string)($answers[$q['id']][$sub['id']] ?? '')); ?>
            <div class="bwf-sub">
              <div style="font-weight:600;margin:8px 0 6px;"><?php echo esc_html($sub['label']); ?></div>
              <div class="bwf-card"><?php echo nl2br(esc_html($v)); ?></div>
            </div>
          <?php endforeach; ?>
        <?php else: 
          $v = trim((string)($answers[$q['id']] ?? '')); ?>
          <div class="bwf-card"><?php echo nl2br(esc_html($v)); ?></div>
        <?php endif; ?>
      </div>
    <?php endforeach; ?>
  </div>
  <?php
  return ob_get_clean();
});

/* --------------------------------------------------------------------------
   3) 작성 폼: [bwf_owner_questions]
   - 새 글은 항상 빈 값(이전 값 자동채움 없음)
   - 필수/글자수 미충족 시 저장 차단 + 모달 + 빨간 테두리 + 스크롤
   - 중복 제출 방지(트랜지언트 락 + 버튼 비활성)
-------------------------------------------------------------------------- */
add_shortcode('bwf_owner_questions', function(){
  if (!is_user_logged_in()) return '<div class="bwf-form">로그인이 필요합니다.</div>';
  $cfg = bwf_owner_get_config();
  $min = intval($cfg['min_length'] ?? 200);
  $nonce = wp_create_nonce('bwf_owner_save');
  $err  = isset($_POST['bwf_q_error']) ? sanitize_text_field($_POST['bwf_q_error']) : '';
  $old  = isset($_POST['q']) ? (array) $_POST['q'] : []; // 검증 실패 후 재표시용

  wp_enqueue_style('bwf-forms');
  wp_enqueue_script('bwf-owner');

  ob_start(); ?>
  <form id="bwfOwnerForm" method="post" action="<?php echo esc_url( admin_url('admin-post.php') ); ?>">
    <input type="hidden" name="action" value="bwf_owner_save">
    <input type="hidden" name="bwf_submission" value="<?php echo esc_attr( wp_generate_uuid4() ); ?>">
    <?php wp_nonce_field('bwf_owner_save','bwf_owner_nonce'); ?>


    <h2 class="bwf-title"><?php echo esc_html($cfg['title'] ?? '대표님 핵심 질문지'); ?></h2>
    <p class="bwf-help">
      <?php
        $intro = (string)($cfg['intro_html'] ?? '');
        $intro = str_replace('{MIN}', $min, $intro);
        echo wp_kses_post($intro);
      ?>
    </p>

    <div class="bwf-topwrap">
      <div class="bwf-top-title"><b>작성</b> <span class="done">0</span>/<span class="total"><?php
        $t = 0; foreach(($cfg['questions'] ?? []) as $q){ $t += intval($q['count_as'] ?? 1); } echo intval($t);
      ?></span>문항</div>
      <div id="bwf-progress"><div class="bar" style="width:0%"></div></div>
    </div>

    <?php foreach(($cfg['questions'] ?? []) as $q): 
      $qid = esc_attr($q['id']);
      $req = !isset($q['required']) || $q['required'];     // 기본 필수
      $ml  = $q['minlength'] ?? $min;
      $type = $q['type'] ?? 'textarea';
      $desc = $q['desc_html'] ?? '';
      $ex   = $q['examples_html'] ?? '';
    ?>
      <div class="bwf-field">
        <label><?php echo esc_html($q['label']); ?><?php if($req): ?> <span class="bwf-required">*</span><?php endif; ?></label>
        <?php if($desc): ?><div class="bwf-desc"><?php echo wp_kses_post($desc); ?></div><?php endif; ?>
        <?php if($ex): ?><div class="bwf-examples"><?php echo wp_kses_post($ex); ?></div><?php endif; ?>

        <?php if($type==='group'): ?>
          <?php foreach(($q['sub'] ?? []) as $sub):
            $sid = esc_attr($sub['id']); $pl = esc_attr($sub['placeholder'] ?? '');
            $sreq = !isset($sub['required']) || $sub['required'];
            $val = isset($old[$qid][$sid]) ? (string)$old[$qid][$sid] : '';
          ?>
            <div class="bwf-sub">
              <div style="font-weight:600;margin:8px 0 6px;"><?php echo esc_html($sub['label'] ?? ''); ?><?php if($sreq): ?> <span class="bwf-required">*</span><?php endif; ?></div>
              <textarea name="q[<?php echo $qid; ?>][<?php echo $sid; ?>]" rows="3" <?php echo $sreq?'required':''; ?> placeholder="<?php echo $pl; ?>"><?php echo esc_textarea($val); ?></textarea>            </div>
          <?php endforeach; ?>
        <?php else:
          $val = isset($old[$qid]) ? (string)$old[$qid] : '';
        ?>
          <textarea name="q[<?php echo $qid; ?>]" rows="5" <?php echo $req?'required':''; ?> minlength="<?php echo intval($ml); ?>" placeholder="내용을 입력하세요."><?php echo esc_textarea($val); ?></textarea>
        <?php endif; ?>
      </div>
    <?php endforeach; ?>

    <div class="bwf-actions">
      <button type="submit" class="bwf-btn" id="bwfOwnerSubmit">저장하기</button>
    </div>

    <!-- 에러 모달 -->
    <div class="bwf-modal" id="bwf-modal" aria-hidden="true">
      <div class="bwf-modal__card">
        <h3>입력이 필요한 항목이 있어요</h3>
        <p class="bwf-modal__msg"><?php echo $err ? esc_html($err) : '필수 항목을 확인해 주세요.'; ?></p>
        <div class="bwf-modal__actions">
          <button type="button" class="bwf-btn" id="bwf-modal-ok">확인</button>
        </div>
      </div>
    </div>

    <script>
        (function(){
        const form  = document.getElementById('bwfOwnerForm');
        const btn   = form?.querySelector('button[type=submit],input[type=submit]');
        const bar   = document.querySelector('#bwf-progress .bar');
        const total = parseInt(document.querySelector('.bwf-top-title .total')?.textContent || '0', 10);
        const doneEl= document.querySelector('.bwf-top-title .done');

        function clearFieldError(wrap){
            wrap.classList.remove('bwf-error');
            const ta = wrap.querySelector('textarea');
            if (ta) ta.classList.remove('bwf-error');
        }
        function setFieldError(wrap){
            wrap.classList.add('bwf-error');
            const ta = wrap.querySelector('textarea');
            if (ta) ta.classList.add('bwf-error'); // ← textarea만 빨강, 예시 박스엔 영향 없음
        }
        function isValidTextarea(el){
            const v = (el.value || '').trim();
            return v.length > 0;
            }
        function refreshProgress(){
            const units = [...form.querySelectorAll('.bwf-field')];
            let done = 0;
            units.forEach(w=>{
            const subs = w.querySelectorAll('.bwf-sub textarea');
            if (subs.length){
                let all = true;
                subs.forEach(s=>{ if ((s.value||'').trim()==='') all=false; });
                if (all) done++;
            }else{
                const el = w.querySelector('textarea');
                if (el && isValidTextarea(el)) done++;
            }
            });
            const pct = total>0 ? Math.round((done/total)*100) : 0;
            if (doneEl) doneEl.textContent = String(done);
            if (bar) bar.style.width = pct + '%';
        }

        // 입력 시 즉시 에러 해제 + 진행률 갱신
        form.querySelectorAll('textarea').forEach(el=>{
            el.addEventListener('input', ()=>{
            const wrap = el.closest('.bwf-field');
            if (isValidTextarea(el)) clearFieldError(wrap);
            refreshProgress();
            });
        });
        refreshProgress();

        form.addEventListener('submit', function(e){
            let firstBad = null;
            form.querySelectorAll('.bwf-field').forEach(w=>clearFieldError(w));

            // 일반 문항
            form.querySelectorAll('.bwf-field textarea[required]').forEach(el=>{
            if (!isValidTextarea(el)) { if(!firstBad) firstBad = el; setFieldError(el.closest('.bwf-field')); }
            });
            // 그룹 문항
            form.querySelectorAll('.bwf-field .bwf-sub textarea[required]').forEach(el=>{
            if ((el.value||'').trim()===''){ if(!firstBad) firstBad = el; setFieldError(el.closest('.bwf-field')); }
            });

            if(firstBad){
            e.preventDefault();
            btn?.removeAttribute('aria-busy'); btn?.removeAttribute('disabled');
            alert('필수 항목을 확인해주세요.');
            firstBad.scrollIntoView({behavior:'smooth', block:'center'}); firstBad.focus();
            }else{
            btn?.setAttribute('aria-busy','true'); btn?.setAttribute('disabled','disabled');
            }
        });
        })();
        </script>


  </form>
  <?php
  return ob_get_clean();
});

/* --------------------------------------------------------------------------
   4) 저장 처리: 서버 검증 + 중복제출 방지 + 개별 포스트 생성
-------------------------------------------------------------------------- */
// add_action('init', function(){
//   if (!isset($_POST['bwf_owner_action']) || $_POST['bwf_owner_action']!=='save') return;

//   if (!is_user_logged_in()) return;
//   if (!wp_verify_nonce($_POST['bwf_owner_nonce'] ?? '', 'bwf_owner_save')) return;

//   // 중복 제출 락(사용자+nonce 기준, 30초)
//   $uid = get_current_user_id();
//   $nonce = sanitize_text_field($_POST['bwf_owner_nonce']);
//   $lock_key = "bwf_owner_lock_{$uid}_".md5($nonce);
//   if (get_transient($lock_key)) return;
//   set_transient($lock_key, 1, 30);

//   $cfg = bwf_owner_get_config();
//   $min = intval($cfg['min_length'] ?? 200);
//   $q   = isset($_POST['q']) ? (array) $_POST['q'] : [];

//   // 서버 검증
//   $errors = [];
//   foreach(($cfg['questions'] ?? []) as $qq){
//     $id = $qq['id']; $type = $qq['type'] ?? 'textarea';
//     $required = !isset($qq['required']) || $qq['required'];
//     if ($type === 'group'){
//       foreach(($qq['sub'] ?? []) as $sub){
//         $sid = $sub['id']; $sreq = !isset($sub['required']) || $sub['required'];
//         $val = trim((string)($q[$id][$sid] ?? ''));
//         if ($sreq && $val===''){ $errors[] = "{$qq['label']} - {$sub['label']}을(를) 입력해 주세요."; }
//       }
//     } else {
//       $val = trim((string)($q[$id] ?? ''));
//       $ml  = intval($qq['minlength'] ?? $min);
//       if ($required && $val===''){ $errors[] = "{$qq['label']}을(를) 입력해 주세요."; }
//       if ($ml > 0 && mb_strlen($val) < $ml){ $errors[] = "{$qq['label']}은(는) 최소 {$ml}자 이상 작성해 주세요."; }
//     }
//   }

//   if (!empty($errors)){
//     $_POST['bwf_q_error'] = implode(' / ', $errors); // 폼에서 모달로 표시
//     return;
//   }

//   // 저장(항상 새 글 생성 → 기존 글 덮어쓰기/일괄변경 방지)
//   $post_id = wp_insert_post([
//     'post_type'   => 'bwf_owner_answer',
//     'post_title'  => '대표 질문 - '. current_time('Y-m-d H:i:s'),
//     'post_status' => 'publish',
//     'post_date'   => bwf_now_str(),
//     'post_date_gmt' => null,
//     'post_author' => $uid,
//   ], true);
//   if (is_wp_error($post_id)){
//     $_POST['bwf_q_error'] = $post_id->get_error_message();
//     return;
//   }
//   // JSON 그대로 저장
//   update_post_meta($post_id, 'bwf_answers', bwf_sanitize_deep($q));

//   // 완료 → 리다이렉트
//   wp_redirect(BWF_OWNER_AFTER_SAVE_URL);
//   exit;
// });

/* 배열 value 전체 sanitize */
function bwf_sanitize_deep($val){
  if (is_array($val)){ foreach($val as $k=>$v){ $val[$k] = bwf_sanitize_deep($v); } return $val; }
  return sanitize_textarea_field((string)$val);
}


// ── 1) 서울 타임존 유틸 (없으면 추가)


// ── 2) 저장 핸들러 (표준 endpoint: admin-post.php?action=bwf_owner_save)
function bwf_owner_handle_save(){
  if ($_SERVER['REQUEST_METHOD'] !== 'POST') return;

  if (!is_user_logged_in()){
    wp_safe_redirect( wp_login_url( wp_get_referer() ?: home_url('/') ) ); exit;
  }

  // nonce 검증
  $nonce = $_POST['bwf_owner_nonce'] ?? '';
  if (!wp_verify_nonce($nonce, 'bwf_owner_save')){
    wp_safe_redirect( add_query_arg('err','nonce', wp_get_referer() ?: home_url('/') ) ); exit;
  }

  $uid = get_current_user_id();
  $sub = sanitize_text_field($_POST['bwf_submission'] ?? '');
  if (!$sub){
    wp_safe_redirect( add_query_arg('err','submission', wp_get_referer() ?: home_url('/') ) ); exit;
  }

  // 2중 저장 방지
  $lock = "bwf_owner_lock_{$uid}_{$sub}";
  if (get_transient($lock)){
    wp_safe_redirect( add_query_arg('err','dup', wp_get_referer() ?: home_url('/') ) ); exit;
  }
  set_transient($lock, 1, 5*MINUTE_IN_SECONDS);

  // 폼 값
  $answers = (array)($_POST['q'] ?? []);

  // (선택) 서버 검증: 최소 글자/필수
  $cfg = function_exists('bwf_owner_get_config') ? bwf_owner_get_config() : ['min_length'=>50,'questions'=>[]];
  $min = (int)($cfg['min_length'] ?? 50);
  $errs = [];
  foreach ((array)$cfg['questions'] as $q){
    $id   = $q['id'] ?? '';
    $type = $q['type'] ?? 'textarea';
    $req  = !isset($q['required']) || $q['required'];
    $ml   = isset($q['minlength']) && $q['minlength'] !== '' ? (int)$q['minlength'] : $min;

    if ($type === 'group'){
      foreach ((array)($q['sub'] ?? []) as $s){
        $sid  = $s['id'] ?? '';
        $sreq = !isset($s['required']) || $s['required'];
        $v    = trim((string)($answers[$id][$sid] ?? ''));
        if ($sreq && $v==='') $errs[]="$id/$sid";
      }
    }else{
      $v = trim((string)($answers[$id] ?? ''));
      if ($req && ($v==='' || mb_strlen($v) < $ml)) $errs[]=$id;
    }
  }
  if ($errs){
    wp_safe_redirect( add_query_arg('err','validation', wp_get_referer() ?: home_url('/') ) ); exit;
  }

  // CPT 저장(개별 레코드)
  $pid = wp_insert_post([
    'post_type'    => 'bwf_owner_answer',
    'post_status'  => 'publish',
    'post_author'  => $uid,
    'post_title'   => '대표 질문 ' . bwf_now_str(),
    'post_date'    => bwf_now_str(),
    'post_date_gmt'=> null,
    'meta_input'   => [
      'bwf_answers'    => $answers,
      'bwf_submission' => $sub,
      'bwf_saved_at'   => bwf_now_str(),
    ],
  ], true);

  $dest = home_url('/my-questions/'); // 마이페이지 목록 슬러그
  if (is_wp_error($pid)){
    wp_safe_redirect( add_query_arg('err','save', $dest) ); exit;
  }
  wp_safe_redirect( add_query_arg(['saved'=>1,'id'=>$pid], $dest) ); exit;
}
add_action('admin_post_bwf_owner_save', 'bwf_owner_handle_save');
add_action('admin_post_nopriv_bwf_owner_save', 'bwf_owner_handle_save');

`$nl
===== FILE: berrywalk-feedback\includes\questions-admin.php (3744 bytes, 95 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

require_once __DIR__ . '/helper.php';

add_action('admin_menu', function(){
  add_menu_page('Berrywalk Feedback','Berrywalk Feedback','manage_options','bwf_crm','bwf_crm_landing','dashicons-feedback',26);
  add_submenu_page('bwf_crm','대표 질문지','대표 질문지','manage_options','bwf_questions','bwf_questions_page');
});

function bwf_crm_landing(){
  echo '<div class="wrap"><h1>Berrywalk Feedback</h1><p>왼쪽 하위 메뉴에서 이동하세요.</p></div>';
}

function bwf_questions_page(){
  $q = isset($_GET['s']) ? sanitize_text_field($_GET['s']) : '';

  // bwf_questions 메타가 있는 사용자만
  $users = new WP_User_Query([
    'meta_key'     => 'bwf_questions',
    'meta_compare' => 'EXISTS',
    'fields'       => ['ID','user_login','user_email','display_name'],
    'number'       => 2000,
  ]);

  $rows = [];
  foreach($users->get_results() as $u){
    $now  = get_user_meta($u->ID,'bwf_questions',true);
    $hist = get_user_meta($u->ID,'bwf_questions_history',true);
    if(!is_array($hist)) $hist=[];
    $items=[]; if(is_array($now)&&$now) $items[]=$now; $items=array_merge($items,$hist);

    foreach($items as $qs){
      if(!is_array($qs) || empty($qs)) continue;
      $flat = wp_strip_all_tags(implode(' ', array_map('strval',$qs)));
      if($q && mb_stripos($flat,$q)===false) continue;

      // 대표 메타
      $company = get_user_meta($u->ID,'bw_company_name',true);
      $industry_key = get_user_meta($u->ID,'bw_industry',true);
      $industry_map = bwf_industry_options();
      $industry = $industry_map[$industry_key] ?? $industry_key;
      $phone    = get_user_meta($u->ID,'bw_phone',true);

      $rows[] = [
        'id'      => $u->ID,
        'name'    => $u->display_name ?: $u->user_login,
        'email'   => $u->user_email,
        't'       => $qs['_saved_at'] ?? '',
        'company' => $company,
        'industry'=> $industry,
        'phone'   => $phone,
        'data'    => $qs,
      ];
    }
  }

  echo '<div class="wrap"><h1>대표 질문지</h1>';
  echo '<form method="get" style="margin:12px 0">';
  echo '<input type="hidden" name="page" value="bwf_questions">';
  echo '<input type="search" name="s" value="'.esc_attr($q).'" placeholder="내용 검색" style="min-width:280px;"> ';
  echo '<button class="button">검색</button> ';
  echo '<a class="button" href="'.esc_url(admin_url('admin.php?page=bwf_questions')).'">초기화</a>';
  echo '</form>';

  if (empty($rows)) { echo '<p>저장된 대표 질문이 없습니다.</p></div>'; return; }

  // 보기 페이지(URL)
  $view_page = get_page_by_path('my-question-view');
  $view_url  = $view_page ? get_permalink($view_page) : home_url('/my-question-view/');

  echo '<table class="widefat striped"><thead><tr>';
  echo '<th>저장시각</th><th>대표ID</th><th>대표명(이메일)</th><th>회사명</th><th>업종</th><th>휴대폰</th><th>보기</th>';
  echo '</tr></thead><tbody>';

  foreach($rows as $r){
    $qs = $r['data'];
    $goto = esc_url(add_query_arg([
      'qid' => ($qs['_id'] ?? ''),
      'uid' => $r['id'],
    ], $view_url));

    echo '<tr>';
    echo '<td>'.esc_html($r['t']).'</td>';
    echo '<td>'.intval($r['id']).'</td>';
    echo '<td>'.esc_html($r['name']).' <span style="color:#64748b">('.esc_html($r['email']).')</span></td>';
    echo '<td>'.esc_html($r['company']).'</td>';
    echo '<td>'.esc_html($r['industry']).'</td>';
    echo '<td>'.esc_html($r['phone']).'</td>';
    echo '<td><a class="button button-secondary" href="'.$goto.'" target="_blank">보기</a></td>';
    echo '</tr>';
  }
  echo '</tbody></table></div>';
}

`$nl
===== FILE: berrywalk-feedback\includes\shortcodes.php (7155 bytes, 197 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/**
 * [bw_owner_form]
 * - 대표가 핵심 질문지 작성 → 저장 → 피드백 링크 메일 발송
 */
add_shortcode('bw_owner_form', function($atts){
  wp_enqueue_style('bwf-forms');
  wp_enqueue_script('bwf-owner');
  wp_localize_script('bwf-owner','BWF_OWNER',[
    'ajax'=> admin_url('admin-ajax.php'),
    'nonce'=> wp_create_nonce('bwf_owner_submit')
  ]);

  ob_start(); ?>
  <form id="bwf-owner" class="bwf-form">
    <h3>대표님 핵심 질문지</h3>

    <div class="grid-2">
      <label>회사/서비스명
        <input name="company_name" required>
      </label>
      <label>업종
        <select name="industry" required>
          <option value="">선택</option>
          <option>교육</option><option>부동산</option><option>커머스</option>
          <option>콘텐츠/미디어</option><option>기타</option>
        </select>
      </label>

      <label>직원 수
        <select name="employees" required>
          <option value="">선택</option>
          <option>1~3</option><option>4~9</option><option>10~29</option><option>30+</option>
        </select>
      </label>
      <label>홈페이지 URL
        <input type="url" name="website_url" placeholder="https://example.com" required>
      </label>
    </div>

    <label>SNS/링크(쉼표 또는 JSON 배열)
      <textarea name="socials" placeholder='["https://instagram.com/...","https://youtube.com/..."]'></textarea>
    </label>

    <label>알게 된 경로
      <input name="discover_source" placeholder="유튜브/검색/지인/광고 등">
    </label>

    <hr>

    <label>현재 가장 큰 고민
      <textarea name="pain_points" required></textarea>
    </label>

    <label>핵심 가치(문제→가치 한 줄)
      <textarea name="value_prop" required></textarea>
    </label>

    <label>이상적 타겟/선택 이유
      <textarea name="ideal_customer" required></textarea>
    </label>

    <div class="grid-3">
      <label>맞춤 질문 1
        <textarea name="must_ask_q1" required></textarea>
      </label>
      <label>맞춤 질문 2
        <textarea name="must_ask_q2" required></textarea>
      </label>
      <label>맞춤 질문 3
        <textarea name="must_ask_q3" required></textarea>
      </label>
    </div>

    <button type="submit" class="bwf-btn">질문지 제출 및 링크 받기</button>
    <p class="bwf-hint">제출 후, 고객 피드백용 고유 링크가 관리자 이메일로 발송됩니다.</p>
  </form>
  <?php
  return ob_get_clean();
});


/**
 * [bw_feedback_form]
 * - 고객 서술형 피드백 (최소 100자)
 * - ref 토큰으로 대표 질문 자동 노출
 */
add_shortcode('bw_feedback_form', function($atts){
  $ref = sanitize_text_field($_GET['ref'] ?? '');
  if (!$ref) return '<div>유효하지 않은 접근입니다.</div>';

  global $wpdb;
  $rep = $wpdb->prefix.'bw_representatives';
  $row = $wpdb->get_row($wpdb->prepare("SELECT * FROM $rep WHERE view_token=%s", $ref), ARRAY_A);
  if (!$row) return '<div>존재하지 않는 링크입니다.</div>';

  // 로그인 사용자 기본값 프리필(있으면)
  $u = wp_get_current_user();
  $pref_age    = $u->ID ? get_user_meta($u->ID,'age_range',true) : '';
  $pref_gender = $u->ID ? get_user_meta($u->ID,'gender',true) : '';

  wp_enqueue_style('bwf-forms');
  wp_enqueue_script('bwf-feedback');
  wp_localize_script('bwf-feedback','BWF_FB',[
    'ajax'=> admin_url('admin-ajax.php'),
    'nonce'=> wp_create_nonce('bwf_feedback_submit'),
    'ref'=> $ref,
    'minlen'=> 100
  ]);

  ob_start(); ?>
  <div class="bwf-card">
    <h3>피드백 설문</h3>
    <p class="muted">대표 질문 요약</p>
    <ul class="bwf-rep">
      <li><b>가장 큰 고민:</b> <?=esc_html($row['pain_points']);?></li>
      <li><b>핵심 가치(대표 생각):</b> <?=esc_html($row['value_prop']);?></li>
      <li><b>이상적 타겟:</b> <?=esc_html($row['ideal_customer']);?></li>
      <li><b>맞춤 질문 1:</b> <?=esc_html($row['must_ask_q1']);?></li>
      <li><b>맞춤 질문 2:</b> <?=esc_html($row['must_ask_q2']);?></li>
      <li><b>맞춤 질문 3:</b> <?=esc_html($row['must_ask_q3']);?></li>
    </ul>
  </div>

  <form id="bwf-feedback" class="bwf-form">
    <h4>응답자 기본정보</h4>
    <div class="grid-3">
      <label>연령대
        <select name="age_range" required>
          <option value="">선택</option>
          <option <?=$pref_age==='10s'?'selected':'';?> value="10s">10대</option>
          <option <?=$pref_age==='20s'?'selected':'';?> value="20s">20대</option>
          <option <?=$pref_age==='30s'?'selected':'';?> value="30s">30대</option>
          <option <?=$pref_age==='40s'?'selected':'';?> value="40s">40대</option>
          <option <?=$pref_age==='50s+'?'selected':'';?> value="50s+">50대+</option>
        </select>
      </label>
      <label>성별
        <select name="gender" required>
          <option value="">선택</option>
          <option <?=$pref_gender==='male'?'selected':'';?> value="male">남</option>
          <option <?=$pref_gender==='female'?'selected':'';?> value="female">여</option>
          <option <?=$pref_gender==='other'?'selected':'';?> value="other">기타/응답거부</option>
        </select>
      </label>
      <label>카테고리 구매경험
        <select name="category_experience" required>
          <option value="">선택</option>
          <option value="1">예</option>
          <option value="0">아니오</option>
        </select>
      </label>
    </div>

    <label>최초 유입 경로(예: 유튜브/검색/지인)
      <input name="discover_channel" required>
    </label>

    <hr>

    <h4>핵심 질문(서술형, 최소 100자)</h4>
    <label>① 첫인상/서비스 평가
      <textarea name="first_impression" required></textarea>
    </label>
    <label>② 타겟 적합성(대표 타겟과 실제 체감)
      <textarea name="target_fit" required></textarea>
    </label>
    <label>③ 경쟁사 비교/차별점
      <textarea name="competitor_compare" required></textarea>
    </label>
    <label>④ ‘꼭 사야 할 이유’/구매장애
      <textarea name="must_buy_reason" required></textarea>
    </label>
    <label>⑤ 추천 의향/개선 시 추천 가능성
      <textarea name="recommend_intent" required></textarea>
    </label>

    <h4>대표 맞춤 질문</h4>
    <label>Q1: <?=esc_html($row['must_ask_q1']);?>
      <textarea name="ans_owner_q1" required></textarea>
    </label>
    <label>Q2: <?=esc_html($row['must_ask_q2']);?>
      <textarea name="ans_owner_q2" required></textarea>
    </label>
    <label>Q3: <?=esc_html($row['must_ask_q3']);?>
      <textarea name="ans_owner_q3" required></textarea>
    </label>

    <button type="submit" class="bwf-btn">피드백 제출</button>
    <p class="bwf-hint">각 문항은 최소 100자 이상이 필요합니다.</p>
  </form>
  <?php
  return ob_get_clean();
});

`$nl
===== FILE: berrywalk-feedback\includes\signup.php (21235 bytes, 472 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

/**
 * Berrywalk Feedback - Signup Shortcodes (대표 / 피드백자)
 * 변경 핵심
 * - 대표 회원가입 시 role 슬러그를 'bw_owner' 로 강제(하위호환: 'representative'도 허용)
 * - 가입 직후에도 set_role('bw_owner')로 확정
 * - user meta 'bw_owner' 플래그 저장(기본 'Y' — 필요하면 하단 상수로 변경)
 * - "*표시는 필수 입력" 상단 고정, 타이틀 중앙, 휴대폰 자동 하이픈 + 패턴검증, 필수 누락 팝업/하이라이트
 */

require_once __DIR__ . '/helper.php';

/* ─────────────────────────────────────────────────────────────────────────────
   역할 보장: bw_owner 역할이 없으면 생성 (권한: read 만)
   ───────────────────────────────────────────────────────────────────────────── */
add_action('init', function(){
  if (!get_role('bw_owner')) {
    add_role('bw_owner', '대표', ['read' => true]);
  }
});

/* 메타 플래그 기본값 (원하면 바꿔도 됨) */
if (!defined('BWF_BW_OWNER_META_VALUE')) {
  define('BWF_BW_OWNER_META_VALUE', 'Y');
}

/* 공통 모달 에러 출력 스크립트 */
function bwf_print_modal_error_script($msg){
  $m = esc_js($msg);
  echo "<script>
    document.addEventListener('DOMContentLoaded', function(){
      var modal = document.getElementById('bwf-modal');
      if(!modal) return;
      modal.querySelector('.bwf-modal__msg').textContent = '{$m}';
      modal.classList.add('is-open');
      modal.setAttribute('aria-hidden','false');
      var ok = modal.querySelector('#bwf-modal-ok');
      if(ok) ok.addEventListener('click', function(){
        modal.classList.remove('is-open');
        modal.setAttribute('aria-hidden','true');
      });
    });
  </script>";
}

/* ─────────────────────────────────────────────────────────────────────────────
   대표 회원가입 (역할: bw_owner 고정)
   ───────────────────────────────────────────────────────────────────────────── */
add_shortcode('bwf_signup_representative', function () {
  wp_enqueue_style('bwf-forms');

  if (is_user_logged_in()) {
    $u = wp_get_current_user();
    return '<div class="bwf-form"><p><strong>'.bwf_esc($u->user_login).'</strong>로 로그인됨.</p>
            <p class="bwf-actions"><a class="bwf-btn" href="'.esc_url(home_url('/owner-questions/')).'">질문 등록하기</a></p></div>';
  }

  $nonce = wp_create_nonce('bwf_signup_rep'); // 기존 nonce 재사용
  $S = function($k,$d=''){ return isset($_POST[$k]) ? esc_attr($_POST[$k]) : $d; };

  ob_start(); ?>
  <form method="post" class="bwf-form bwf-grid" novalidate id="bwf-signup-rep">
    <!-- 역할을 bw_owner로 고정 -->
    <input type="hidden" name="bwf_role" value="bw_owner">
    <input type="hidden" name="bwf_nonce" value="<?php echo esc_attr($nonce); ?>">

    <h2 class="bwf-title bwf-col-full">대표 회원가입</h2>
    <p class="bwf-required-note bwf-col-full">* 표시는 필수 입력</p>

    <!-- 로그인 정보 -->
    <div>
      <label>아이디(영문/숫자) <span class="bwf-required">*</span></label>
      <input type="text" name="user_login" value="<?php echo $S('user_login'); ?>" pattern="[A-Za-z0-9_\.\-]{4,32}" required>
    </div>
    <div>
      <label>비밀번호 <span class="bwf-required">*</span></label>
      <input type="password" name="user_pass" required>
    </div>
    <div>
      <label>이메일 <span class="bwf-required">*</span></label>
      <input type="email" name="user_email" value="<?php echo $S('user_email'); ?>" required>
    </div>
    <div>
      <label>이름 <span class="bwf-required">*</span></label>
      <input type="text" name="first_name" value="<?php echo $S('first_name'); ?>" required>
    </div>

    <!-- 회사 기본 -->
    <div>
      <label>회사명 <span class="bwf-required">*</span></label>
      <input type="text" name="bw_company_name" value="<?php echo $S('bw_company_name'); ?>" required>
    </div>
    <div>
      <label>업종 <span class="bwf-required">*</span></label>
      <select name="bw_industry" required>
        <option value="">선택</option>
        <?php foreach(bwf_industry_options() as $k=>$v){
          $sel = selected($S('bw_industry'), $k, false);
          echo "<option value='".esc_attr($k)."' $sel>".esc_html($v)."</option>";
        } ?>
      </select>
    </div>
    <div>
      <label>직원 수 <span class="bwf-required">*</span></label>
      <input type="number" name="bw_employees" value="<?php echo $S('bw_employees'); ?>" min="1" required>
    </div>
    <div>
      <label>홈페이지 URL</label>
      <input type="url" name="user_url" value="<?php echo $S('user_url'); ?>" placeholder="https://">
    </div>

    <!-- 연락/유입 -->
    <div>
      <label>알게 된 경로 <span class="bwf-required">*</span></label>
      <select name="bw_discover" id="bwf-source" required>
        <option value="">선택</option>
        <?php foreach(bwf_source_options() as $k=>$v){
          $sel = selected($S('bw_discover'), $k, false);
          echo "<option value='".esc_attr($k)."' $sel>".esc_html($v)."</option>";
        } ?>
      </select>
      <input type="text" name="source_etc" id="bwf-source-etc" placeholder="기타 경로" style="display:none;" value="<?php echo $S('source_etc'); ?>">
    </div>
    <div>
      <label>휴대폰 번호 <span class="bwf-required">*</span></label>
      <input type="tel" name="bw_phone" id="bwf-phone"
        inputmode="numeric" autocomplete="tel"
        placeholder="010-1234-5678"
        maxlength="13" pattern="^010-\d{4}-\d{4}$" required>
    </div>
    <div>
      <label>연락 가능한 시간대 <span class="bwf-required">*</span></label>
      <input type="text" name="bw_contact_window" value="<?php echo $S('bw_contact_window'); ?>" placeholder="예: 평일 13:00~18:00" required>
    </div>

    <div class="bwf-col-full"><hr></div>

    <!-- 소셜 링크(옵션) -->
    <div class="bwf-col-full"><strong>소셜 링크(있으면 입력)</strong></div>
    <?php foreach(bwf_social_fields() as $key=>$label): ?>
      <div>
        <label><?php echo bwf_esc($label); ?></label>
        <input type="url" name="<?php echo esc_attr($key); ?>" value="<?php echo $S($key); ?>" placeholder="https://">
      </div>
    <?php endforeach; ?>

    <div class="bwf-col-full bwf-actions">
      <button type="submit" name="bwf_register">회원가입</button>
    </div>

    <!-- 팝업 모달 -->
    <div class="bwf-modal" id="bwf-modal" aria-hidden="true">
      <div class="bwf-modal__card">
        <h3>입력이 필요한 항목이 있어요</h3>
        <p class="bwf-modal__msg">필수 항목을 확인해 주세요.</p>
        <div class="bwf-modal__actions">
          <button type="button" class="bwf-btn" id="bwf-modal-ok">확인</button>
        </div>
      </div>
    </div>

    <script>
    (function(){
      const f   = document.getElementById('bwf-signup-rep');
      const src = f.querySelector('#bwf-source');
      const etc = f.querySelector('#bwf-source-etc');
      const tel = f.querySelector('#bwf-phone');
      const modal = f.querySelector('#bwf-modal');
      const okBtn = f.querySelector('#bwf-modal-ok');

      function toggleEtc(){
        etc.style.display = (src && src.value === 'etc') ? 'block' : 'none';
        if (src && src.value !== 'etc') etc.value = '';
      }
      if (src){ src.addEventListener('change', toggleEtc); toggleEtc(); }

      /* 휴대폰 자동 하이픈 */
      function formatPhone(v){
        const d = String(v||'').replace(/\D/g,'').slice(0,11);
        if (d.startsWith('010')) {
          if (d.length >= 11) return d.replace(/^(\d{3})(\d{4})(\d{4}).*$/,'$1-$2-$3');
          if (d.length >= 7)  return d.replace(/^(\d{3})(\d{0,4})(\d{0,4}).*$/,(m,a,b,c)=> a+(b?'-'+b:'')+(c?'-'+c:''));
          if (d.length >= 4)  return d.replace(/^(\d{3})(\d{0,4}).*$/,(m,a,b)=> a+'-'+b);
        }
        return d;
      }
      if (tel){
        tel.addEventListener('input', ()=>{
          const before = tel.value;
          tel.value = formatPhone(before);
          tel.setSelectionRange(tel.value.length, tel.value.length);
        });
      }

      /* 모달 */
      function openModal(msg){
        modal.querySelector('.bwf-modal__msg').textContent = msg || '필수 항목을 확인해 주세요.';
        modal.classList.add('is-open'); modal.setAttribute('aria-hidden','false');
      }
      function closeModal(){ modal.classList.remove('is-open'); modal.setAttribute('aria-hidden','true'); }
      okBtn.addEventListener('click', closeModal);

      /* 제출 전 클라이언트 검증 */
      f.addEventListener('submit', function(ev){
        const req = Array.from(f.querySelectorAll('[required]'));
        let firstInvalid = null;

        req.forEach(el=>{
          el.classList.remove('bwf-invalid');
          // 전화번호 패턴 강제
          if (el.name==='bw_phone' && !/^010-\d{4}-\d{4}$/.test(el.value)) {
            el.setCustomValidity('휴대폰 번호는 010-1234-5678 형식으로 입력해주세요.');
          } else {
            el.setCustomValidity('');
          }
          if(!el.checkValidity()){
            if(!firstInvalid) firstInvalid = el;
            el.classList.add('bwf-invalid');
          }
        });

        if (firstInvalid){
          ev.preventDefault();
          openModal('누락된 필수 항목을 입력해 주세요.');
          firstInvalid.scrollIntoView({behavior:'smooth', block:'center'});
          firstInvalid.focus({preventScroll:true});
        }
      });
    })();
    </script>
  </form>
  <?php
    if (!empty($_POST['bwf_error'])) {
      bwf_print_modal_error_script($_POST['bwf_error']);
    }
    return ob_get_clean();
});

/* ─────────────────────────────────────────────────────────────────────────────
   피드백자 회원가입 (간단)
   ───────────────────────────────────────────────────────────────────────────── */
add_shortcode('bwf_signup_feedback', function () {
  wp_enqueue_style('bwf-forms');

  if (is_user_logged_in()) {
    $u = wp_get_current_user();
    return '<div class="bwf-form"><p><strong>' . bwf_esc($u->user_login) . '</strong>로 로그인됨.</p></div>';
  }

  $nonce = wp_create_nonce('bwf_signup_fb');
  $S = function($k,$d=''){ return isset($_POST[$k]) ? esc_attr($_POST[$k]) : $d; };

  ob_start(); ?>
  <form method="post" class="bwf-form bwf-grid" novalidate id="bwf-signup-fb">
    <input type="hidden" name="bwf_role" value="feedback_provider">
    <input type="hidden" name="bwf_nonce" value="<?php echo esc_attr($nonce); ?>">

    <h2 class="bwf-title bwf-col-full">피드백 회원가입</h2>
    <p class="bwf-required-note bwf-col-full">* 표시는 필수 입력</p>

    <div>
      <label>이메일 <span class="bwf-required">*</span></label>
      <input type="email" name="user_email" value="<?php echo $S('user_email'); ?>" required>
    </div>
    <div>
      <label>비밀번호 <span class="bwf-required">*</span></label>
      <input type="password" name="user_pass" required>
    </div>
    <div>
      <label>아이디 <span class="bwf-required">*</span></label>
      <input type="text" name="user_login" value="<?php echo $S('user_login'); ?>" pattern="[A-Za-z0-9_\.\-]{4,32}" required>
    </div>
    <div>
      <label>이름 <span class="bwf-required">*</span></label>
      <input type="text" name="first_name" value="<?php echo $S('first_name'); ?>" required>
    </div>

    <div>
      <label>연령대 <span class="bwf-required">*</span></label>
      <input type="text" name="age_range" value="<?php echo $S('age_range'); ?>" placeholder="예: 20대 초반" required>
    </div>
    <div>
      <label>성별 <span class="bwf-required">*</span></label>
      <select name="gender" required>
        <option value="">선택</option>
        <option value="male"   <?php selected($S('gender'),'male'); ?>>남성</option>
        <option value="female" <?php selected($S('gender'),'female'); ?>>여성</option>
        <option value="etc"    <?php selected($S('gender'),'etc'); ?>>기타/응답안함</option>
      </select>
    </div>
    <div>
      <label>카테고리 구매 경험 <span class="bwf-required">*</span></label>
      <select name="experience" required>
        <option value="">선택</option>
        <option value="yes" <?php selected($S('experience'),'yes'); ?>>예</option>
        <option value="no"  <?php selected($S('experience'),'no');  ?>>아니오</option>
      </select>
    </div>
    <div>
      <label>알게 된 경로 <span class="bwf-required">*</span></label>
      <select name="source" id="bwf-source-fb" required>
        <option value="">선택</option>
        <?php foreach(bwf_source_options() as $k=>$v){
          $sel = selected($S('source'), $k, false);
          echo "<option value='".esc_attr($k)."' $sel>".esc_html($v)."</option>";
        } ?>
      </select>
      <input type="text" name="source_etc" id="bwf-source-etc-fb" placeholder="기타 경로" style="display:none;" value="<?php echo $S('source_etc'); ?>">
    </div>

    <div class="bwf-col-full bwf-actions">
      <button type="submit" name="bwf_register">회원가입</button>
    </div>

    <!-- 팝업 모달 -->
    <div class="bwf-modal" id="bwf-modal" aria-hidden="true">
      <div class="bwf-modal__card">
        <h3>입력이 필요한 항목이 있어요</h3>
        <p class="bwf-modal__msg">필수 항목을 확인해 주세요.</p>
        <div class="bwf-modal__actions">
          <button type="button" class="bwf-btn" id="bwf-modal-ok">확인</button>
        </div>
      </div>
    </div>

    <script>
    (function(){
      const f   = document.getElementById('bwf-signup-fb');
      const src = f.querySelector('#bwf-source-fb');
      const etc = f.querySelector('#bwf-source-etc-fb');
      const modal = f.querySelector('#bwf-modal');
      const okBtn = f.querySelector('#bwf-modal-ok');

      function toggleEtc(){
        etc.style.display = (src && src.value === 'etc') ? 'block' : 'none';
        if (src && src.value !== 'etc') etc.value = '';
      }
      if (src){ src.addEventListener('change', toggleEtc); toggleEtc(); }

      function openModal(msg){
        modal.querySelector('.bwf-modal__msg').textContent = msg || '필수 항목을 확인해 주세요.';
        modal.classList.add('is-open'); modal.setAttribute('aria-hidden','false');
      }
      function closeModal(){ modal.classList.remove('is-open'); modal.setAttribute('aria-hidden','true'); }
      okBtn.addEventListener('click', closeModal);

      f.addEventListener('submit', function(ev){
        const req = Array.from(f.querySelectorAll('[required]'));
        let firstInvalid = null;
        req.forEach(el=>{
          el.classList.remove('bwf-invalid');
          el.setCustomValidity('');
          if (!el.checkValidity()){
            if (!firstInvalid) firstInvalid = el;
            el.classList.add('bwf-invalid');
          }
        });
        if (firstInvalid){
          ev.preventDefault();
          openModal('누락된 필수 항목을 입력해 주세요.');
          firstInvalid.scrollIntoView({behavior:'smooth', block:'center'});
          firstInvalid.focus({preventScroll:true});
        }
      });
    })();
    </script>
  </form>
  <?php
    if (!empty($_POST['bwf_error'])) {
      bwf_print_modal_error_script($_POST['bwf_error']);
    }
    return ob_get_clean();
});

/* ─────────────────────────────────────────────────────────────────────────────
   서버 사이드 처리 (대표/피드백 공통)
   ───────────────────────────────────────────────────────────────────────────── */
add_action('init', function(){
  if (!isset($_POST['bwf_register'])) return;

  $role  = sanitize_text_field($_POST['bwf_role'] ?? '');
  $nonce = sanitize_text_field($_POST['bwf_nonce'] ?? '');

  // 대표(신규: bw_owner / 구버전: representative) 둘 다 허용
  $is_owner = in_array($role, ['bw_owner', 'representative'], true);

  if ($is_owner && !wp_verify_nonce($nonce,'bwf_signup_rep')) return;
  if ($role === 'feedback_provider' && !wp_verify_nonce($nonce,'bwf_signup_fb')) return;

  // 공통 필드
  $user_login = sanitize_user($_POST['user_login'] ?? '');
  $user_email = sanitize_email($_POST['user_email'] ?? '');
  $user_pass  = $_POST['user_pass'] ?? '';
  $first_name = sanitize_text_field($_POST['first_name'] ?? '');

  // 필수 검사
  $err = '';
  if (!$user_login || !$user_email || !$user_pass || !$first_name) $err = '필수 항목이 누락되었습니다.';
  if (!$err && username_exists($user_login)) $err = '이미 사용 중인 아이디입니다.';
  if (!$err && email_exists($user_email))    $err = '이미 등록된 이메일입니다.';

  if ($is_owner) {
    foreach (['bw_company_name','bw_industry','bw_employees','bw_contact_window','bw_discover','bw_phone'] as $k) {
      if (empty($_POST[$k])) { $err = '필수 항목이 누락되었습니다.'; break; }
    }
    // 휴대폰 정규화 및 형식 체크
    if (!$err) {
      $raw = (string)($_POST['bw_phone'] ?? '');
      $digits = preg_replace('/\D+/','',$raw);
      if (strlen($digits)!==11 || strpos($digits,'010')!==0) {
        $_POST['bwf_error'] = '휴대폰 번호는 010-1234-5678 형식으로 입력해주세요.'; return;
      }
      $_POST['bw_phone'] = preg_replace('/^(\d{3})(\d{4})(\d{4})$/','$1-$2-$3',$digits);
    }
  } else {
    foreach (['age_range','gender','experience','source'] as $k) {
      if (empty($_POST[$k])) { $err = '필수 항목이 누락되었습니다.'; break; }
    }
  }

  if ($err) { $_POST['bwf_error'] = $err; return; }

  // 계정 생성 (대표는 role 필드가 뭐로 오든 최종적으로 'bw_owner'로 세팅)
  $target_role = $is_owner ? 'bw_owner' : 'feedback_provider';
  $uid = wp_insert_user([
    'user_login' => $user_login,
    'user_email' => $user_email,
    'user_pass'  => $user_pass,
    'first_name' => $first_name,
    'role'       => $target_role,
    'user_url'   => esc_url_raw($_POST['user_url'] ?? '')
  ]);
  if (is_wp_error($uid)) { $_POST['bwf_error'] = $uid->get_error_message(); return; }

  // 로그인 세션
  wp_set_current_user($uid);
  wp_set_auth_cookie($uid);

  // 대표 역할 확정 + 메타 플래그
  if ($is_owner) {
    $u = new WP_User($uid);
    $u->set_role('bw_owner'); // 최종 보정

    update_user_meta($uid, 'bw_owner', BWF_BW_OWNER_META_VALUE); // 플래그 저장

    $meta_keys = ['bw_company_name','bw_industry','bw_employees','bw_contact_window','bw_discover','bw_phone'];
    foreach($meta_keys as $k){
      if(isset($_POST[$k])) update_user_meta($uid,$k,sanitize_text_field($_POST[$k]));
    }
    if (isset($_POST['bw_discover']) && $_POST['bw_discover']==='etc' && !empty($_POST['source_etc'])) {
      update_user_meta($uid,'bw_discover','etc: '.sanitize_text_field($_POST['source_etc']));
    }
    // 소셜
    foreach (bwf_social_fields() as $k=>$label) {
      if(isset($_POST[$k]) && $_POST[$k]!== '') update_user_meta($uid,$k,esc_url_raw($_POST[$k]));
    }
  } else { // 피드백자
    foreach (['age_range','gender','experience','source'] as $k){
      if(isset($_POST[$k])) update_user_meta($uid,$k,sanitize_text_field($_POST[$k]));
    }
    if (isset($_POST['source']) && $_POST['source']==='etc' && !empty($_POST['source_etc'])) {
      update_user_meta($uid,'source','etc: '.sanitize_text_field($_POST['source_etc']));
    }
  }

  // 성공 리디렉트
  $dest = $is_owner ? home_url('/info-feedback/?join=ok') : home_url('/?join=ok');
  wp_redirect($dest); exit;
});

`$nl
===== FILE: berrywalk-feedback\includes\view-question.php (2348 bytes, 62 lines) =====
`$ext
<?php
if (!defined('ABSPATH')) exit;

add_shortcode('bw_view_question', function(){
  wp_enqueue_style('bwf-forms'); // 공용 스타일

  $qid = sanitize_text_field($_GET['qid'] ?? '');
  $uid = intval($_GET['uid'] ?? 0);
  $id = intval($atts['id'] ?? ($_GET['id'] ?? 0));
  if (!$id) return '<div class="bwf-form">잘못된 접근입니다.</div>';
  $post = get_post($id);
  if (!$post || get_post_type($post) !== 'bwf_owner_answer') return '<div class="bwf-form">잘못된 접근입니다.</div>';

  // 권한: 작성자거나, 관리자면 통과
  $author = (int)$post->post_author;
  if ( get_current_user_id() !== $author && !current_user_can('manage_options') ) {
    return '<div class="bwf-form">접근 권한이 없습니다.</div>';
}

  $now  = get_user_meta($uid,'bwf_questions', true);
  $hist = get_user_meta($uid,'bwf_questions_history', true); if(!is_array($hist)) $hist=[];
  $items=[]; if(is_array($now)&&$now) $items[]=$now; $items=array_merge($items,$hist);

  $target = null;
  foreach($items as $it){ if(($it['_id'] ?? '') === $qid){ $target = $it; break; } }
  if (!$target) return '<div class="bwf-form"><p>대상을 찾을 수 없습니다.</p></div>';

  ob_start(); ?>
  <div class="bwf-view">
    <div class="bwf-card">
      <h2 class="bwf-title">대표 질문 보기</h2>
      <ul class="bwf-kv">
        <li><b>저장 시각</b><span><?=esc_html($target['_saved_at'] ?? '')?></span></li>
        <li><b>대표 ID</b><span><?=intval($uid)?></span></li>
      </ul>
    </div>

    <div class="bwf-card">
      <h3>내용</h3>
      <ul class="bwf-bullets">
        <?php
        $map = [
          'problem'=>'① 가장 큰 고민','value'=>'② 핵심 가치','ideal_customer'=>'③ 이상적 타겟',
          'q1'=>'④-1 질문','q2'=>'④-2 질문','q3'=>'④-3 질문',
          'one_question'=>'⑤ 1:1 한 가지','competitors'=>'⑥ 경쟁/차별'
        ];
        foreach($map as $k=>$title){
          if(!empty($target[$k])){
            echo '<li><b>'.$title.':</b> '.esc_html($target[$k]).'</li>';
          }
        }
        ?>
      </ul>
      <div class="bwf-actions">
        <a href="javascript:history.back()" class="bwf-btn-secondary">목록으로</a>
      </div>
    </div>
  </div>
  <?php
  return ob_get_clean();
});

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\composer.json (719 bytes, 24 lines) =====
`$ext
{
	"name": "yahnis-elsts/plugin-update-checker",
	"type": "library",
	"description": "A custom update checker for WordPress plugins and themes. Useful if you can't host your plugin in the official WP repository but still want it to support automatic updates.",
	"keywords": ["wordpress", "plugin updates", "automatic updates", "theme updates"],
	"homepage": "https://github.com/YahnisElsts/plugin-update-checker/",
	"license": "MIT",
	"authors": [
		{
			"name": "Yahnis Elsts",
			"email": "whiteshadow@w-shadow.com",
			"homepage": "https://w-shadow.com/",
			"role": "Developer"
		}
	],
	"require": {
		"php": ">=5.6.20",
		"ext-json": "*"
	},
	"autoload": {
		"files": ["load-v5p6.php"]
	}
}

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\license.txt (1063 bytes, 8 lines) =====
`$ext
Copyright (c) 2023 Jānis Elsts

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\load-v5p6.php (1182 bytes, 35 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6;

use YahnisElsts\PluginUpdateChecker\v5\PucFactory as MajorFactory;
use YahnisElsts\PluginUpdateChecker\v5p6\PucFactory as MinorFactory;

require __DIR__ . '/Puc/v5p6/Autoloader.php';
new Autoloader();

require __DIR__ . '/Puc/v5p6/PucFactory.php';
require __DIR__ . '/Puc/v5/PucFactory.php';

//Register classes defined in this version with the factory.
foreach (
	array(
		'Plugin\\UpdateChecker' => Plugin\UpdateChecker::class,
		'Theme\\UpdateChecker'  => Theme\UpdateChecker::class,

		'Vcs\\PluginUpdateChecker' => Vcs\PluginUpdateChecker::class,
		'Vcs\\ThemeUpdateChecker'  => Vcs\ThemeUpdateChecker::class,

		'GitHubApi'    => Vcs\GitHubApi::class,
		'BitBucketApi' => Vcs\BitBucketApi::class,
		'GitLabApi'    => Vcs\GitLabApi::class,
	)
	as $pucGeneralClass => $pucVersionedClass
) {
	MajorFactory::addVersion($pucGeneralClass, $pucVersionedClass, '5.6');
	//Also add it to the minor-version factory in case the major-version factory
	//was already defined by another, older version of the update checker.
	MinorFactory::addVersion($pucGeneralClass, $pucVersionedClass, '5.6');
}


`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\plugin-update-checker.php (227 bytes, 10 lines) =====
`$ext
<?php
/**
 * Plugin Update Checker Library 5.6
 * http://w-shadow.com/
 *
 * Copyright 2025 Janis Elsts
 * Released under the MIT license. See license.txt for details.
 */

require dirname(__FILE__) . '/load-v5p6.php';
`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\README.md (21190 bytes, 373 lines) =====
`$ext
Plugin Update Checker
=====================

This is a custom update checker library for WordPress plugins and themes. It lets you add automatic update notifications and one-click upgrades to your commercial plugins, private themes, and so on. All you need to do is put your plugin/theme details in a JSON file, place the file on your server, and pass the URL to the library. The library periodically checks the URL to see if there's a new version available and displays an update notification to the user if necessary.

From the users' perspective, it works just like with plugins and themes hosted on WordPress.org. The update checker uses the default upgrade UI that is familiar to most WordPress users.

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
**Table of Contents**

- [Getting Started](#getting-started)
  - [Self-hosted Plugins and Themes](#self-hosted-plugins-and-themes)
    - [How to Release an Update](#how-to-release-an-update)
    - [Notes](#notes)
  - [GitHub Integration](#github-integration)
    - [How to Release an Update](#how-to-release-an-update-1)
    - [Notes](#notes-1)
  - [BitBucket Integration](#bitbucket-integration)
    - [How to Release an Update](#how-to-release-an-update-2)
  - [GitLab Integration](#gitlab-integration)
    - [How to Release a GitLab Update](#how-to-release-a-gitlab-update)
- [Migrating from 4.x](#migrating-from-4x)
- [License Management](#license-management)
- [Resources](#resources)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

Getting Started
---------------

*Note:* In each of the below examples, part of the instructions is to create an instance of the update checker class. It's recommended to do this either during the `plugins_loaded` action or outside of any hooks. If you do it only during an `admin_*` action, then updates will not be visible to a wide variety of WordPress management tools; they will only be visible to logged-in users on dashboard pages.

### Self-hosted Plugins and Themes

1. Download [the latest release](https://github.com/YahnisElsts/plugin-update-checker/releases/latest) and copy the `plugin-update-checker` directory to your plugin or theme.
2. Go to the `examples` subdirectory and open the .json file that fits your project type. Replace the placeholder data with your plugin/theme details. 
	- Plugin example:
	
		```json
		{
			"name" : "Plugin Name",
			"version" : "2.0",
			"download_url" : "https://example.com/plugin-name-2.0.zip",
			"sections" : {
				"description" : "Plugin description here. You can use HTML."
			}
		}
		```
		
        This is a minimal example that leaves out optional fields. See [this table](https://docs.google.com/spreadsheets/d/1eOBbW7Go2qEQXReOOCdidMTf_tDYRq4JfegcO1CBPIs/edit?usp=sharing) for a full list of supported fields and their descriptions.
	- Theme example:
	
		```json
		{
			"version": "2.0",
			"details_url": "https://example.com/version-2.0-details.html",
			"download_url": "https://example.com/example-theme-2.0.zip"
		}
		```
		
		This is actually a complete example that shows all theme-related fields. `version` and `download_url` should be self-explanatory. The `details_url` key specifies the page that the user will see if they click the "View version 1.2.3 details" link in an update notification.  
3. Upload the JSON file to a publicly accessible location.
4. Add the following code to the main plugin file or to the `functions.php` file:

	```php
	require 'path/to/plugin-update-checker/plugin-update-checker.php';
	use YahnisElsts\PluginUpdateChecker\v5\PucFactory;
 
	$myUpdateChecker = PucFactory::buildUpdateChecker(
		'https://example.com/path/to/details.json',
		__FILE__, //Full path to the main plugin file or functions.php.
		'unique-plugin-or-theme-slug'
	);
	```
	Note: If you're using the Composer autoloader, you don't need to explicitly `require` the library.

#### How to Release an Update

Change the `version` number in the JSON file and make sure that `download_url` points to the latest version. Update the other fields if necessary. Tip: You can use [wp-update-server](https://github.com/YahnisElsts/wp-update-server) to automate this process.

By default, the library will check the specified URL for changes every 12 hours. You can force it to check immediately by clicking the "Check for updates" link on the "Plugins" page (it's next to the "Visit plugin site" link). Themes don't have that link, but you can also trigger an update check like this:
 
 1. Install [Debug Bar](https://srd.wordpress.org/plugins/debug-bar/).
 2. Click the "Debug" menu in the Admin Bar (a.k.a Toolbar).
 3. Open the "PUC (your-slug)" panel. 
 4. Click the "Check Now" button.  

#### Notes
- The second argument passed to `buildUpdateChecker` must be the absolute path to the main plugin file or any file in the theme directory. If you followed the "getting started" instructions, you can just use the `__FILE__` constant.
- The third argument - i.e. the slug - is optional but recommended. In most cases, the slug should be the same as the name of your plugin directory. For example, if your plugin lives in `/wp-content/plugins/my-plugin`, set the slug to `my-plugin`. If the slug is omitted, the update checker will use the name of the main plugin file as the slug (e.g. `my-cool-plugin.php` &rarr; `my-cool-plugin`). This can lead to conflicts if your plugin has a generic file name like `plugin.php`. 
	
	This doesn't affect themes because PUC uses the theme directory name as the default slug. Still, if you're planning to use the slug in your own code - e.g. to filter updates or override update checker behaviour - it can be a good idea to set it explicitly. 

### GitHub Integration

1. Download [the latest release](https://github.com/YahnisElsts/plugin-update-checker/releases/latest) and copy the `plugin-update-checker` directory to your plugin or theme.
2. Add the following code to the main plugin file or `functions.php`:

	```php
	require 'plugin-update-checker/plugin-update-checker.php';
	use YahnisElsts\PluginUpdateChecker\v5\PucFactory;
 
	$myUpdateChecker = PucFactory::buildUpdateChecker(
		'https://github.com/user-name/repo-name/',
		__FILE__,
		'unique-plugin-or-theme-slug'
	);
	
	//Set the branch that contains the stable release.
	$myUpdateChecker->setBranch('stable-branch-name');

	//Optional: If you're using a private repository, specify the access token like this:
	$myUpdateChecker->setAuthentication('your-token-here');
	```
3. Plugins only: Add a `readme.txt` file formatted according to the [WordPress.org plugin readme standard](https://wordpress.org/plugins/readme.txt) to your repository. The contents of this file will be shown when the user clicks the "View version 1.2.3 details" link.

#### How to Release an Update

This library supports a couple of different ways to release updates on GitHub. Pick the one that best fits your workflow.

- **GitHub releases** 
	
	Create a new release using the "Releases" feature on GitHub. The tag name and release title don't matter. The description is optional, but if you do provide one, it will be displayed when the user clicks the "View version x.y.z details" link on the "Plugins" page. Note that PUC ignores releases marked as "This is a pre-release".
	
	If you want to use release assets, call the `enableReleaseAssets()` method after creating the update checker instance:
	```php
	$myUpdateChecker->getVcsApi()->enableReleaseAssets();
	```
	
- **Tags** 
	
	To release version 1.2.3, create a new Git tag named `v1.2.3` or `1.2.3`. That's it.
	
	PUC doesn't require strict adherence to [SemVer](https://semver.org/). These are all valid tag names: `v1.2.3`, `v1.2-foo`, `1.2.3_rc1-ABC`, `1.2.3.4.5`. However, be warned that it's not smart enough to filter out alpha/beta/RC versions. If that's a problem, you might want to use GitHub releases or branches instead.
	
- **Stable branch** 
	
	Point the update checker at a stable, production-ready branch: 
	 ```php
	 $updateChecker->setBranch('branch-name');
	 ```
	 PUC will periodically check the `Version` header in the main plugin file or `style.css` and display a notification if it's greater than the installed version.
	 
	 Caveat: If you set the branch to `master` (the default), the update checker will look for recent releases and tags first. It'll only use the `master` branch if it doesn't find anything else suitable.

#### Notes

The library will pull update details from the following parts of a release/tag/branch:

- Version number
	- The "Version" plugin header.
	- The latest GitHub release or tag name.
- Changelog
	- The "Changelog" section of `readme.txt`.
	- One of the following files:
		CHANGES.md, CHANGELOG.md, changes.md, changelog.md
	- GitHub release notes.
- Required and tested WordPress versions
	- The "Requires at least" and "Tested up to" fields in `readme.txt`.
	- The following plugin headers:
		`Required WP`, `Tested WP`, `Requires at least`, `Tested up to`
- "Last updated" timestamp
	- The creation timestamp of the latest GitHub release.
	- The latest commit in the selected tag or branch.
- Number of downloads
	- The `download_count` statistic of the latest release.
	- If you're not using GitHub releases, there will be no download stats.
- Other plugin details - author, homepage URL, description
	- The "Description" section of `readme.txt`.
	- Remote plugin headers (i.e. the latest version on GitHub).
	- Local plugin headers (i.e. the currently installed version).
- Ratings, banners, screenshots
	- Not supported.
	
### BitBucket Integration

1. Download [the latest release](https://github.com/YahnisElsts/plugin-update-checker/releases/latest) and copy the `plugin-update-checker` directory to your plugin or theme.
2. Add the following code to the main plugin file or `functions.php`:

	```php
	require 'plugin-update-checker/plugin-update-checker.php';
	use YahnisElsts\PluginUpdateChecker\v5\PucFactory;
 
	$myUpdateChecker = PucFactory::buildUpdateChecker(
		'https://bitbucket.org/user-name/repo-name',
		__FILE__,
		'unique-plugin-or-theme-slug'
	);

	//Optional: If you're using a private repository, create an OAuth consumer
	//and set the authentication credentials like this:
	//Note: For now you need to check "This is a private consumer" when
	//creating the consumer to work around #134:
	// https://github.com/YahnisElsts/plugin-update-checker/issues/134
	$myUpdateChecker->setAuthentication(array(
		'consumer_key' => '...',
		'consumer_secret' => '...',
	));

	//Optional: Set the branch that contains the stable release.
	$myUpdateChecker->setBranch('stable-branch-name');
	```
3. Optional: Add a `readme.txt` file formatted according to the [WordPress.org plugin readme standard](https://wordpress.org/plugins/readme.txt) to your repository. For plugins, the contents of this file will be shown when the user clicks the "View version 1.2.3 details" link.

#### How to Release an Update

BitBucket doesn't have an equivalent to GitHub's releases, so the process is slightly different. You can use any of the following approaches: 

- **`Stable tag` header** 
	
	This is the recommended approach if you're using tags to mark each version. Add a `readme.txt` file formatted according to the [WordPress.org plugin readme standard](https://wordpress.org/plugins/readme.txt) to your repository. Set the "stable tag" header to the tag that represents the latest release. Example:
	```text
	Stable tag: v1.2.3
	```
	The tag doesn't have to start with a "v" or follow any particular format. You can use any name you like as long as it's a valid Git tag.
	
	Tip: If you explicitly set a stable branch, the update checker will look for a `readme.txt` in that branch. Otherwise it will only look at the `master` branch.
	
- **Tags** 
	
	You can skip the "stable tag" bit and just create a new Git tag named `v1.2.3` or `1.2.3`. The update checker will look at the most recent tags and pick the one that looks like the highest version number.
	
	PUC doesn't require strict adherence to [SemVer](https://semver.org/). These are all valid tag names: `v1.2.3`, `v1.2-foo`, `1.2.3_rc1-ABC`, `1.2.3.4.5`. However, be warned that it's not smart enough to filter out alpha/beta/RC versions.
	
- **Stable branch** 
	
	Point the update checker at a stable, production-ready branch: 
	 ```php
	 $updateChecker->setBranch('branch-name');
	 ```
	 PUC will periodically check the `Version` header in the main plugin file or `style.css` and display a notification if it's greater than the installed version. Caveat: If you set the branch to `master`, the update checker will still look for tags first.

### GitLab Integration

1. Download [the latest release](https://github.com/YahnisElsts/plugin-update-checker/releases/latest) and copy the `plugin-update-checker` directory to your plugin or theme.
2. Add the following code to the main plugin file or `functions.php` and define how you want to check for updates from Gitlab (refer to: [Gitlab: How to Release an Update](#how-to-release-a-gitlab-update)):

	```php
	require 'plugin-update-checker/plugin-update-checker.php';
	use YahnisElsts\PluginUpdateChecker\v5\PucFactory;

	$myUpdateChecker = PucFactory::buildUpdateChecker(
		'https://gitlab.com/user-name/repo-name/',
		__FILE__,
		'unique-plugin-or-theme-slug'
	);

	//Optional: If you're using a private repository, specify the access token like this:
	$myUpdateChecker->setAuthentication('your-token-here');
	```

	Alternatively, if you're using a self-hosted GitLab instance, initialize the update checker like this:
	```php
	use YahnisElsts\PluginUpdateChecker\v5p6\Vcs\PluginUpdateChecker;
	use YahnisElsts\PluginUpdateChecker\v5p6\Vcs\GitLabApi;
	
	$myUpdateChecker = new PluginUpdateChecker(
		new GitLabApi('https://myserver.com/user-name/repo-name/'),
		__FILE__,
		'unique-plugin-or-theme-slug'
	);
	//Optional: Add setAuthentication(...) and setBranch(...) as shown above.  
	```
	If you're using a self-hosted GitLab instance and [subgroups or nested groups](https://docs.gitlab.com/ce/user/group/subgroups/index.html), you have to tell the update checker which parts of the URL are subgroups:
	```php
	use YahnisElsts\PluginUpdateChecker\v5p6\Vcs\PluginUpdateChecker;
	use YahnisElsts\PluginUpdateChecker\v5p6\Vcs\GitLabApi;
   
	$myUpdateChecker = new PluginUpdateChecker(
		new GitLabApi(
			'https://myserver.com/group-name/subgroup-level1/subgroup-level2/subgroup-level3/repo-name/', 
			null, 
			'subgroup-level1/subgroup-level2/subgroup-level3'
		),
		__FILE__,
		'unique-plugin-or-theme-slug'
	);
	```

3. Plugins only: Add a `readme.txt` file formatted according to the [WordPress.org plugin readme standard](https://wordpress.org/plugins/readme.txt) to your repository. The contents of this file will be shown when the user clicks the "View version 1.2.3 details" link.

#### How to Release a GitLab Update

A GitLab repository can be checked for updates in 3 different ways.

- **GitLab releases**
	
	Create a new release using the "Releases" feature on GitLab. The tag name should match the version number. You can add a `v` prefix to the tag, like `v1.2.3`. Releases that are marked as ["Upcoming Release"](https://docs.gitlab.com/ee/user/project/releases/index.html#upcoming-releases) will be automatically ignored.
	
	If you want to use custom release assets, call the `enableReleaseAssets()` method after creating the update checker instance:
	```php
	$myUpdateChecker->getVcsApi()->enableReleaseAssets();
	```
	
	By default, PUC will use the first available asset link, regardless of type. You can pass a regular expression to `enableReleaseAssets()` to make it pick the first link where the URL matches the regex. For example:
	```php
	$myUpdateChecker->getVcsApi()->enableReleaseAssets('/\.zip($|[?&#])/i');
	```
	
	**Tip:** You can use a Gitlab CI/CD Pipeline to automatically generate your update on release using a Generic Package. For more information about generic packages, refer to the following links:
		- [Gitlab CI/CD Release Documentation](https://docs.gitlab.com/ee/user/project/releases/#create-release-from-gitlab-ci)
		- [Gitlab Release Assets as Generic Package Documentation](https://gitlab.com/gitlab-org/release-cli/-/tree/master/docs/examples/release-assets-as-generic-package/)
		- [Example .gitlab-ci.yml file using Release Generic Packages for generating a update package from the Sensei-LMS wordpress plugin](https://gist.github.com/timwiel/9dfd3526c768efad4973254085e065ce)

- **Tags**

	To release version 1.2.3, create a new Git tag named `v1.2.3` or `1.2.3`. The update checker will look at recent tags and use the one that looks like the highest version number.
	
	PUC doesn't require strict adherence to [SemVer](https://semver.org/). However, be warned that it's not smart enough to filter out alpha/beta/RC versions. If that's a problem, you might want to use GitLab branches instead.

- **Stable branch**

	Point the update checker at any stable, production-ready branch:
	```php
	$myUpdateChecker->setBranch('stable-branch-name');
	```
	PUC will periodically check the `Version` header in the main plugin file or `style.css` and display a notification if it's greater than the installed version. Caveat: Even if you set the branch to `main` (the default) or `master` (the historical default), the update checker will still look for recent releases and tags first.

Migrating from 4.x
------------------

Older versions of the library didn't use namespaces. Code that was written for those versions will need to be updated to work with the current version. At a minimum, you'll need to change the factory class name. 

Old code:
```php
$myUpdateChecker = Puc_v4_Factory::buildUpdateChecker(
	'https://example.com/info.json',
	__FILE__,
	'my-slug'
);
```

New code:
```php
use YahnisElsts\PluginUpdateChecker\v5\PucFactory;

$myUpdateChecker = PucFactory::buildUpdateChecker(
	'https://example.com/info.json',
	__FILE__,
	'my-slug'
);
```

Other classes have also been renamed, usually by simply removing the `Puc_vXpY_` prefix and converting `Category_Thing` to `Category\Thing`. Here's a table of the most commonly used classes and their new names:

| Old class name                      | New class name                                                 |
|-------------------------------------|----------------------------------------------------------------|
| `Puc_v4_Factory`                    | `YahnisElsts\PluginUpdateChecker\v5\PucFactory`                |
| `Puc_v4p13_Factory`                 | `YahnisElsts\PluginUpdateChecker\v5p6\PucFactory`              |
| `Puc_v4p13_Plugin_UpdateChecker`    | `YahnisElsts\PluginUpdateChecker\v5p6\Plugin\UpdateChecker`    |
| `Puc_v4p13_Theme_UpdateChecker`     | `YahnisElsts\PluginUpdateChecker\v5p6\Theme\UpdateChecker`     |
| `Puc_v4p13_Vcs_PluginUpdateChecker` | `YahnisElsts\PluginUpdateChecker\v5p6\Vcs\PluginUpdateChecker` |
| `Puc_v4p13_Vcs_ThemeUpdateChecker`  | `YahnisElsts\PluginUpdateChecker\v5p6\Vcs\ThemeUpdateChecker`  |
| `Puc_v4p13_Vcs_GitHubApi`           | `YahnisElsts\PluginUpdateChecker\v5p6\Vcs\GitHubApi`           |
| `Puc_v4p13_Vcs_GitLabApi`           | `YahnisElsts\PluginUpdateChecker\v5p6\Vcs\GitLabApi`           |
| `Puc_v4p13_Vcs_BitBucketApi`        | `YahnisElsts\PluginUpdateChecker\v5p6\Vcs\BitBucketApi`        |

License Management
------------------

Currently, the update checker doesn't have any built-in license management features. It only provides some hooks that you can use to, for example, append license keys to update requests (`$updateChecker->addQueryArgFilter()`). If you're looking for ways to manage and verify licenses, please post your feedback in [this issue](https://github.com/YahnisElsts/plugin-update-checker/issues/222).

Resources
---------

- [This blog post](https://w-shadow.com/blog/2010/09/02/automatic-updates-for-any-plugin/) has more information about the update checker API. *Slightly out of date.*
- [Debug Bar](https://wordpress.org/plugins/debug-bar/) - useful for testing and debugging the update checker.
- [Update format reference](https://docs.google.com/spreadsheets/d/1eOBbW7Go2qEQXReOOCdidMTf_tDYRq4JfegcO1CBPIs/edit?usp=sharing) - describes all fields supported by the JSON-based update information format used by the update checker. Only covers plugins. Themes use a similar but more limited format.
- [Securing download links](https://w-shadow.com/blog/2013/03/19/plugin-updates-securing-download-links/) - a general overview.
- [A GUI for entering download credentials](https://open-tools.net/documentation/tutorial-automatic-updates.html#wordpress)
- [Theme Update Checker](https://w-shadow.com/blog/2011/06/02/automatic-updates-for-commercial-themes/) - an older, theme-only variant of this update checker.

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\css\puc-debug-bar.css (1334 bytes, 71 lines) =====
`$ext
.puc-debug-bar-panel-v5 pre {
	margin-top: 0;
}

/* Style the debug data table to match "widefat" table style used by WordPress. */
table.puc-debug-data {
    width: 100%;
    clear: both;
    margin: 0;

    border-spacing: 0;
    background-color: #f9f9f9;

    border-radius: 3px;
    border: 1px solid #dfdfdf;
    border-collapse: separate;
}

table.puc-debug-data * {
    word-wrap: break-word;
}

table.puc-debug-data th {
	width: 11em;
    padding: 7px 7px 8px;
    text-align: left;

    font-family: "Georgia", "Times New Roman", "Bitstream Charter", "Times", serif;
    font-weight: 400;
    font-size: 14px;
    line-height: 1.3em;
    text-shadow: rgba(255, 255, 255, 0.804) 0 1px 0;
}

table.puc-debug-data td, table.puc-debug-data th {
    border-width: 1px 0;
    border-style: solid;

    border-top-color: #fff;
    border-bottom-color: #dfdfdf;

    text-transform: none;
}

table.puc-debug-data td {
    color: #555;
    font-size: 12px;
    padding: 4px 7px 2px;
    vertical-align: top;
}

.puc-ajax-response {
	border: 1px solid #dfdfdf;
	border-radius: 3px;
	padding: 0.5em;
	margin: 5px 0;
	background-color: white;
}

.puc-ajax-nonce {
	display: none;
}

.puc-ajax-response dt {
	margin: 0;
}

.puc-ajax-response dd {
	margin: 0 0 1em;
}

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\js\debug-bar.js (1793 bytes, 54 lines) =====
`$ext
jQuery(function($) {

	function runAjaxAction(button, action) {
		button = $(button);
		var panel = button.closest('.puc-debug-bar-panel-v5');
		var responseBox = button.closest('td').find('.puc-ajax-response');

		responseBox.text('Processing...').show();
		$.post(
			ajaxurl,
			{
				action  : action,
				uid     : panel.data('uid'),
				_wpnonce: panel.data('nonce')
			},
			function(data) {
				//The response contains HTML that should already be escaped in server-side code.
				//phpcs:ignore WordPressVIPMinimum.JS.HTMLExecutingFunctions.html
				responseBox.html(data);
			},
			'html'
		);
	}

	$('.puc-debug-bar-panel-v5 input[name="puc-check-now-button"]').on('click', function() {
		runAjaxAction(this, 'puc_v5_debug_check_now');
		return false;
	});

	$('.puc-debug-bar-panel-v5 input[name="puc-request-info-button"]').on('click', function() {
		runAjaxAction(this, 'puc_v5_debug_request_info');
		return false;
	});


	// Debug Bar uses the panel class name as part of its link and container IDs. This means we can
	// end up with multiple identical IDs if more than one plugin uses the update checker library.
	// Fix it by replacing the class name with the plugin slug.
	var panels = $('#debug-menu-targets').find('.puc-debug-bar-panel-v5');
	panels.each(function() {
		var panel = $(this);
		var uid = panel.data('uid');
		var target = panel.closest('.debug-menu-target');

		//Change the panel wrapper ID.
		target.attr('id', 'debug-menu-target-puc-' + uid);

		//Change the menu link ID as well and point it at the new target ID.
		$('#debug-bar-menu').find('.puc-debug-menu-link-' + uid)
			.closest('.debug-menu-link')
			.attr('id', 'debug-menu-link-puc-' + uid)
			.attr('href', '#' + target.attr('id'));
	});
});
`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5\PucFactory.php (201 bytes, 11 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5;

if ( !class_exists(PucFactory::class, false) ):

	class PucFactory extends \YahnisElsts\PluginUpdateChecker\v5p6\PucFactory {
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Autoloader.php (2774 bytes, 87 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(Autoloader::class, false) ):

	class Autoloader {
		const DEFAULT_NS_PREFIX = 'YahnisElsts\\PluginUpdateChecker\\';

		private $prefix;
		private $rootDir;
		private $libraryDir;

		private $staticMap;

		public function __construct() {
			$this->rootDir = dirname(__FILE__) . '/';

			$namespaceWithSlash = __NAMESPACE__ . '\\';
			$this->prefix = $namespaceWithSlash;

			$this->libraryDir = $this->rootDir . '../..';
			if ( !self::isPhar() ) {
				$this->libraryDir = realpath($this->libraryDir);
			}
			$this->libraryDir = $this->libraryDir . '/';

			//Usually, dependencies like Parsedown are in the global namespace,
			//but if someone adds a custom namespace to the entire library, they
			//will be in the same namespace as this class.
			$isCustomNamespace = (
				substr($namespaceWithSlash, 0, strlen(self::DEFAULT_NS_PREFIX)) !== self::DEFAULT_NS_PREFIX
			);
			$libraryPrefix = $isCustomNamespace ? $namespaceWithSlash : '';

			$this->staticMap = array(
				$libraryPrefix . 'PucReadmeParser' => 'vendor/PucReadmeParser.php',
				$libraryPrefix . 'Parsedown'       => 'vendor/Parsedown.php',
			);

			//Add the generic, major-version-only factory class to the static map.
			$versionSeparatorPos = strrpos(__NAMESPACE__, '\\v');
			if ( $versionSeparatorPos !== false ) {
				$versionSegment = substr(__NAMESPACE__, $versionSeparatorPos + 1);
				$pointPos = strpos($versionSegment, 'p');
				if ( ($pointPos !== false) && ($pointPos > 1) ) {
					$majorVersionSegment = substr($versionSegment, 0, $pointPos);
					$majorVersionNs = __NAMESPACE__ . '\\' . $majorVersionSegment;
					$this->staticMap[$majorVersionNs . '\\PucFactory'] =
						'Puc/' . $majorVersionSegment . '/Factory.php';
				}
			}

			spl_autoload_register(array($this, 'autoload'));
		}

		/**
		 * Determine if this file is running as part of a Phar archive.
		 *
		 * @return bool
		 */
		private static function isPhar() {
			//Check if the current file path starts with "phar://".
			static $pharProtocol = 'phar://';
			return (substr(__FILE__, 0, strlen($pharProtocol)) === $pharProtocol);
		}

		public function autoload($className) {
			if ( isset($this->staticMap[$className]) && file_exists($this->libraryDir . $this->staticMap[$className]) ) {
				include($this->libraryDir . $this->staticMap[$className]);
				return;
			}

			if ( strpos($className, $this->prefix) === 0 ) {
				$path = substr($className, strlen($this->prefix));
				$path = str_replace(array('_', '\\'), '/', $path);
				$path = $this->rootDir . $path . '.php';

				if ( file_exists($path) ) {
					include $path;
				}
			}
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\InstalledPackage.php (3042 bytes, 106 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(InstalledPackage::class, false) ):

	/**
	 * This class represents a currently installed plugin or theme.
	 *
	 * Not to be confused with the "package" field in WP update API responses that contains
	 * the download URL of a the new version.
	 */
	abstract class InstalledPackage {
		/**
		 * @var UpdateChecker
		 */
		protected $updateChecker;

		public function __construct($updateChecker) {
			$this->updateChecker = $updateChecker;
		}

		/**
		 * Get the currently installed version of the plugin or theme.
		 *
		 * @return string|null Version number.
		 */
		abstract public function getInstalledVersion();

		/**
		 * Get the full path of the plugin or theme directory (without a trailing slash).
		 *
		 * @return string
		 */
		abstract public function getAbsoluteDirectoryPath();

		/**
		 * Check whether a regular file exists in the package's directory.
		 *
		 * @param string $relativeFileName File name relative to the package directory.
		 * @return bool
		 */
		public function fileExists($relativeFileName) {
			return is_file(
				$this->getAbsoluteDirectoryPath()
				. DIRECTORY_SEPARATOR
				. ltrim($relativeFileName, '/\\')
			);
		}

		/* -------------------------------------------------------------------
		 * File header parsing
		 * -------------------------------------------------------------------
		 */

		/**
		 * Parse plugin or theme metadata from the header comment.
		 *
		 * This is basically a simplified version of the get_file_data() function from /wp-includes/functions.php.
		 * It's intended as a utility for subclasses that detect updates by parsing files in a VCS.
		 *
		 * @param string|null $content File contents.
		 * @return string[]
		 */
		public function getFileHeader($content) {
			$content = (string)$content;

			//WordPress only looks at the first 8 KiB of the file, so we do the same.
			$content = substr($content, 0, 8192);
			//Normalize line endings.
			$content = str_replace("\r", "\n", $content);

			$headers = $this->getHeaderNames();
			$results = array();
			foreach ($headers as $field => $name) {
				$success = preg_match('/^[ \t\/*#@]*' . preg_quote($name, '/') . ':(.*)$/mi', $content, $matches);

				if ( ($success === 1) && $matches[1] ) {
					$value = $matches[1];
					if ( function_exists('_cleanup_header_comment') ) {
						$value = _cleanup_header_comment($value);
					}
					$results[$field] = $value;
				} else {
					$results[$field] = '';
				}
			}

			return $results;
		}

		/**
		 * @return array Format: ['HeaderKey' => 'Header Name']
		 */
		abstract protected function getHeaderNames();

		/**
		 * Get the value of a specific plugin or theme header.
		 *
		 * @param string $headerName
		 * @return string Either the value of the header, or an empty string if the header doesn't exist.
		 */
		abstract public function getHeaderValue($headerName);

	}
endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Metadata.php (4401 bytes, 163 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

use LogicException;
use stdClass;
use WP_Error;

if ( !class_exists(Metadata::class, false) ):

	/**
	 * A base container for holding information about updates and plugin metadata.
	 *
	 * @author Janis Elsts
	 * @copyright 2016
	 * @access public
	 */
	abstract class Metadata {
		/**
		 * Additional dynamic properties, usually copied from the API response.
		 *
		 * @var array<string,mixed>
		 */
		protected $extraProperties = array();

		/**
		 * Create an instance of this class from a JSON document.
		 *
		 * @abstract
		 * @param string $json
		 * @return self
		 */
		public static function fromJson($json) {
			throw new LogicException('The ' . __METHOD__ . ' method must be implemented by subclasses');
		}

		/**
		 * @param string $json
		 * @param self $target
		 * @return bool
		 */
		protected static function createFromJson($json, $target) {
			/** @var \StdClass $apiResponse */
			$apiResponse = json_decode($json);
			if ( empty($apiResponse) || !is_object($apiResponse) ){
				$errorMessage = "Failed to parse update metadata. Try validating your .json file with https://jsonlint.com/";
				do_action('puc_api_error', new WP_Error('puc-invalid-json', $errorMessage));
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_trigger_error -- For plugin developers.
				trigger_error(esc_html($errorMessage), E_USER_NOTICE);
				return false;
			}

			$valid = $target->validateMetadata($apiResponse);
			if ( is_wp_error($valid) ){
				do_action('puc_api_error', $valid);
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_trigger_error -- For plugin developers.
				trigger_error(esc_html($valid->get_error_message()), E_USER_NOTICE);
				return false;
			}

			foreach(get_object_vars($apiResponse) as $key => $value){
				$target->$key = $value;
			}

			return true;
		}

		/**
		 * No validation by default! Subclasses should check that the required fields are present.
		 *
		 * @param \StdClass $apiResponse
		 * @return bool|\WP_Error
		 */
		protected function validateMetadata($apiResponse) {
			return true;
		}

		/**
		 * Create a new instance by copying the necessary fields from another object.
		 *
		 * @abstract
		 * @param \StdClass|self $object The source object.
		 * @return self The new copy.
		 */
		public static function fromObject($object) {
			throw new LogicException('The ' . __METHOD__ . ' method must be implemented by subclasses');
		}

		/**
		 * Create an instance of StdClass that can later be converted back to an
		 * update or info container. Useful for serialization and caching, as it
		 * avoids the "incomplete object" problem if the cached value is loaded
		 * before this class.
		 *
		 * @return \StdClass
		 */
		public function toStdClass() {
			$object = new stdClass();
			$this->copyFields($this, $object);
			return $object;
		}

		/**
		 * Transform the metadata into the format used by WordPress core.
		 *
		 * @return object
		 */
		abstract public function toWpFormat();

		/**
		 * Copy known fields from one object to another.
		 *
		 * @param \StdClass|self $from
		 * @param \StdClass|self $to
		 */
		protected function copyFields($from, $to) {
			$fields = $this->getFieldNames();

			if ( property_exists($from, 'slug') && !empty($from->slug) ) {
				//Let plugins add extra fields without having to create subclasses.
				$fields = apply_filters($this->getPrefixedFilter('retain_fields') . '-' . $from->slug, $fields);
			}

			foreach ($fields as $field) {
				if ( property_exists($from, $field) ) {
					$to->$field = $from->$field;
				}
			}
		}

		/**
		 * @return string[]
		 */
		protected function getFieldNames() {
			return array();
		}

		/**
		 * @param string $tag
		 * @return string
		 */
		protected function getPrefixedFilter($tag) {
			return 'puc_' . $tag;
		}

		public function __set($name, $value) {
			$this->extraProperties[$name] = $value;
		}

		public function __get($name) {
			return isset($this->extraProperties[$name]) ? $this->extraProperties[$name] : null;
		}

		public function __isset($name) {
			return isset($this->extraProperties[$name]);
		}

		public function __unset($name) {
			unset($this->extraProperties[$name]);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\OAuthSignature.php (3167 bytes, 103 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(OAuthSignature::class, false) ):

	/**
	 * A basic signature generator for zero-legged OAuth 1.0.
	 */
	class OAuthSignature {
		private $consumerKey = '';
		private $consumerSecret = '';

		public function __construct($consumerKey, $consumerSecret) {
			$this->consumerKey = $consumerKey;
			$this->consumerSecret = $consumerSecret;
		}

		/**
		 * Sign a URL using OAuth 1.0.
		 *
		 * @param string $url The URL to be signed. It may contain query parameters.
		 * @param string $method HTTP method such as "GET", "POST" and so on.
		 * @return string The signed URL.
		 */
		public function sign($url, $method = 'GET') {
			$parameters = array();

			//Parse query parameters.
			$query = wp_parse_url($url, PHP_URL_QUERY);
			if ( !empty($query) ) {
				parse_str($query, $parsedParams);
				if ( is_array($parsedParams) ) {
					$parameters = $parsedParams;
				}
				//Remove the query string from the URL. We'll replace it later.
				$url = substr($url, 0, strpos($url, '?'));
			}

			$parameters = array_merge(
				$parameters,
				array(
					'oauth_consumer_key' => $this->consumerKey,
					'oauth_nonce' => $this->nonce(),
					'oauth_signature_method' => 'HMAC-SHA1',
					'oauth_timestamp' => time(),
					'oauth_version' => '1.0',
				)
			);
			unset($parameters['oauth_signature']);

			//Parameters must be sorted alphabetically before signing.
			ksort($parameters);

			//The most complicated part of the request - generating the signature.
			//The string to sign contains the HTTP method, the URL path, and all of
			//our query parameters. Everything is URL encoded. Then we concatenate
			//them with ampersands into a single string to hash.
			$encodedVerb = urlencode($method);
			$encodedUrl = urlencode($url);
			$encodedParams = urlencode(http_build_query($parameters, '', '&'));

			$stringToSign = $encodedVerb . '&' . $encodedUrl . '&' . $encodedParams;

			//Since we only have one OAuth token (the consumer secret) we only have
			//to use it as our HMAC key. However, we still have to append an & to it
			//as if we were using it with additional tokens.
			$secret = urlencode($this->consumerSecret) . '&';

			//The signature is a hash of the consumer key and the base string. Note
			//that we have to get the raw output from hash_hmac and base64 encode
			//the binary data result.
			$parameters['oauth_signature'] = base64_encode(hash_hmac('sha1', $stringToSign, $secret, true));

			return ($url . '?' . http_build_query($parameters));
		}

		/**
		 * Generate a random nonce.
		 *
		 * @return string
		 */
		private function nonce() {
			$mt = microtime();

			$rand = null;
			if ( is_callable('random_bytes') ) {
				try {
					$rand = random_bytes(16);
				} catch (\Exception $ex) {
					//Fall back to mt_rand (below).
				}
			}
			if ( $rand === null ) {
				//phpcs:ignore WordPress.WP.AlternativeFunctions.rand_mt_rand
				$rand = function_exists('wp_rand') ? wp_rand() : mt_rand();
			}

			return md5($mt . '_' . $rand);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\PucFactory.php (12121 bytes, 363 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6;

use YahnisElsts\PluginUpdateChecker\v5p6\Plugin;
use YahnisElsts\PluginUpdateChecker\v5p6\Theme;
use YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !class_exists(PucFactory::class, false) ):

	/**
	 * A factory that builds update checker instances.
	 *
	 * When multiple versions of the same class have been loaded (e.g. PluginUpdateChecker 4.0
	 * and 4.1), this factory will always use the latest available minor version. Register class
	 * versions by calling {@link PucFactory::addVersion()}.
	 *
	 * At the moment it can only build instances of the UpdateChecker class. Other classes are
	 * intended mainly for internal use and refer directly to specific implementations.
	 */
	class PucFactory {
		protected static $classVersions = array();
		protected static $sorted = false;

		protected static $myMajorVersion = '';
		protected static $latestCompatibleVersion = '';

		/**
		 * A wrapper method for buildUpdateChecker() that reads the metadata URL from the plugin or theme header.
		 *
		 * @param string $fullPath Full path to the main plugin file or the theme's style.css.
		 * @param array $args Optional arguments. Keys should match the argument names of the buildUpdateChecker() method.
		 * @return Plugin\UpdateChecker|Theme\UpdateChecker|Vcs\BaseChecker
		 */
		public static function buildFromHeader($fullPath, $args = array()) {
			$fullPath = self::normalizePath($fullPath);

			//Set up defaults.
			$defaults = array(
				'metadataUrl'  => '',
				'slug'         => '',
				'checkPeriod'  => 12,
				'optionName'   => '',
				'muPluginFile' => '',
			);
			$args = array_merge($defaults, array_intersect_key($args, $defaults));
			extract($args, EXTR_SKIP);

			//Check for the service URI
			if ( empty($metadataUrl) ) {
				$metadataUrl = self::getServiceURI($fullPath);
			}

			return self::buildUpdateChecker($metadataUrl, $fullPath, $slug, $checkPeriod, $optionName, $muPluginFile);
		}

		/**
		 * Create a new instance of the update checker.
		 *
		 * This method automatically detects if you're using it for a plugin or a theme and chooses
		 * the appropriate implementation for your update source (JSON file, GitHub, BitBucket, etc).
		 *
		 * @see UpdateChecker::__construct
		 *
		 * @param string $metadataUrl The URL of the metadata file, a GitHub repository, or another supported update source.
		 * @param string $fullPath Full path to the main plugin file or to the theme directory.
		 * @param string $slug Custom slug. Defaults to the name of the main plugin file or the theme directory.
		 * @param int $checkPeriod How often to check for updates (in hours).
		 * @param string $optionName Where to store bookkeeping info about update checks.
		 * @param string $muPluginFile The plugin filename relative to the mu-plugins directory.
		 * @return Plugin\UpdateChecker|Theme\UpdateChecker|Vcs\BaseChecker
		 */
		public static function buildUpdateChecker($metadataUrl, $fullPath, $slug = '', $checkPeriod = 12, $optionName = '', $muPluginFile = '') {
			$fullPath = self::normalizePath($fullPath);
			$id = null;

			//Plugin or theme?
			$themeDirectory = self::getThemeDirectoryName($fullPath);
			if ( self::isPluginFile($fullPath) ) {
				$type = 'Plugin';
				$id = $fullPath;
			} else if ( $themeDirectory !== null ) {
				$type = 'Theme';
				$id = $themeDirectory;
			} else {
				throw new \RuntimeException(sprintf(
					'The update checker cannot determine if "%s" is a plugin or a theme. ' .
					'This is a bug. Please contact the PUC developer.',
					esc_html($fullPath)
				));
			}

			//Which hosting service does the URL point to?
			$service = self::getVcsService($metadataUrl);

			$apiClass = null;
			if ( empty($service) ) {
				//The default is to get update information from a remote JSON file.
				$checkerClass = $type . '\\UpdateChecker';
			} else {
				//You can also use a VCS repository like GitHub.
				$checkerClass = 'Vcs\\' . $type . 'UpdateChecker';
				$apiClass = $service . 'Api';
			}

			$checkerClass = self::getCompatibleClassVersion($checkerClass);
			if ( $checkerClass === null ) {
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_trigger_error
				trigger_error(
					esc_html(sprintf(
						'PUC %s does not support updates for %ss %s',
						self::$latestCompatibleVersion,
						strtolower($type),
						$service ? ('hosted on ' . $service) : 'using JSON metadata'
					)),
					E_USER_ERROR
				);
			}

			if ( !isset($apiClass) ) {
				//Plain old update checker.
				return new $checkerClass($metadataUrl, $id, $slug, $checkPeriod, $optionName, $muPluginFile);
			} else {
				//VCS checker + an API client.
				$apiClass = self::getCompatibleClassVersion($apiClass);
				if ( $apiClass === null ) {
					//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_trigger_error
					trigger_error(esc_html(sprintf(
						'PUC %s does not support %s',
						self::$latestCompatibleVersion,
						$service
					)), E_USER_ERROR);
				}

				return new $checkerClass(
					new $apiClass($metadataUrl),
					$id,
					$slug,
					$checkPeriod,
					$optionName,
					$muPluginFile
				);
			}
		}

		/**
		 *
		 * Normalize a filesystem path. Introduced in WP 3.9.
		 * Copying here allows use of the class on earlier versions.
		 * This version adapted from WP 4.8.2 (unchanged since 4.5.6)
		 *
		 * @param string $path Path to normalize.
		 * @return string Normalized path.
		 */
		public static function normalizePath($path) {
			if ( function_exists('wp_normalize_path') ) {
				return wp_normalize_path($path);
			}
			$path = str_replace('\\', '/', $path);
			$path = preg_replace('|(?<=.)/+|', '/', $path);
			if ( substr($path, 1, 1) === ':' ) {
				$path = ucfirst($path);
			}
			return $path;
		}

		/**
		 * Check if the path points to a plugin file.
		 *
		 * @param string $absolutePath Normalized path.
		 * @return bool
		 */
		protected static function isPluginFile($absolutePath) {
			//Is the file inside the "plugins" or "mu-plugins" directory?
			$pluginDir = self::normalizePath(WP_PLUGIN_DIR);
			$muPluginDir = self::normalizePath(WPMU_PLUGIN_DIR);
			if ( (strpos($absolutePath, $pluginDir) === 0) || (strpos($absolutePath, $muPluginDir) === 0) ) {
				return true;
			}

			//Is it a file at all? Caution: is_file() can fail if the parent dir. doesn't have the +x permission set.
			if ( !is_file($absolutePath) ) {
				return false;
			}

			//Does it have a valid plugin header?
			//This is a last-ditch check for plugins symlinked from outside the WP root.
			if ( function_exists('get_file_data') ) {
				$headers = get_file_data($absolutePath, array('Name' => 'Plugin Name'), 'plugin');
				return !empty($headers['Name']);
			}

			return false;
		}

		/**
		 * Get the name of the theme's directory from a full path to a file inside that directory.
		 * E.g. "/abc/public_html/wp-content/themes/foo/whatever.php" => "foo".
		 *
		 * Note that subdirectories are currently not supported. For example,
		 * "/xyz/wp-content/themes/my-theme/includes/whatever.php" => NULL.
		 *
		 * @param string $absolutePath Normalized path.
		 * @return string|null Directory name, or NULL if the path doesn't point to a theme.
		 */
		protected static function getThemeDirectoryName($absolutePath) {
			if ( is_file($absolutePath) ) {
				$absolutePath = dirname($absolutePath);
			}

			if ( file_exists($absolutePath . '/style.css') ) {
				return basename($absolutePath);
			}
			return null;
		}

		/**
		 * Get the service URI from the file header.
		 *
		 * @param string $fullPath
		 * @return string
		 */
		private static function getServiceURI($fullPath) {
			//Look for the URI
			if ( is_readable($fullPath) ) {
				$seek = array(
					'github' => 'GitHub URI',
					'gitlab' => 'GitLab URI',
					'bucket' => 'BitBucket URI',
				);
				$seek = apply_filters('puc_get_source_uri', $seek);
				$data = get_file_data($fullPath, $seek);
				foreach ($data as $key => $uri) {
					if ( $uri ) {
						return $uri;
					}
				}
			}

			//URI was not found so throw an error.
			throw new \RuntimeException(
				sprintf('Unable to locate URI in header of "%s"', esc_html($fullPath))
			);
		}

		/**
		 * Get the name of the hosting service that the URL points to.
		 *
		 * @param string $metadataUrl
		 * @return string|null
		 */
		private static function getVcsService($metadataUrl) {
			$service = null;

			//Which hosting service does the URL point to?
			$host = (string)(wp_parse_url($metadataUrl, PHP_URL_HOST));
			$path = (string)(wp_parse_url($metadataUrl, PHP_URL_PATH));

			//Check if the path looks like "/user-name/repository".
			//For GitLab.com it can also be "/user/group1/group2/.../repository".
			$repoRegex = '@^/?([^/]+?)/([^/#?&]+?)/?$@';
			if ( $host === 'gitlab.com' ) {
				$repoRegex = '@^/?(?:[^/#?&]++/){1,20}(?:[^/#?&]++)/?$@';
			}
			if ( preg_match($repoRegex, $path) ) {
				$knownServices = array(
					'github.com' => 'GitHub',
					'bitbucket.org' => 'BitBucket',
					'gitlab.com' => 'GitLab',
				);
				if ( isset($knownServices[$host]) ) {
					$service = $knownServices[$host];
				}
			}

			return apply_filters('puc_get_vcs_service', $service, $host, $path, $metadataUrl);
		}

		/**
		 * Get the latest version of the specified class that has the same major version number
		 * as this factory class.
		 *
		 * @param string $class Partial class name.
		 * @return string|null Full class name.
		 */
		protected static function getCompatibleClassVersion($class) {
			if ( isset(self::$classVersions[$class][self::$latestCompatibleVersion]) ) {
				return self::$classVersions[$class][self::$latestCompatibleVersion];
			}
			return null;
		}

		/**
		 * Get the specific class name for the latest available version of a class.
		 *
		 * @param string $class
		 * @return null|string
		 */
		public static function getLatestClassVersion($class) {
			if ( !self::$sorted ) {
				self::sortVersions();
			}

			if ( isset(self::$classVersions[$class]) ) {
				return reset(self::$classVersions[$class]);
			} else {
				return null;
			}
		}

		/**
		 * Sort available class versions in descending order (i.e. newest first).
		 */
		protected static function sortVersions() {
			foreach ( self::$classVersions as $class => $versions ) {
				uksort($versions, array(__CLASS__, 'compareVersions'));
				self::$classVersions[$class] = $versions;
			}
			self::$sorted = true;
		}

		protected static function compareVersions($a, $b) {
			return -version_compare($a, $b);
		}

		/**
		 * Register a version of a class.
		 *
		 * @access private This method is only for internal use by the library.
		 *
		 * @param string $generalClass Class name without version numbers, e.g. 'PluginUpdateChecker'.
		 * @param string $versionedClass Actual class name, e.g. 'PluginUpdateChecker_1_2'.
		 * @param string $version Version number, e.g. '1.2'.
		 */
		public static function addVersion($generalClass, $versionedClass, $version) {
			if ( empty(self::$myMajorVersion) ) {
				$lastNamespaceSegment = substr(__NAMESPACE__, strrpos(__NAMESPACE__, '\\') + 1);
				self::$myMajorVersion = substr(ltrim($lastNamespaceSegment, 'v'), 0, 1);
			}

			//Store the greatest version number that matches our major version.
			$components = explode('.', $version);
			if ( $components[0] === self::$myMajorVersion ) {

				if (
					empty(self::$latestCompatibleVersion)
					|| version_compare($version, self::$latestCompatibleVersion, '>')
				) {
					self::$latestCompatibleVersion = $version;
				}

			}

			if ( !isset(self::$classVersions[$generalClass]) ) {
				self::$classVersions[$generalClass] = array();
			}
			self::$classVersions[$generalClass][$version] = $versionedClass;
			self::$sorted = false;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Scheduler.php (11167 bytes, 301 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(Scheduler::class, false) ):

	/**
	 * The scheduler decides when and how often to check for updates.
	 * It calls @see UpdateChecker::checkForUpdates() to perform the actual checks.
	 */
	class Scheduler {
		public $checkPeriod = 12; //How often to check for updates (in hours).
		public $throttleRedundantChecks = false; //Check less often if we already know that an update is available.
		public $throttledCheckPeriod = 72;

		protected $hourlyCheckHooks = array('load-update.php');

		/**
		 * @var UpdateChecker
		 */
		protected $updateChecker;

		private $cronHook = null;

		/**
		 * Scheduler constructor.
		 *
		 * @param UpdateChecker $updateChecker
		 * @param int $checkPeriod How often to check for updates (in hours).
		 * @param array $hourlyHooks
		 */
		public function __construct($updateChecker, $checkPeriod, $hourlyHooks = array('load-plugins.php')) {
			$this->updateChecker = $updateChecker;
			$this->checkPeriod = $checkPeriod;

			//Set up the periodic update checks
			$this->cronHook = $this->updateChecker->getUniqueName('cron_check_updates');
			if ( $this->checkPeriod > 0 ){

				//Trigger the check via Cron.
				//Try to use one of the default schedules if possible as it's less likely to conflict
				//with other plugins and their custom schedules.
				$defaultSchedules = array(
					1  => 'hourly',
					12 => 'twicedaily',
					24 => 'daily',
				);
				if ( array_key_exists($this->checkPeriod, $defaultSchedules) ) {
					$scheduleName = $defaultSchedules[$this->checkPeriod];
				} else {
					//Use a custom cron schedule.
					$scheduleName = 'every' . $this->checkPeriod . 'hours';
					//phpcs:ignore WordPress.WP.CronInterval.ChangeDetected -- WPCS fails to parse the callback.
					add_filter('cron_schedules', array($this, '_addCustomSchedule'));
				}

				if ( !wp_next_scheduled($this->cronHook) && !defined('WP_INSTALLING') ) {
					//Randomly offset the schedule to help prevent update server traffic spikes. Without this
					//most checks may happen during times of day when people are most likely to install new plugins.
					$upperLimit = max($this->checkPeriod * 3600 - 15 * 60, 1);
					if ( function_exists('wp_rand') ) {
						$randomOffset = wp_rand(0, $upperLimit);
					} else {
						//This constructor may be called before wp_rand() is available.
						//phpcs:ignore WordPress.WP.AlternativeFunctions.rand_rand
						$randomOffset = rand(0, $upperLimit);
					}
					$firstCheckTime = time() - $randomOffset;
					$firstCheckTime = apply_filters(
						$this->updateChecker->getUniqueName('first_check_time'),
						$firstCheckTime
					);
					wp_schedule_event($firstCheckTime, $scheduleName, $this->cronHook);
				}
				add_action($this->cronHook, array($this, 'maybeCheckForUpdates'));

				//In case Cron is disabled or unreliable, we also manually trigger
				//the periodic checks while the user is browsing the Dashboard.
				add_action( 'admin_init', array($this, 'maybeCheckForUpdates') );

				//Like WordPress itself, we check more often on certain pages.
				/** @see wp_update_plugins */
				add_action('load-update-core.php', array($this, 'maybeCheckForUpdates'));
				//phpcs:ignore Squiz.PHP.CommentedOutCode.Found -- Not actually code, just file names.
				//"load-update.php" and "load-plugins.php" or "load-themes.php".
				$this->hourlyCheckHooks = array_merge($this->hourlyCheckHooks, $hourlyHooks);
				foreach($this->hourlyCheckHooks as $hook) {
					add_action($hook, array($this, 'maybeCheckForUpdates'));
				}
				//This hook fires after a bulk update is complete.
				add_action('upgrader_process_complete', array($this, 'removeHooksIfLibraryGone'), 1, 0);
				add_action('upgrader_process_complete', array($this, 'upgraderProcessComplete'), 11, 2);

			} else {
				//Periodic checks are disabled.
				wp_clear_scheduled_hook($this->cronHook);
			}
		}

		/**
		 * Remove all hooks if this version of PUC has been deleted or overwritten.
		 *
		 * Callback for the "upgrader_process_complete" action.
		 */
		public function removeHooksIfLibraryGone() {
			//Cancel all further actions if the current version of PUC has been deleted or overwritten
			//by a different version during the upgrade. If we try to do anything more in that situation,
			//we could trigger a fatal error by trying to autoload a deleted class.
			clearstatcache();
			if ( !file_exists(__FILE__) ) {
				$this->removeHooks();
				$this->updateChecker->removeHooks();
			}
		}

		/**
		 * Runs upon the WP action upgrader_process_complete.
		 *
		 * We look at the parameters to decide whether to call maybeCheckForUpdates() or not.
		 * We also check if the update checker has been removed by the update.
		 *
		 * @param \WP_Upgrader $upgrader  WP_Upgrader instance
		 * @param array $upgradeInfo extra information about the upgrade
		 */
		public function upgraderProcessComplete(
			/** @noinspection PhpUnusedParameterInspection */
			$upgrader, $upgradeInfo
		) {
			//Sanity check and limitation to relevant types.
			if (
				!is_array($upgradeInfo) || !isset($upgradeInfo['type'], $upgradeInfo['action'])
				|| 'update' !== $upgradeInfo['action'] || !in_array($upgradeInfo['type'], array('plugin', 'theme'))
			) {
				return;
			}

			//Filter out notifications of upgrades that should have no bearing upon whether or not our
			//current info is up-to-date.
			if ( is_a($this->updateChecker, Theme\UpdateChecker::class) ) {
				if ( 'theme' !== $upgradeInfo['type'] || !isset($upgradeInfo['themes']) ) {
					return;
				}

				//Letting too many things going through for checks is not a real problem, so we compare widely.
				if ( !in_array(
					strtolower($this->updateChecker->directoryName),
					array_map('strtolower', $upgradeInfo['themes'])
				) ) {
					return;
				}
			}

			if ( is_a($this->updateChecker, Plugin\UpdateChecker::class) ) {
				if ( 'plugin' !== $upgradeInfo['type'] || !isset($upgradeInfo['plugins']) ) {
					return;
				}

				//Themes pass in directory names in the information array, but plugins use the relative plugin path.
				if ( !in_array(
					strtolower($this->updateChecker->directoryName),
					array_map('dirname', array_map('strtolower', $upgradeInfo['plugins']))
				) ) {
					return;
				}
			}

			$this->maybeCheckForUpdates();
		}

		/**
		 * Check for updates if the configured check interval has already elapsed.
		 * Will use a shorter check interval on certain admin pages like "Dashboard -> Updates" or when doing cron.
		 *
		 * You can override the default behaviour by using the "puc_check_now-$slug" filter.
		 * The filter callback will be passed three parameters:
		 *     - Current decision. TRUE = check updates now, FALSE = don't check now.
		 *     - Last check time as a Unix timestamp.
		 *     - Configured check period in hours.
		 * Return TRUE to check for updates immediately, or FALSE to cancel.
		 *
		 * This method is declared public because it's a hook callback. Calling it directly is not recommended.
		 */
		public function maybeCheckForUpdates() {
			if ( empty($this->checkPeriod) ){
				return;
			}

			$state = $this->updateChecker->getUpdateState();
			$shouldCheck = ($state->timeSinceLastCheck() >= $this->getEffectiveCheckPeriod());

			if ( $shouldCheck ) {
				//Sanity check: Do not proceed if one of the critical classes is missing.
				//That can happen - theoretically and extremely rarely - if maybeCheckForUpdates()
				//is called before the old version of our plugin has been fully deleted, or
				//called from an independent AJAX request during deletion.
				if ( !(
					class_exists(Utils::class)
					&& class_exists(Metadata::class)
					&& class_exists(Plugin\Update::class)
					&& class_exists(Theme\Update::class)
				) ) {
					return;
				}
			}

			//Let plugin authors substitute their own algorithm.
			$shouldCheck = apply_filters(
				$this->updateChecker->getUniqueName('check_now'),
				$shouldCheck,
				$state->getLastCheck(),
				$this->checkPeriod
			);

			if ( $shouldCheck ) {
				$this->updateChecker->checkForUpdates();
			}
		}

		/**
		 * Calculate the actual check period based on the current status and environment.
		 *
		 * @return int Check period in seconds.
		 */
		protected function getEffectiveCheckPeriod() {
			$currentFilter = current_filter();
			if ( in_array($currentFilter, array('load-update-core.php', 'upgrader_process_complete')) ) {
				//Check more often when the user visits "Dashboard -> Updates" or does a bulk update.
				$period = 60;
			} else if ( in_array($currentFilter, $this->hourlyCheckHooks) ) {
				//Also check more often on /wp-admin/update.php and the "Plugins" or "Themes" page.
				$period = 3600;
			} else if ( $this->throttleRedundantChecks && ($this->updateChecker->getUpdate() !== null) ) {
				//Check less frequently if it's already known that an update is available.
				$period = $this->throttledCheckPeriod * 3600;
			} else if ( defined('DOING_CRON') && constant('DOING_CRON') ) {
				//WordPress cron schedules are not exact, so let's do an update check even
				//if slightly less than $checkPeriod hours have elapsed since the last check.
				$cronFuzziness = 20 * 60;
				$period = $this->checkPeriod * 3600 - $cronFuzziness;
			} else {
				$period = $this->checkPeriod * 3600;
			}

			return $period;
		}

		/**
		 * Add our custom schedule to the array of Cron schedules used by WP.
		 *
		 * @param array $schedules
		 * @return array
		 */
		public function _addCustomSchedule($schedules) {
			if ( $this->checkPeriod && ($this->checkPeriod > 0) ){
				$scheduleName = 'every' . $this->checkPeriod . 'hours';
				$schedules[$scheduleName] = array(
					'interval' => $this->checkPeriod * 3600,
					'display' => sprintf('Every %d hours', $this->checkPeriod),
				);
			}
			return $schedules;
		}

		/**
		 * Remove the scheduled cron event that the library uses to check for updates.
		 *
		 * @return void
		 */
		public function removeUpdaterCron() {
			wp_clear_scheduled_hook($this->cronHook);
		}

		/**
		 * Get the name of the update checker's WP-cron hook. Mostly useful for debugging.
		 *
		 * @return string
		 */
		public function getCronHookName() {
			return $this->cronHook;
		}

		/**
		 * Remove most hooks added by the scheduler.
		 */
		public function removeHooks() {
			remove_filter('cron_schedules', array($this, '_addCustomSchedule'));
			remove_action('admin_init', array($this, 'maybeCheckForUpdates'));
			remove_action('load-update-core.php', array($this, 'maybeCheckForUpdates'));

			if ( $this->cronHook !== null ) {
				remove_action($this->cronHook, array($this, 'maybeCheckForUpdates'));
			}
			if ( !empty($this->hourlyCheckHooks) ) {
				foreach ($this->hourlyCheckHooks as $hook) {
					remove_action($hook, array($this, 'maybeCheckForUpdates'));
				}
			}
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\StateStore.php (4972 bytes, 215 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(StateStore::class, false) ):

	class StateStore {
		/**
		 * @var int Last update check timestamp.
		 */
		protected $lastCheck = 0;

		/**
		 * @var string Version number.
		 */
		protected $checkedVersion = '';

		/**
		 * @var Update|null Cached update.
		 */
		protected $update = null;

		/**
		 * @var string Site option name.
		 */
		private $optionName = '';

		/**
		 * @var bool Whether we've already tried to load the state from the database.
		 */
		private $isLoaded = false;

		public function __construct($optionName) {
			$this->optionName = $optionName;
		}

		/**
		 * Get time elapsed since the last update check.
		 *
		 * If there are no recorded update checks, this method returns a large arbitrary number
		 * (i.e. time since the Unix epoch).
		 *
		 * @return int Elapsed time in seconds.
		 */
		public function timeSinceLastCheck() {
			$this->lazyLoad();
			return time() - $this->lastCheck;
		}

		/**
		 * @return int
		 */
		public function getLastCheck() {
			$this->lazyLoad();
			return $this->lastCheck;
		}

		/**
		 * Set the time of the last update check to the current timestamp.
		 *
		 * @return $this
		 */
		public function setLastCheckToNow() {
			$this->lazyLoad();
			$this->lastCheck = time();
			return $this;
		}

		/**
		 * @return null|Update
		 */
		public function getUpdate() {
			$this->lazyLoad();
			return $this->update;
		}

		/**
		 * @param Update|null $update
		 * @return $this
		 */
		public function setUpdate($update = null) {
			$this->lazyLoad();
			$this->update = $update;
			return $this;
		}

		/**
		 * @return string
		 */
		public function getCheckedVersion() {
			$this->lazyLoad();
			return $this->checkedVersion;
		}

		/**
		 * @param string $version
		 * @return $this
		 */
		public function setCheckedVersion($version) {
			$this->lazyLoad();
			$this->checkedVersion = strval($version);
			return $this;
		}

		/**
		 * Get translation updates.
		 *
		 * @return array
		 */
		public function getTranslations() {
			$this->lazyLoad();
			if ( isset($this->update, $this->update->translations) ) {
				return $this->update->translations;
			}
			return array();
		}

		/**
		 * Set translation updates.
		 *
		 * @param array $translationUpdates
		 */
		public function setTranslations($translationUpdates) {
			$this->lazyLoad();
			if ( isset($this->update) ) {
				$this->update->translations = $translationUpdates;
				$this->save();
			}
		}

		public function save() {
			$state = new \stdClass();

			$state->lastCheck = $this->lastCheck;
			$state->checkedVersion = $this->checkedVersion;

			if ( isset($this->update)) {
				$state->update = $this->update->toStdClass();

				$updateClass = get_class($this->update);
				$state->updateClass = $updateClass;
				$prefix = $this->getLibPrefix();
				if ( Utils::startsWith($updateClass, $prefix) ) {
					$state->updateBaseClass = substr($updateClass, strlen($prefix));
				}
			}

			update_site_option($this->optionName, $state);
			$this->isLoaded = true;
		}

		/**
		 * @return $this
		 */
		public function lazyLoad() {
			if ( !$this->isLoaded ) {
				$this->load();
			}
			return $this;
		}

		protected function load() {
			$this->isLoaded = true;

			$state = get_site_option($this->optionName, null);

			if (
				!is_object($state)
				//Sanity check: If the Utils class is missing, the plugin is probably in the process
				//of being deleted (e.g. the old version gets deleted during an update).
				|| !class_exists(Utils::class)
			) {
				$this->lastCheck = 0;
				$this->checkedVersion = '';
				$this->update = null;
				return;
			}

			$this->lastCheck = intval(Utils::get($state, 'lastCheck', 0));
			$this->checkedVersion = Utils::get($state, 'checkedVersion', '');
			$this->update = null;

			if ( isset($state->update) ) {
				//This mess is due to the fact that the want the update class from this version
				//of the library, not the version that saved the update.

				$updateClass = null;
				if ( isset($state->updateBaseClass) ) {
					$updateClass = $this->getLibPrefix() . $state->updateBaseClass;
				} else if ( isset($state->updateClass) ) {
					$updateClass = $state->updateClass;
				}

				$factory = array($updateClass, 'fromObject');
				if ( ($updateClass !== null) && is_callable($factory) ) {
					$this->update = call_user_func($factory, $state->update);
				}
			}
		}

		public function delete() {
			delete_site_option($this->optionName);

			$this->lastCheck = 0;
			$this->checkedVersion = '';
			$this->update = null;
		}

		private function getLibPrefix() {
			//This assumes that the current class is at the top of the versioned namespace.
			return __NAMESPACE__ . '\\';
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Update.php (787 bytes, 39 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

use stdClass;

if ( !class_exists(Update::class, false) ):

	/**
	 * A simple container class for holding information about an available update.
	 *
	 * @author Janis Elsts
	 * @access public
	 */
	abstract class Update extends Metadata {
		public $slug;
		public $version;
		public $download_url;
		public $translations = array();

		/**
		 * @return string[]
		 */
		protected function getFieldNames() {
			return array('slug', 'version', 'download_url', 'translations');
		}

		public function toWpFormat() {
			$update = new stdClass();

			$update->slug = $this->slug;
			$update->new_version = $this->version;
			$update->package = $this->download_url;

			return $update;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\UpdateChecker.php (37442 bytes, 1142 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

use stdClass;
use WP_Error;

if ( !class_exists(UpdateChecker::class, false) ):

	abstract class UpdateChecker {
		protected $filterSuffix = '';
		protected $updateTransient = '';

		/**
		 * @var string This can be "plugin" or "theme".
		 */
		protected $componentType = '';
		/**
		 * @var string Currently the same as $componentType, but this is an implementation detail that
		 *             depends on how WP works internally, and could therefore change.
		 */
		protected $translationType = '';

		/**
		 * Set to TRUE to enable error reporting. Errors are raised using trigger_error()
		 * and should be logged to the standard PHP error log.
		 * @var bool
		 */
		public $debugMode = null;

		/**
		 * @var string Where to store the update info.
		 */
		public $optionName = '';

		/**
		 * @var string The URL of the metadata file.
		 */
		public $metadataUrl = '';

		/**
		 * @var string Plugin or theme directory name.
		 */
		public $directoryName = '';

		/**
		 * @var string The slug that will be used in update checker hooks and remote API requests.
		 * Usually matches the directory name unless the plugin/theme directory has been renamed.
		 */
		public $slug = '';

		/**
		 * @var InstalledPackage
		 */
		protected $package;

		/**
		 * @var Scheduler
		 */
		public $scheduler;

		/**
		 * @var UpgraderStatus
		 */
		protected $upgraderStatus;

		/**
		 * @var StateStore
		 */
		protected $updateState;

		/**
		 * @var array List of API errors triggered during the last checkForUpdates() call.
		 */
		protected $lastRequestApiErrors = array();

		/**
		 * @var string|mixed The default is 0 because parse_url() can return NULL or FALSE.
		 */
		protected $cachedMetadataHost = 0;

		/**
		 * @var DebugBar\Extension|null
		 */
		protected $debugBarExtension = null;

		/**
		 * @var WpCliCheckTrigger|null
		 */
		protected $wpCliCheckTrigger = null;

		public function __construct($metadataUrl, $directoryName, $slug = null, $checkPeriod = 12, $optionName = '') {
			$this->debugMode = (bool)(constant('WP_DEBUG'));
			$this->metadataUrl = $metadataUrl;
			$this->directoryName = $directoryName;
			$this->slug = !empty($slug) ? $slug : $this->directoryName;

			$this->optionName = $optionName;
			if ( empty($this->optionName) ) {
				//BC: Initially the library only supported plugin updates and didn't use type prefixes
				//in the option name. Lets use the same prefix-less name when possible.
				if ( $this->filterSuffix === '' ) {
					$this->optionName = 'external_updates-' . $this->slug;
				} else {
					$this->optionName = $this->getUniqueName('external_updates');
				}
			}

			if ( empty($this->translationType) ) {
				$this->translationType = $this->componentType;
			}

			$this->package = $this->createInstalledPackage();
			$this->scheduler = $this->createScheduler($checkPeriod);
			$this->upgraderStatus = new UpgraderStatus();
			$this->updateState = new StateStore($this->optionName);

			if ( did_action('init') ) {
				$this->loadTextDomain();
			} else {
				add_action('init', array($this, 'loadTextDomain'));
			}

			$this->installHooks();

			if ( ($this->wpCliCheckTrigger === null) && defined('WP_CLI') ) {
				$this->wpCliCheckTrigger = new WpCliCheckTrigger($this->componentType, $this->scheduler);
			}
		}

		/**
		 * @internal
		 */
		public function loadTextDomain() {
			//We're not using load_plugin_textdomain() or its siblings because figuring out where
			//the library is located (plugin, mu-plugin, theme, custom wp-content paths) is messy.
			$domain = 'plugin-update-checker';
			$locale = apply_filters(
				'plugin_locale',
				(is_admin() && function_exists('get_user_locale')) ? get_user_locale() : get_locale(),
				$domain
			);

			$moFile = $domain . '-' . $locale . '.mo';
			$path = realpath(dirname(__FILE__) . '/../../languages');

			if ($path && file_exists($path)) {
				load_textdomain($domain, $path . '/' . $moFile);
			}
		}

		protected function installHooks() {
			//Insert our update info into the update array maintained by WP.
			add_filter('site_transient_' . $this->updateTransient, array($this,'injectUpdate'));

			//Insert translation updates into the update list.
			add_filter('site_transient_' . $this->updateTransient, array($this, 'injectTranslationUpdates'));

			//Clear translation updates when WP clears the update cache.
			//This needs to be done directly because the library doesn't actually remove obsolete plugin updates,
			//it just hides them (see getUpdate()). We can't do that with translations - too much disk I/O.
			add_action(
				'delete_site_transient_' . $this->updateTransient,
				array($this, 'clearCachedTranslationUpdates')
			);

			//Rename the update directory to be the same as the existing directory.
			if ( $this->directoryName !== '.' ) {
				add_filter('upgrader_source_selection', array($this, 'fixDirectoryName'), 10, 3);
			}

			//Allow HTTP requests to the metadata URL even if it's on a local host.
			add_filter('http_request_host_is_external', array($this, 'allowMetadataHost'), 10, 2);

			//Potentially exclude information about this entity from core update check requests to api.wordpress.org.
			//phpcs:ignore WordPressVIPMinimum.Hooks.RestrictedHooks.http_request_args -- Doesn't modify timeouts.
			add_filter('http_request_args', array($this, 'excludeEntityFromWordPressAPI'), 10, 2);

			//DebugBar integration.
			if ( did_action('plugins_loaded') ) {
				$this->maybeInitDebugBar();
			} else {
				add_action('plugins_loaded', array($this, 'maybeInitDebugBar'));
			}
		}

		/**
		 * Remove hooks that were added by this update checker instance.
		 */
		public function removeHooks() {
			remove_filter('site_transient_' . $this->updateTransient, array($this,'injectUpdate'));
			remove_filter('site_transient_' . $this->updateTransient, array($this, 'injectTranslationUpdates'));
			remove_action(
				'delete_site_transient_' . $this->updateTransient,
				array($this, 'clearCachedTranslationUpdates')
			);

			remove_filter('upgrader_source_selection', array($this, 'fixDirectoryName'), 10);
			remove_filter('http_request_host_is_external', array($this, 'allowMetadataHost'), 10);
			remove_filter('http_request_args', array($this, 'excludeEntityFromWordPressAPI'));
			remove_action('plugins_loaded', array($this, 'maybeInitDebugBar'));

			remove_action('init', array($this, 'loadTextDomain'));

			if ( $this->scheduler ) {
				$this->scheduler->removeHooks();
			}

			if ( $this->debugBarExtension ) {
				$this->debugBarExtension->removeHooks();
			}
		}

		/**
		 * Check if the current user has the required permissions to install updates.
		 *
		 * @return bool
		 */
		abstract public function userCanInstallUpdates();

		/**
		 * Explicitly allow HTTP requests to the metadata URL.
		 *
		 * WordPress has a security feature where the HTTP API will reject all requests that are sent to
		 * another site hosted on the same server as the current site (IP match), a local host, or a local
		 * IP, unless the host exactly matches the current site.
		 *
		 * This feature is opt-in (at least in WP 4.4). Apparently some people enable it.
		 *
		 * That can be a problem when you're developing your plugin and you decide to host the update information
		 * on the same server as your test site. Update requests will mysteriously fail.
		 *
		 * We fix that by adding an exception for the metadata host.
		 *
		 * @param bool $allow
		 * @param string $host
		 * @return bool
		 */
		public function allowMetadataHost($allow, $host) {
			if ( $this->cachedMetadataHost === 0 ) {
				$this->cachedMetadataHost = wp_parse_url($this->metadataUrl, PHP_URL_HOST);
			}

			if ( is_string($this->cachedMetadataHost) && (strtolower($host) === strtolower($this->cachedMetadataHost)) ) {
				return true;
			}
			return $allow;
		}

		/**
		 * Create a package instance that represents this plugin or theme.
		 *
		 * @return InstalledPackage
		 */
		abstract protected function createInstalledPackage();

		/**
		 * @return InstalledPackage
		 */
		public function getInstalledPackage() {
			return $this->package;
		}

		/**
		 * Create an instance of the scheduler.
		 *
		 * This is implemented as a method to make it possible for plugins to subclass the update checker
		 * and substitute their own scheduler.
		 *
		 * @param int $checkPeriod
		 * @return Scheduler
		 */
		abstract protected function createScheduler($checkPeriod);

		/**
		 * Remove information about this plugin or theme from the requests that WordPress core sends
		 * to api.wordpress.org when checking for updates.
		 *
		 * @param array $args
		 * @param string $url
		 * @return array
		 */
		public function excludeEntityFromWordPressAPI($args, $url) {
			//Is this an api.wordpress.org update check request?
			$parsedUrl = wp_parse_url($url);
			if ( !isset($parsedUrl['host']) || (strtolower($parsedUrl['host']) !== 'api.wordpress.org') ) {
				return $args;
			}

			$typePluralised = $this->componentType . 's';
			$expectedPathPrefix = '/' . $typePluralised . '/update-check/1.';  //e.g. "/plugins/update-check/1.1/"
			if ( !isset($parsedUrl['path']) || !Utils::startsWith($parsedUrl['path'], $expectedPathPrefix) ) {
				return $args;
			}

			//Plugins and themes can disable this feature by using the filter below.
			if ( !apply_filters(
				$this->getUniqueName('remove_from_default_update_checks'),
				true, $this, $args, $url
			) ) {
				return $args;
			}

			if ( empty($args['body'][$typePluralised]) ) {
				return $args;
			}

			$reportingItems = json_decode($args['body'][$typePluralised], true);
			if ( $reportingItems === null ) {
				return $args;
			}

			//The list of installed items uses different key formats for plugins and themes.
			//Luckily, we can reuse the getUpdateListKey() method here.
			$updateListKey = $this->getUpdateListKey();
			if ( isset($reportingItems[$typePluralised][$updateListKey]) ) {
				unset($reportingItems[$typePluralised][$updateListKey]);
			}

			if ( !empty($reportingItems['active']) ) {
				if ( is_array($reportingItems['active']) ) {
					foreach ($reportingItems['active'] as $index => $relativePath) {
						if ( $relativePath === $updateListKey ) {
							unset($reportingItems['active'][$index]);
						}
					}
					//Re-index the array.
					$reportingItems['active'] = array_values($reportingItems['active']);
				} else if ( $reportingItems['active'] === $updateListKey ) {
					//For themes, the "active" field is a string that contains the theme's directory name.
					//Pretend that the default theme is active so that we don't reveal the actual theme.
					if ( defined('WP_DEFAULT_THEME') ) {
						$reportingItems['active'] = WP_DEFAULT_THEME;
					}

					//Unfortunately, it doesn't seem to be documented if we can safely remove the "active"
					//key. So when we don't know the default theme, we'll just leave it as is.
				}
			}

			$args['body'][$typePluralised] = wp_json_encode($reportingItems);
			return $args;
		}

		/**
		 * Check for updates. The results are stored in the DB option specified in $optionName.
		 *
		 * @return Update|null
		 */
		public function checkForUpdates() {
			$installedVersion = $this->getInstalledVersion();
			//Fail silently if we can't find the plugin/theme or read its header.
			if ( $installedVersion === null ) {
				$this->triggerError(
					sprintf('Skipping update check for %s - installed version unknown.', $this->slug),
					E_USER_WARNING
				);
				return null;
			}

			//Start collecting API errors.
			$this->lastRequestApiErrors = array();
			add_action('puc_api_error', array($this, 'collectApiErrors'), 10, 4);

			$state = $this->updateState;
			$state->setLastCheckToNow()
				->setCheckedVersion($installedVersion)
				->save(); //Save before checking in case something goes wrong

			$state->setUpdate($this->requestUpdate());
			$state->save();

			//Stop collecting API errors.
			remove_action('puc_api_error', array($this, 'collectApiErrors'), 10);

			return $this->getUpdate();
		}

		/**
		 * Load the update checker state from the DB.
		 *
		 * @return StateStore
		 */
		public function getUpdateState() {
			return $this->updateState->lazyLoad();
		}

		/**
		 * Reset update checker state - i.e. last check time, cached update data and so on.
		 *
		 * Call this when your plugin is being uninstalled, or if you want to
		 * clear the update cache.
		 */
		public function resetUpdateState() {
			$this->updateState->delete();
		}

		/**
		 * Get the details of the currently available update, if any.
		 *
		 * If no updates are available, or if the last known update version is below or equal
		 * to the currently installed version, this method will return NULL.
		 *
		 * Uses cached update data. To retrieve update information straight from
		 * the metadata URL, call requestUpdate() instead.
		 *
		 * @return Update|null
		 */
		public function getUpdate() {
			$update = $this->updateState->getUpdate();

			//Is there an update available?
			if ( isset($update) ) {
				//Check if the update is actually newer than the currently installed version.
				$installedVersion = $this->getInstalledVersion();
				if ( ($installedVersion !== null) && version_compare($update->version, $installedVersion, '>') ){
					return $update;
				}
			}
			return null;
		}

		/**
		 * Retrieve the latest update (if any) from the configured API endpoint.
		 *
		 * Subclasses should run the update through filterUpdateResult before returning it.
		 *
		 * @return Update An instance of Update, or NULL when no updates are available.
		 */
		abstract public function requestUpdate();

		/**
		 * Filter the result of a requestUpdate() call.
		 *
		 * @template T of Update
		 * @param T|null $update
		 * @param array|WP_Error|null $httpResult The value returned by wp_remote_get(), if any.
		 * @return T
		 */
		protected function filterUpdateResult($update, $httpResult = null) {
			//Let plugins/themes modify the update.
			$update = apply_filters($this->getUniqueName('request_update_result'), $update, $httpResult);

			$this->fixSupportedWordpressVersion($update);

			if ( isset($update, $update->translations) ) {
				//Keep only those translation updates that apply to this site.
				$update->translations = $this->filterApplicableTranslations($update->translations);
			}

			return $update;
		}

		/**
		 * The "Tested up to" field in the plugin metadata is supposed to be in the form of "major.minor",
		 * while WordPress core's list_plugin_updates() expects the $update->tested field to be an exact
		 * version, e.g. "major.minor.patch", to say it's compatible. In other case it shows
		 * "Compatibility: Unknown".
		 * The function mimics how wordpress.org API crafts the "tested" field out of "Tested up to".
		 *
		 * @param Metadata|null $update
		 */
		protected function fixSupportedWordpressVersion($update = null) {
			if ( !isset($update->tested) || !preg_match('/^\d++\.\d++$/', $update->tested) ) {
				return;
			}

			$actualWpVersions = array();

			$wpVersion = $GLOBALS['wp_version'];

			if ( function_exists('get_core_updates') ) {
				$coreUpdates = get_core_updates();
				if ( is_array($coreUpdates) ) {
					foreach ($coreUpdates as $coreUpdate) {
						if ( isset($coreUpdate->current) ) {
							$actualWpVersions[] = $coreUpdate->current;
						}
					}
				}
			}

			$actualWpVersions[] = $wpVersion;

			$actualWpPatchNumber = null;
			foreach ($actualWpVersions as $version) {
				if ( preg_match('/^(?P<majorMinor>\d++\.\d++)(?:\.(?P<patch>\d++))?/', $version, $versionParts) ) {
					if ( $versionParts['majorMinor'] === $update->tested ) {
						$patch = isset($versionParts['patch']) ? intval($versionParts['patch']) : 0;
						if ( $actualWpPatchNumber === null ) {
							$actualWpPatchNumber = $patch;
						} else {
							$actualWpPatchNumber = max($actualWpPatchNumber, $patch);
						}
					}
				}
			}
			if ( $actualWpPatchNumber === null ) {
				$actualWpPatchNumber = 999;
			}

			if ( $actualWpPatchNumber > 0 ) {
				$update->tested .= '.' . $actualWpPatchNumber;
			}
		}

		/**
		 * Get the currently installed version of the plugin or theme.
		 *
		 * @return string|null Version number.
		 */
		public function getInstalledVersion() {
			return $this->package->getInstalledVersion();
		}

		/**
		 * Get the full path of the plugin or theme directory.
		 *
		 * @return string
		 */
		public function getAbsoluteDirectoryPath() {
			return $this->package->getAbsoluteDirectoryPath();
		}

		/**
		 * Trigger a PHP error, but only when $debugMode is enabled.
		 *
		 * @param string $message
		 * @param int $errorType
		 */
		public function triggerError($message, $errorType) {
			if ( $this->isDebugModeEnabled() ) {
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_trigger_error -- Only happens in debug mode.
				trigger_error(esc_html($message), $errorType);
			}
		}

		/**
		 * @return bool
		 */
		protected function isDebugModeEnabled() {
			if ( $this->debugMode === null ) {
				$this->debugMode = (bool)(constant('WP_DEBUG'));
			}
			return $this->debugMode;
		}

		/**
		 * Get the full name of an update checker filter, action or DB entry.
		 *
		 * This method adds the "puc_" prefix and the "-$slug" suffix to the filter name.
		 * For example, "pre_inject_update" becomes "puc_pre_inject_update-plugin-slug".
		 *
		 * @param string $baseTag
		 * @return string
		 */
		public function getUniqueName($baseTag) {
			$name = 'puc_' . $baseTag;
			if ( $this->filterSuffix !== '' ) {
				$name .= '_' . $this->filterSuffix;
			}
			return $name . '-' . $this->slug;
		}

		/**
		 * Store API errors that are generated when checking for updates.
		 *
		 * @internal
		 * @param \WP_Error $error
		 * @param array|null $httpResponse
		 * @param string|null $url
		 * @param string|null $slug
		 */
		public function collectApiErrors($error, $httpResponse = null, $url = null, $slug = null) {
			if ( isset($slug) && ($slug !== $this->slug) ) {
				return;
			}

			$this->lastRequestApiErrors[] = array(
				'error'        => $error,
				'httpResponse' => $httpResponse,
				'url'          => $url,
			);
		}

		/**
		 * @return array
		 */
		public function getLastRequestApiErrors() {
			return $this->lastRequestApiErrors;
		}

		/* -------------------------------------------------------------------
		 * PUC filters and filter utilities
		 * -------------------------------------------------------------------
		 */

		/**
		 * Register a callback for one of the update checker filters.
		 *
		 * Identical to add_filter(), except it automatically adds the "puc_" prefix
		 * and the "-$slug" suffix to the filter name. For example, "request_info_result"
		 * becomes "puc_request_info_result-your_plugin_slug".
		 *
		 * @param string $tag
		 * @param callable $callback
		 * @param int $priority
		 * @param int $acceptedArgs
		 */
		public function addFilter($tag, $callback, $priority = 10, $acceptedArgs = 1) {
			add_filter($this->getUniqueName($tag), $callback, $priority, $acceptedArgs);
		}

		/* -------------------------------------------------------------------
		 * Inject updates
		 * -------------------------------------------------------------------
		 */

		/**
		 * Insert the latest update (if any) into the update list maintained by WP.
		 *
		 * @param \stdClass $updates Update list.
		 * @return \stdClass Modified update list.
		 */
		public function injectUpdate($updates) {
			//Is there an update to insert?
			$update = $this->getUpdate();

			if ( !$this->shouldShowUpdates() ) {
				$update = null;
			}

			if ( !empty($update) ) {
				//Let plugins filter the update info before it's passed on to WordPress.
				$update = apply_filters($this->getUniqueName('pre_inject_update'), $update);
				$updates = $this->addUpdateToList($updates, $update->toWpFormat());
			} else {
				//Clean up any stale update info.
				$updates = $this->removeUpdateFromList($updates);
				//Add a placeholder item to the "no_update" list to enable auto-update support.
				//If we don't do this, the option to enable automatic updates will only show up
				//when an update is available.
				$updates = $this->addNoUpdateItem($updates);
			}

			return $updates;
		}

		/**
		 * @param \stdClass|null $updates
		 * @param \stdClass|array $updateToAdd
		 * @return \stdClass
		 */
		protected function addUpdateToList($updates, $updateToAdd) {
			if ( !is_object($updates) ) {
				$updates = new stdClass();
				$updates->response = array();
			}

			$updates->response[$this->getUpdateListKey()] = $updateToAdd;
			return $updates;
		}

		/**
		 * @param \stdClass|null $updates
		 * @return \stdClass|null
		 */
		protected function removeUpdateFromList($updates) {
			if ( isset($updates, $updates->response) ) {
				unset($updates->response[$this->getUpdateListKey()]);
			}
			return $updates;
		}

		/**
		 * See this post for more information:
		 * @link https://make.wordpress.org/core/2020/07/30/recommended-usage-of-the-updates-api-to-support-the-auto-updates-ui-for-plugins-and-themes-in-wordpress-5-5/
		 *
		 * @param \stdClass|null $updates
		 * @return \stdClass
		 */
		protected function addNoUpdateItem($updates) {
			if ( !is_object($updates) ) {
				$updates = new stdClass();
				$updates->response = array();
				$updates->no_update = array();
			} else if ( !isset($updates->no_update) ) {
				$updates->no_update = array();
			}

			$updates->no_update[$this->getUpdateListKey()] = (object) $this->getNoUpdateItemFields();

			return $updates;
		}

		/**
		 * Subclasses should override this method to add fields that are specific to plugins or themes.
		 * @return array
		 */
		protected function getNoUpdateItemFields() {
			return array(
				'new_version'   => $this->getInstalledVersion(),
				'url'           => '',
				'package'       => '',
				'requires_php'  => '',
			);
		}

		/**
		 * Get the key that will be used when adding updates to the update list that's maintained
		 * by the WordPress core. The list is always an associative array, but the key is different
		 * for plugins and themes.
		 *
		 * @return string
		 */
		abstract protected function getUpdateListKey();

		/**
		 * Should we show available updates?
		 *
		 * Usually the answer is "yes", but there are exceptions. For example, WordPress doesn't
		 * support automatic updates installation for mu-plugins, so PUC usually won't show update
		 * notifications in that case. See the plugin-specific subclass for details.
		 *
		 * Note: This method only applies to updates that are displayed (or not) in the WordPress
		 * admin. It doesn't affect APIs like requestUpdate and getUpdate.
		 *
		 * @return bool
		 */
		protected function shouldShowUpdates() {
			return true;
		}

		/* -------------------------------------------------------------------
		 * JSON-based update API
		 * -------------------------------------------------------------------
		 */

		/**
		 * Retrieve plugin or theme metadata from the JSON document at $this->metadataUrl.
		 *
		 * @param class-string<Update> $metaClass Parse the JSON as an instance of this class. It must have a static fromJson method.
		 * @param string $filterRoot
		 * @param array $queryArgs Additional query arguments.
		 * @return array<Metadata|null, array|WP_Error> A metadata instance and the value returned by wp_remote_get().
		 */
		protected function requestMetadata($metaClass, $filterRoot, $queryArgs = array()) {
			//Query args to append to the URL. Plugins can add their own by using a filter callback (see addQueryArgFilter()).
			$queryArgs = array_merge(
				array(
					'installed_version' => strval($this->getInstalledVersion()),
					'php' => phpversion(),
					'locale' => get_locale(),
				),
				$queryArgs
			);
			$queryArgs = apply_filters($this->getUniqueName($filterRoot . '_query_args'), $queryArgs);

			//Various options for the wp_remote_get() call. Plugins can filter these, too.
			$options = array(
				'timeout' => wp_doing_cron() ? 10 : 3,
				'headers' => array(
					'Accept' => 'application/json',
				),
			);
			$options = apply_filters($this->getUniqueName($filterRoot . '_options'), $options);

			//The metadata file should be at 'http://your-api.com/url/here/$slug/info.json'
			$url = $this->metadataUrl;
			if ( !empty($queryArgs) ){
				$url = add_query_arg($queryArgs, $url);
			}

			$result = wp_remote_get($url, $options);

			$result = apply_filters($this->getUniqueName('request_metadata_http_result'), $result, $url, $options);

			//Try to parse the response
			$status = $this->validateApiResponse($result);
			$metadata = null;
			if ( !is_wp_error($status) ){
				if ( (strpos($metaClass, '\\') === false) ) {
					$metaClass = __NAMESPACE__ . '\\' . $metaClass;
				}
				$metadata = call_user_func(array($metaClass, 'fromJson'), $result['body']);
			} else {
				do_action('puc_api_error', $status, $result, $url, $this->slug);
				$this->triggerError(
					sprintf('The URL %s does not point to a valid metadata file. ', $url)
					. $status->get_error_message(),
					E_USER_WARNING
				);
			}

			return array($metadata, $result);
		}

		/**
		 * Check if $result is a successful update API response.
		 *
		 * @param array|WP_Error $result
		 * @return true|WP_Error
		 */
		protected function validateApiResponse($result) {
			if ( is_wp_error($result) ) { /** @var WP_Error $result */
				return new WP_Error($result->get_error_code(), 'WP HTTP Error: ' . $result->get_error_message());
			}

			if ( !isset($result['response']['code']) ) {
				return new WP_Error(
					'puc_no_response_code',
					'wp_remote_get() returned an unexpected result.'
				);
			}

			if ( $result['response']['code'] !== 200 ) {
				return new WP_Error(
					'puc_unexpected_response_code',
					'HTTP response code is ' . $result['response']['code'] . ' (expected: 200)'
				);
			}

			if ( empty($result['body']) ) {
				return new WP_Error('puc_empty_response', 'The metadata file appears to be empty.');
			}

			return true;
		}

		/* -------------------------------------------------------------------
		 * Language packs / Translation updates
		 * -------------------------------------------------------------------
		 */

		/**
		 * Filter a list of translation updates and return a new list that contains only updates
		 * that apply to the current site.
		 *
		 * @param array $translations
		 * @return array
		 */
		protected function filterApplicableTranslations($translations) {
			$languages = array_flip(array_values(get_available_languages()));
			$installedTranslations = $this->getInstalledTranslations();

			$applicableTranslations = array();
			foreach ($translations as $translation) {
				//Does it match one of the available core languages?
				$isApplicable = array_key_exists($translation->language, $languages);
				//Is it more recent than an already-installed translation?
				if ( isset($installedTranslations[$translation->language]) ) {
					$updateTimestamp = strtotime($translation->updated);
					$installedTimestamp = strtotime($installedTranslations[$translation->language]['PO-Revision-Date']);
					$isApplicable = $updateTimestamp > $installedTimestamp;
				}

				if ( $isApplicable ) {
					$applicableTranslations[] = $translation;
				}
			}

			return $applicableTranslations;
		}

		/**
		 * Get a list of installed translations for this plugin or theme.
		 *
		 * @return array
		 */
		protected function getInstalledTranslations() {
			if ( !function_exists('wp_get_installed_translations') ) {
				return array();
			}
			$installedTranslations = wp_get_installed_translations($this->translationType . 's');
			if ( isset($installedTranslations[$this->directoryName]) ) {
				$installedTranslations = $installedTranslations[$this->directoryName];
			} else {
				$installedTranslations = array();
			}
			return $installedTranslations;
		}

		/**
		 * Insert translation updates into the list maintained by WordPress.
		 *
		 * @param stdClass $updates
		 * @return stdClass
		 */
		public function injectTranslationUpdates($updates) {
			$translationUpdates = $this->getTranslationUpdates();
			if ( empty($translationUpdates) ) {
				return $updates;
			}

			//Being defensive.
			if ( !is_object($updates) ) {
				$updates = new stdClass();
			}
			if ( !isset($updates->translations) ) {
				$updates->translations = array();
			}

			//In case there's a name collision with a plugin or theme hosted on wordpress.org,
			//remove any preexisting updates that match our thing.
			$updates->translations = array_values(array_filter(
				$updates->translations,
				array($this, 'isNotMyTranslation')
			));

			//Add our updates to the list.
			foreach($translationUpdates as $update) {
				$convertedUpdate = array_merge(
					array(
						'type' => $this->translationType,
						'slug' => $this->directoryName,
						'autoupdate' => 0,
						//AFAICT, WordPress doesn't actually use the "version" field for anything.
						//But lets make sure it's there, just in case.
						'version' => isset($update->version) ? $update->version : ('1.' . strtotime($update->updated)),
					),
					(array)$update
				);

				$updates->translations[] = $convertedUpdate;
			}

			return $updates;
		}

		/**
		 * Get a list of available translation updates.
		 *
		 * This method will return an empty array if there are no updates.
		 * Uses cached update data.
		 *
		 * @return array
		 */
		public function getTranslationUpdates() {
			return $this->updateState->getTranslations();
		}

		/**
		 * Remove all cached translation updates.
		 *
		 * @see wp_clean_update_cache
		 */
		public function clearCachedTranslationUpdates() {
			$this->updateState->setTranslations(array());
		}

		/**
		 * Filter callback. Keeps only translations that *don't* match this plugin or theme.
		 *
		 * @param array $translation
		 * @return bool
		 */
		protected function isNotMyTranslation($translation) {
			$isMatch = isset($translation['type'], $translation['slug'])
				&& ($translation['type'] === $this->translationType)
				&& ($translation['slug'] === $this->directoryName);

			return !$isMatch;
		}

		/* -------------------------------------------------------------------
		 * Fix directory name when installing updates
		 * -------------------------------------------------------------------
		 */

		/**
		 * Rename the update directory to match the existing plugin/theme directory.
		 *
		 * When WordPress installs a plugin or theme update, it assumes that the ZIP file will contain
		 * exactly one directory, and that the directory name will be the same as the directory where
		 * the plugin or theme is currently installed.
		 *
		 * GitHub and other repositories provide ZIP downloads, but they often use directory names like
		 * "project-branch" or "project-tag-hash". We need to change the name to the actual plugin folder.
		 *
		 * This is a hook callback. Don't call it from a plugin.
		 *
		 * @access protected
		 *
		 * @param string $source The directory to copy to /wp-content/plugins or /wp-content/themes. Usually a subdirectory of $remoteSource.
		 * @param string $remoteSource WordPress has extracted the update to this directory.
		 * @param \WP_Upgrader $upgrader
		 * @return string|WP_Error
		 */
		public function fixDirectoryName($source, $remoteSource, $upgrader) {
			global $wp_filesystem;
			/** @var \WP_Filesystem_Base $wp_filesystem */

			//Basic sanity checks.
			if ( !isset($source, $remoteSource, $upgrader, $upgrader->skin, $wp_filesystem) ) {
				return $source;
			}

			//If WordPress is upgrading anything other than our plugin/theme, leave the directory name unchanged.
			if ( !$this->isBeingUpgraded($upgrader) ) {
				return $source;
			}

			//Fix the remote source structure if necessary.
			//The update archive should contain a single directory that contains the rest of plugin/theme files.
			//Otherwise, WordPress will try to copy the entire working directory ($source == $remoteSource).
			//We can't rename $remoteSource because that would break WordPress code that cleans up temporary files
			//after update.
			if ( $this->isBadDirectoryStructure($remoteSource) ) {
				//Create a new directory using the plugin slug.
				$newDirectory = trailingslashit($remoteSource) . $this->slug . '/';

				if ( !$wp_filesystem->is_dir($newDirectory) ) {
					$wp_filesystem->mkdir($newDirectory);

					//Move all files to the newly created directory.
					$sourceFiles = $wp_filesystem->dirlist($remoteSource);
					if ( is_array($sourceFiles) ) {
						$sourceFiles = array_keys($sourceFiles);
						$allMoved = true;
						foreach ($sourceFiles as $filename) {
							//Skip our newly created folder.
							if ( $filename === $this->slug ) {
								continue;
							}

							$previousSource = trailingslashit($remoteSource) . $filename;
							$newSource = trailingslashit($newDirectory) . $filename;

							if ( !$wp_filesystem->move($previousSource, $newSource, true) ) {
								$allMoved = false;
								break;
							}
						}

						if ( $allMoved ) {
							//Rename source.
							$source = $newDirectory;
						} else {
							//Delete our newly created folder including all files in it.
							$wp_filesystem->rmdir($newDirectory, true);

							//And return a relevant error.
							return new WP_Error(
								'puc-incorrect-directory-structure',
								sprintf(
									'The directory structure of the update was incorrect. All files should be inside ' .
									'a directory named <span class="code">%s</span>, not at the root of the ZIP archive. Plugin Update Checker tried to fix the directory structure, but failed.',
									esc_html($this->slug)
								)
							);
						}
					}
				}
			}

			//Rename the source to match the existing directory.
			$correctedSource = trailingslashit($remoteSource) . $this->directoryName . '/';
			if ( $source !== $correctedSource ) {
				$upgrader->skin->feedback(sprintf(
					'Renaming %s to %s&#8230;',
					'<span class="code">' . basename($source) . '</span>',
					'<span class="code">' . $this->directoryName . '</span>'
				));

				if ( $wp_filesystem->move($source, $correctedSource, true) ) {
					$upgrader->skin->feedback('Directory successfully renamed.');
					return $correctedSource;
				} else {
					return new WP_Error(
						'puc-rename-failed',
						'Unable to rename the update to match the existing directory.'
					);
				}
			}

			return $source;
		}

		/**
		 * Is there an update being installed right now, for this plugin or theme?
		 *
		 * @param \WP_Upgrader|null $upgrader The upgrader that's performing the current update.
		 * @return bool
		 */
		abstract public function isBeingUpgraded($upgrader = null);

		/**
		 * Check for incorrect update directory structure. An update must contain a single directory,
		 * all other files should be inside that directory.
		 *
		 * @param string $remoteSource Directory path.
		 * @return bool
		 */
		protected function isBadDirectoryStructure($remoteSource) {
			global $wp_filesystem;
			/** @var \WP_Filesystem_Base $wp_filesystem */

			$sourceFiles = $wp_filesystem->dirlist($remoteSource);
			if ( is_array($sourceFiles) ) {
				$sourceFiles = array_keys($sourceFiles);
				$firstFilePath = trailingslashit($remoteSource) . $sourceFiles[0];
				return (count($sourceFiles) > 1) || (!$wp_filesystem->is_dir($firstFilePath));
			}

			//Assume it's fine.
			return false;
		}

		/* -------------------------------------------------------------------
		 * DebugBar integration
		 * -------------------------------------------------------------------
		 */

		/**
		 * Initialize the update checker Debug Bar plugin/add-on thingy.
		 */
		public function maybeInitDebugBar() {
			if (
				class_exists('Debug_Bar', false)
				&& class_exists('Debug_Bar_Panel', false)
				&& file_exists(dirname(__FILE__) . '/DebugBar')
			) {
				$this->debugBarExtension = $this->createDebugBarExtension();
			}
		}

		protected function createDebugBarExtension() {
			return new DebugBar\Extension($this);
		}

		/**
		 * Display additional configuration details in the Debug Bar panel.
		 *
		 * @param DebugBar\Panel $panel
		 */
		public function onDisplayConfiguration($panel) {
			//Do nothing. Subclasses can use this to add additional info to the panel.
		}

	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\UpgraderStatus.php (7248 bytes, 201 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(UpgraderStatus::class, false) ):

	/**
	 * A utility class that helps figure out which plugin or theme WordPress is upgrading.
	 *
	 * It may seem strange to have a separate class just for that, but the task is surprisingly complicated.
	 * Core classes like Plugin_Upgrader don't expose the plugin file name during an in-progress update (AFAICT).
	 * This class uses a few workarounds and heuristics to get the file name.
	 */
	class UpgraderStatus {
		private $currentType = null; //This must be either "plugin" or "theme".
		private $currentId = null;   //Plugin basename or theme directory name.

		public function __construct() {
			//Keep track of which plugin/theme WordPress is currently upgrading.
			add_filter('upgrader_pre_install', array($this, 'setUpgradedThing'), 10, 2);
			add_filter('upgrader_package_options', array($this, 'setUpgradedPluginFromOptions'), 10, 1);
			add_filter('upgrader_post_install', array($this, 'clearUpgradedThing'), 10, 1);
			add_action('upgrader_process_complete', array($this, 'clearUpgradedThing'), 10, 1);
		}

		/**
		 * Is there and update being installed RIGHT NOW, for a specific plugin?
		 *
		 * Caution: This method is unreliable. WordPress doesn't make it easy to figure out what it is upgrading,
		 * and upgrader implementations are liable to change without notice.
		 *
		 * @param string $pluginFile The plugin to check.
		 * @param \WP_Upgrader|null $upgrader The upgrader that's performing the current update.
		 * @return bool True if the plugin identified by $pluginFile is being upgraded.
		 */
		public function isPluginBeingUpgraded($pluginFile, $upgrader = null) {
			return $this->isBeingUpgraded('plugin', $pluginFile, $upgrader);
		}

		/**
		 * Is there an update being installed for a specific theme?
		 *
		 * @param string $stylesheet Theme directory name.
		 * @param \WP_Upgrader|null $upgrader The upgrader that's performing the current update.
		 * @return bool
		 */
		public function isThemeBeingUpgraded($stylesheet, $upgrader = null) {
			return $this->isBeingUpgraded('theme', $stylesheet, $upgrader);
		}

		/**
		 * Check if a specific theme or plugin is being upgraded.
		 *
		 * @param string $type
		 * @param string $id
		 * @param \Plugin_Upgrader|\WP_Upgrader|null $upgrader
		 * @return bool
		 */
		protected function isBeingUpgraded($type, $id, $upgrader = null) {
			if ( isset($upgrader) ) {
				list($currentType, $currentId) = $this->getThingBeingUpgradedBy($upgrader);
				if ( $currentType !== null ) {
					$this->currentType = $currentType;
					$this->currentId = $currentId;
				}
			}
			return ($this->currentType === $type) && ($this->currentId === $id);
		}

		/**
		 * Figure out which theme or plugin is being upgraded by a WP_Upgrader instance.
		 *
		 * Returns an array with two items. The first item is the type of the thing that's being
		 * upgraded: "plugin" or "theme". The second item is either the plugin basename or
		 * the theme directory name. If we can't determine what the upgrader is doing, both items
		 * will be NULL.
		 *
		 * Examples:
		 *      ['plugin', 'plugin-dir-name/plugin.php']
		 *      ['theme', 'theme-dir-name']
		 *
		 * @param \Plugin_Upgrader|\WP_Upgrader $upgrader
		 * @return array
		 */
		private function getThingBeingUpgradedBy($upgrader) {
			if ( !isset($upgrader, $upgrader->skin) ) {
				return array(null, null);
			}

			//Figure out which plugin or theme is being upgraded.
			$pluginFile = null;
			$themeDirectoryName = null;

			$skin = $upgrader->skin;
			if ( isset($skin->theme_info) && ($skin->theme_info instanceof \WP_Theme) ) {
				$themeDirectoryName = $skin->theme_info->get_stylesheet();
			} elseif ( $skin instanceof \Plugin_Upgrader_Skin ) {
				if ( isset($skin->plugin) && is_string($skin->plugin) && ($skin->plugin !== '') ) {
					$pluginFile = $skin->plugin;
				}
			} elseif ( $skin instanceof \Theme_Upgrader_Skin ) {
				if ( isset($skin->theme) && is_string($skin->theme) && ($skin->theme !== '') ) {
					$themeDirectoryName = $skin->theme;
				}
			} elseif ( isset($skin->plugin_info) && is_array($skin->plugin_info) ) {
				//This case is tricky because Bulk_Plugin_Upgrader_Skin (etc) doesn't actually store the plugin
				//filename anywhere. Instead, it has the plugin headers in $plugin_info. So the best we can
				//do is compare those headers to the headers of installed plugins.
				$pluginFile = $this->identifyPluginByHeaders($skin->plugin_info);
			}

			if ( $pluginFile !== null ) {
				return array('plugin', $pluginFile);
			} elseif ( $themeDirectoryName !== null ) {
				return array('theme', $themeDirectoryName);
			}
			return array(null, null);
		}

		/**
		 * Identify an installed plugin based on its headers.
		 *
		 * @param array $searchHeaders The plugin file header to look for.
		 * @return string|null Plugin basename ("foo/bar.php"), or NULL if we can't identify the plugin.
		 */
		private function identifyPluginByHeaders($searchHeaders) {
			if ( !function_exists('get_plugins') ){
				require_once( ABSPATH . '/wp-admin/includes/plugin.php' );
			}

			$installedPlugins = get_plugins();
			$matches = array();
			foreach($installedPlugins as $pluginBasename => $headers) {
				$diff1 = array_diff_assoc($headers, $searchHeaders);
				$diff2 = array_diff_assoc($searchHeaders, $headers);
				if ( empty($diff1) && empty($diff2) ) {
					$matches[] = $pluginBasename;
				}
			}

			//It's possible (though very unlikely) that there could be two plugins with identical
			//headers. In that case, we can't unambiguously identify the plugin that's being upgraded.
			if ( count($matches) !== 1 ) {
				return null;
			}

			return reset($matches);
		}

		/**
		 * @access private
		 *
		 * @param mixed $input
		 * @param array $hookExtra
		 * @return mixed Returns $input unaltered.
		 */
		public function setUpgradedThing($input, $hookExtra) {
			if ( !empty($hookExtra['plugin']) && is_string($hookExtra['plugin']) ) {
				$this->currentId = $hookExtra['plugin'];
				$this->currentType = 'plugin';
			} elseif ( !empty($hookExtra['theme']) && is_string($hookExtra['theme']) ) {
				$this->currentId = $hookExtra['theme'];
				$this->currentType = 'theme';
			} else {
				$this->currentType = null;
				$this->currentId = null;
			}
			return $input;
		}

		/**
		 * @access private
		 *
		 * @param array $options
		 * @return array
		 */
		public function setUpgradedPluginFromOptions($options) {
			if ( isset($options['hook_extra']['plugin']) && is_string($options['hook_extra']['plugin']) ) {
				$this->currentType = 'plugin';
				$this->currentId = $options['hook_extra']['plugin'];
			} else {
				$this->currentType = null;
				$this->currentId = null;
			}
			return $options;
		}

		/**
		 * @access private
		 *
		 * @param mixed $input
		 * @return mixed Returns $input unaltered.
		 */
		public function clearUpgradedThing($input = null) {
			$this->currentId = null;
			$this->currentType = null;
			return $input;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Utils.php (1965 bytes, 71 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6;

if ( !class_exists(Utils::class, false) ):

	class Utils {
		/**
		 * Get a value from a nested array or object based on a path.
		 *
		 * @param array|object|null $collection Get an entry from this array.
		 * @param array|string $path A list of array keys in hierarchy order, or a string path like "foo.bar.baz".
		 * @param mixed $default The value to return if the specified path is not found.
		 * @param string $separator Path element separator. Only applies to string paths.
		 * @return mixed
		 */
		public static function get($collection, $path, $default = null, $separator = '.') {
			if ( is_string($path) ) {
				$path = explode($separator, $path);
			}

			//Follow the $path into $input as far as possible.
			$currentValue = $collection;
			foreach ($path as $node) {
				if ( is_array($currentValue) && isset($currentValue[$node]) ) {
					$currentValue = $currentValue[$node];
				} else if ( is_object($currentValue) && isset($currentValue->$node) ) {
					$currentValue = $currentValue->$node;
				} else {
					return $default;
				}
			}

			return $currentValue;
		}

		/**
		 * Get the first array element that is not empty.
		 *
		 * @param array $values
		 * @param mixed|null $default Returns this value if there are no non-empty elements.
		 * @return mixed|null
		 */
		public static function findNotEmpty($values, $default = null) {
			if ( empty($values) ) {
				return $default;
			}

			foreach ($values as $value) {
				if ( !empty($value) ) {
					return $value;
				}
			}

			return $default;
		}

		/**
		 * Check if the input string starts with the specified prefix.
		 *
		 * @param string $input
		 * @param string $prefix
		 * @return bool
		 */
		public static function startsWith($input, $prefix) {
			$length = strlen($prefix);
			return (substr($input, 0, $length) === $prefix);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\WpCliCheckTrigger.php (2667 bytes, 84 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6;

use WP_CLI;

/**
 * Triggers an update check when relevant WP-CLI commands are executed.
 *
 * When WP-CLI runs certain commands like "wp plugin status" or "wp theme list", it calls
 * wp_update_plugins() and wp_update_themes() to refresh update information. This class hooks into
 * the same commands and triggers an update check when they are executed.
 *
 * Note that wp_update_plugins() and wp_update_themes() do not perform an update check *every* time
 * they are called. They use a context-dependent delay between update checks. Similarly, this class
 * calls Scheduler::maybeCheckForUpdates(), which also dynamically decides whether to actually
 * run a check. If you want to force an update check, call UpdateChecker::checkForUpdates() instead.
 */
class WpCliCheckTrigger {
	/**
	 * @var Scheduler
	 */
	private $scheduler;

	/**
	 * @var string 'plugin' or 'theme'
	 */
	private $componentType;

	/**
	 * @var bool Whether an update check was already triggered during the current request
	 *           or script execution.
	 */
	private $wasCheckTriggered = false;

	public function __construct($componentType, Scheduler $scheduler) {
		if ( !in_array($componentType, ['plugin', 'theme']) ) {
			throw new \InvalidArgumentException('Invalid component type. Must be "plugin" or "theme".');
		}

		$this->componentType = $componentType;
		$this->scheduler = $scheduler;

		if ( !defined('WP_CLI') || !class_exists(WP_CLI::class, false) ) {
			return; //Nothing to do if WP-CLI is not available.
		}

		/*
		 * We can't hook directly into wp_update_plugins(), but we can hook into the WP-CLI
		 * commands that call it. We'll use the "before_invoke:xyz" hook to trigger update checks.
		 */
		foreach ($this->getRelevantCommands() as $command) {
			WP_CLI::add_hook('before_invoke:' . $command, [$this, 'triggerUpdateCheckOnce']);
		}
	}

	private function getRelevantCommands() {
		$result = [];
		foreach (['status', 'list', 'update'] as $subcommand) {
			$result[] = $this->componentType . ' ' . $subcommand;
		}
		return $result;
	}

	/**
	 * Trigger a potential update check once.
	 *
	 * @param mixed $input
	 * @return mixed The input value, unchanged.
	 * @internal This method is public so that it can be used as a WP-CLI hook callback.
	 *           It should not be called directly.
	 *
	 */
	public function triggerUpdateCheckOnce($input = null) {
		if ( $this->wasCheckTriggered ) {
			return $input;
		}

		$this->wasCheckTriggered = true;
		$this->scheduler->maybeCheckForUpdates();

		return $input;
	}
}
`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\DebugBar\Extension.php (6670 bytes, 200 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

use YahnisElsts\PluginUpdateChecker\v5p6\PucFactory;
use YahnisElsts\PluginUpdateChecker\v5p6\UpdateChecker;

if ( !class_exists(Extension::class, false) ):

	class Extension {
		const RESPONSE_BODY_LENGTH_LIMIT = 4000;

		/** @var UpdateChecker */
		protected $updateChecker;
		protected $panelClass = Panel::class;

		public function __construct($updateChecker, $panelClass = null) {
			$this->updateChecker = $updateChecker;
			if ( isset($panelClass) ) {
				$this->panelClass = $panelClass;
			}

			if ( (strpos($this->panelClass, '\\') === false) ) {
				$this->panelClass = __NAMESPACE__ . '\\' . $this->panelClass;
			}

			add_filter('debug_bar_panels', array($this, 'addDebugBarPanel'));
			add_action('debug_bar_enqueue_scripts', array($this, 'enqueuePanelDependencies'));

			add_action('wp_ajax_puc_v5_debug_check_now', array($this, 'ajaxCheckNow'));
		}

		/**
		 * Register the PUC Debug Bar panel.
		 *
		 * @param array $panels
		 * @return array
		 */
		public function addDebugBarPanel($panels) {
			if ( $this->updateChecker->userCanInstallUpdates() ) {
				$panels[] = new $this->panelClass($this->updateChecker);
			}
			return $panels;
		}

		/**
		 * Enqueue our Debug Bar scripts and styles.
		 */
		public function enqueuePanelDependencies() {
			wp_enqueue_style(
				'puc-debug-bar-style-v5',
				$this->getLibraryUrl("/css/puc-debug-bar.css"),
				array('debug-bar'),
				'20221008'
			);

			wp_enqueue_script(
				'puc-debug-bar-js-v5',
				$this->getLibraryUrl("/js/debug-bar.js"),
				array('jquery'),
				'20221008'
			);
		}

		/**
		 * Run an update check and output the result. Useful for making sure that
		 * the update checking process works as expected.
		 */
		public function ajaxCheckNow() {
			//phpcs:ignore WordPress.Security.NonceVerification.Missing -- Nonce is checked in preAjaxRequest().
			if ( !isset($_POST['uid']) || ($_POST['uid'] !== $this->updateChecker->getUniqueName('uid')) ) {
				return;
			}
			$this->preAjaxRequest();
			$update = $this->updateChecker->checkForUpdates();
			if ( $update !== null ) {
				echo "An update is available:";
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_print_r -- For debugging output.
				echo '<pre>', esc_html(print_r($update, true)), '</pre>';
			} else {
				echo 'No updates found.';
			}

			$errors = $this->updateChecker->getLastRequestApiErrors();
			if ( !empty($errors) ) {
				printf('<p>The update checker encountered %d API error%s.</p>', count($errors), (count($errors) > 1) ? 's' : '');

				foreach (array_values($errors) as $num => $item) {
					$wpError = $item['error'];
					/** @var \WP_Error $wpError */
					printf('<h4>%d) %s</h4>', intval($num + 1), esc_html($wpError->get_error_message()));

					echo '<dl>';
					printf('<dt>Error code:</dt><dd><code>%s</code></dd>', esc_html($wpError->get_error_code()));

					if ( isset($item['url']) ) {
						printf('<dt>Requested URL:</dt><dd><code>%s</code></dd>', esc_html($item['url']));
					}

					if ( isset($item['httpResponse']) ) {
						if ( is_wp_error($item['httpResponse']) ) {
							$httpError = $item['httpResponse'];
							/** @var \WP_Error $httpError */
							printf(
								'<dt>WordPress HTTP API error:</dt><dd>%s (<code>%s</code>)</dd>',
								esc_html($httpError->get_error_message()),
								esc_html($httpError->get_error_code())
							);
						} else {
							//Status code.
							printf(
								'<dt>HTTP status:</dt><dd><code>%d %s</code></dd>',
								esc_html(wp_remote_retrieve_response_code($item['httpResponse'])),
								esc_html(wp_remote_retrieve_response_message($item['httpResponse']))
							);

							//Headers.
							echo '<dt>Response headers:</dt><dd><pre>';
							foreach (wp_remote_retrieve_headers($item['httpResponse']) as $name => $value) {
								printf("%s: %s\n", esc_html($name), esc_html($value));
							}
							echo '</pre></dd>';

							//Body.
							$body = wp_remote_retrieve_body($item['httpResponse']);
							if ( $body === '' ) {
								$body = '(Empty response.)';
							} else if ( strlen($body) > self::RESPONSE_BODY_LENGTH_LIMIT ) {
								$length = strlen($body);
								$body = substr($body, 0, self::RESPONSE_BODY_LENGTH_LIMIT)
									. sprintf("\n(Long string truncated. Total length: %d bytes.)", $length);
							}

							printf('<dt>Response body:</dt><dd><pre>%s</pre></dd>', esc_html($body));
						}
					}
					echo '<dl>';
				}
			}

			exit;
		}

		/**
		 * Check access permissions and enable error display (for debugging).
		 */
		protected function preAjaxRequest() {
			if ( !$this->updateChecker->userCanInstallUpdates() ) {
				die('Access denied');
			}
			check_ajax_referer('puc-ajax');

			//phpcs:ignore WordPress.PHP.DiscouragedPHPFunctions.runtime_configuration_error_reporting -- Part of a debugging feature.
			error_reporting(E_ALL);
			//phpcs:ignore WordPress.PHP.IniSet.display_errors_Blacklisted
			@ini_set('display_errors', 'On');
		}

		/**
		 * Remove hooks that were added by this extension.
		 */
		public function removeHooks() {
			remove_filter('debug_bar_panels', array($this, 'addDebugBarPanel'));
			remove_action('debug_bar_enqueue_scripts', array($this, 'enqueuePanelDependencies'));
			remove_action('wp_ajax_puc_v5_debug_check_now', array($this, 'ajaxCheckNow'));
		}

		/**
		 * @param string $filePath
		 * @return string
		 */
		private function getLibraryUrl($filePath) {
			$absolutePath = realpath(dirname(__FILE__) . '/../../../' . ltrim($filePath, '/'));

			//Where is the library located inside the WordPress directory structure?
			$absolutePath = PucFactory::normalizePath($absolutePath);

			$pluginDir = PucFactory::normalizePath(WP_PLUGIN_DIR);
			$muPluginDir = PucFactory::normalizePath(WPMU_PLUGIN_DIR);
			$themeDir = PucFactory::normalizePath(get_theme_root());

			if ( (strpos($absolutePath, $pluginDir) === 0) || (strpos($absolutePath, $muPluginDir) === 0) ) {
				//It's part of a plugin.
				return plugins_url(basename($absolutePath), $absolutePath);
			} else if ( strpos($absolutePath, $themeDir) === 0 ) {
				//It's part of a theme.
				$relativePath = substr($absolutePath, strlen($themeDir) + 1);
				$template = substr($relativePath, 0, strpos($relativePath, '/'));
				$baseUrl = get_theme_root_uri($template);

				if ( !empty($baseUrl) && $relativePath ) {
					return $baseUrl . '/' . $relativePath;
				}
			}

			return '';
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\DebugBar\Panel.php (6053 bytes, 187 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

use YahnisElsts\PluginUpdateChecker\v5p6\UpdateChecker;

if ( !class_exists(Panel::class, false) && class_exists('Debug_Bar_Panel', false) ):

	class Panel extends \Debug_Bar_Panel {
		/** @var UpdateChecker */
		protected $updateChecker;

		private $responseBox = '<div class="puc-ajax-response" style="display: none;"></div>';

		public function __construct($updateChecker) {
			$this->updateChecker = $updateChecker;
			$title = sprintf(
				'<span class="puc-debug-menu-link-%s">PUC (%s)</span>',
				esc_attr($this->updateChecker->getUniqueName('uid')),
				$this->updateChecker->slug
			);
			parent::__construct($title);
		}

		public function render() {
			printf(
				'<div class="puc-debug-bar-panel-v5" id="%1$s" data-slug="%2$s" data-uid="%3$s" data-nonce="%4$s">',
				esc_attr($this->updateChecker->getUniqueName('debug-bar-panel')),
				esc_attr($this->updateChecker->slug),
				esc_attr($this->updateChecker->getUniqueName('uid')),
				esc_attr(wp_create_nonce('puc-ajax'))
			);

			$this->displayConfiguration();
			$this->displayStatus();
			$this->displayCurrentUpdate();

			echo '</div>';
		}

		private function displayConfiguration() {
			echo '<h3>Configuration</h3>';
			echo '<table class="puc-debug-data">';
			$this->displayConfigHeader();
			$this->row('Slug', esc_html($this->updateChecker->slug));
			$this->row('DB option', esc_html($this->updateChecker->optionName));

			$requestInfoButton = $this->getMetadataButton();
			$this->row('Metadata URL', esc_html($this->updateChecker->metadataUrl) . ' ' . $requestInfoButton . $this->responseBox);

			$scheduler = $this->updateChecker->scheduler;
			if ( $scheduler->checkPeriod > 0 ) {
				$this->row('Automatic checks', 'Every ' . $scheduler->checkPeriod . ' hours');
			} else {
				$this->row('Automatic checks', 'Disabled');
			}

			if ( isset($scheduler->throttleRedundantChecks) ) {
				if ( $scheduler->throttleRedundantChecks && ($scheduler->checkPeriod > 0) ) {
					$this->row(
						'Throttling',
						sprintf(
							'Enabled. If an update is already available, check for updates every %1$d hours instead of every %2$d hours.',
							$scheduler->throttledCheckPeriod,
							$scheduler->checkPeriod
						)
					);
				} else {
					$this->row('Throttling', 'Disabled');
				}
			}

			$this->updateChecker->onDisplayConfiguration($this);

			echo '</table>';
		}

		protected function displayConfigHeader() {
			//Do nothing. This should be implemented in subclasses.
		}

		protected function getMetadataButton() {
			return '';
		}

		private function displayStatus() {
			echo '<h3>Status</h3>';
			echo '<table class="puc-debug-data">';
			$state = $this->updateChecker->getUpdateState();
			$checkButtonId = $this->updateChecker->getUniqueName('check-now-button');
			if ( function_exists('get_submit_button')  ) {
				$checkNowButton = get_submit_button(
					'Check Now',
					'secondary',
					'puc-check-now-button',
					false,
					array('id' => $checkButtonId)
				);
			} else {
				//get_submit_button() is not available in the frontend. Make a button directly.
				//It won't look the same without admin styles, but it should still work.
				$checkNowButton = sprintf(
					'<input type="button" id="%1$s" name="puc-check-now-button" value="%2$s" class="button button-secondary" />',
					esc_attr($checkButtonId),
					esc_attr('Check Now')
				);
			}

			if ( $state->getLastCheck() > 0 ) {
				$this->row('Last check', $this->formatTimeWithDelta($state->getLastCheck()) . ' ' . $checkNowButton . $this->responseBox);
			} else {
				$this->row('Last check', 'Never');
			}

			$nextCheck = wp_next_scheduled($this->updateChecker->scheduler->getCronHookName());
			$this->row('Next automatic check', $this->formatTimeWithDelta($nextCheck));

			if ( $state->getCheckedVersion() !== '' ) {
				$this->row('Checked version', esc_html($state->getCheckedVersion()));
				$this->row('Cached update', $state->getUpdate());
			}
			$this->row('Update checker class', esc_html(get_class($this->updateChecker)));
			echo '</table>';
		}

		private function displayCurrentUpdate() {
			$update = $this->updateChecker->getUpdate();
			if ( $update !== null ) {
				echo '<h3>An Update Is Available</h3>';
				echo '<table class="puc-debug-data">';
				$fields = $this->getUpdateFields();
				foreach($fields as $field) {
					if ( property_exists($update, $field) ) {
						$this->row(
							ucwords(str_replace('_', ' ', $field)),
							isset($update->$field) ? esc_html($update->$field) : null
						);
					}
				}
				echo '</table>';
			} else {
				echo '<h3>No updates currently available</h3>';
			}
		}

		protected function getUpdateFields() {
			return array('version', 'download_url', 'slug',);
		}

		private function formatTimeWithDelta($unixTime) {
			if ( empty($unixTime) ) {
				return 'Never';
			}

			$delta = time() - $unixTime;
			$result = human_time_diff(time(), $unixTime);
			if ( $delta < 0 ) {
				$result = 'after ' . $result;
			} else {
				$result = $result . ' ago';
			}
			$result .= ' (' . $this->formatTimestamp($unixTime) . ')';
			return $result;
		}

		private function formatTimestamp($unixTime) {
			return gmdate('Y-m-d H:i:s', $unixTime + (get_option('gmt_offset') * 3600));
		}

		public function row($name, $value) {
			if ( is_object($value) || is_array($value) ) {
				//This is specifically for debugging, so print_r() is fine.
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_print_r
				$value = '<pre>' . esc_html(print_r($value, true)) . '</pre>';
			} else if ($value === null) {
				$value = '<code>null</code>';
			}
			printf(
				'<tr><th scope="row">%1$s</th> <td>%2$s</td></tr>',
				esc_html($name),
				//phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- Escaped above.
				$value
			);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\DebugBar\PluginExtension.php (1270 bytes, 41 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

use YahnisElsts\PluginUpdateChecker\v5p6\Plugin\UpdateChecker;

if ( !class_exists(PluginExtension::class, false) ):

	class PluginExtension extends Extension {
		/** @var UpdateChecker */
		protected $updateChecker;

		public function __construct($updateChecker) {
			parent::__construct($updateChecker, PluginPanel::class);

			add_action('wp_ajax_puc_v5_debug_request_info', array($this, 'ajaxRequestInfo'));
		}

		/**
		 * Request plugin info and output it.
		 */
		public function ajaxRequestInfo() {
			//phpcs:ignore WordPress.Security.NonceVerification.Missing -- Nonce is checked in preAjaxRequest().
			if ( !isset($_POST['uid']) || ($_POST['uid'] !== $this->updateChecker->getUniqueName('uid')) ) {
				return;
			}
			$this->preAjaxRequest();
			$info = $this->updateChecker->requestInfo();
			if ( $info !== null ) {
				echo 'Successfully retrieved plugin info from the metadata URL:';
				//phpcs:ignore WordPress.PHP.DevelopmentFunctions.error_log_print_r -- For debugging output.
				echo '<pre>', esc_html(print_r($info, true)), '</pre>';
			} else {
				echo 'Failed to retrieve plugin info from the metadata URL.';
			}
			exit;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\DebugBar\PluginPanel.php (1248 bytes, 48 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

use YahnisElsts\PluginUpdateChecker\v5p6\Plugin\UpdateChecker;

if ( !class_exists(PluginPanel::class, false) ):

	class PluginPanel extends Panel {
		/**
		 * @var UpdateChecker
		 */
		protected $updateChecker;

		protected function displayConfigHeader() {
			$this->row('Plugin file', esc_html($this->updateChecker->pluginFile));
			parent::displayConfigHeader();
		}

		protected function getMetadataButton() {
			$buttonId = $this->updateChecker->getUniqueName('request-info-button');
			if ( function_exists('get_submit_button') ) {
				$requestInfoButton = get_submit_button(
					'Request Info',
					'secondary',
					'puc-request-info-button',
					false,
					array('id' => $buttonId)
				);
			} else {
				$requestInfoButton = sprintf(
					'<input type="button" name="puc-request-info-button" id="%1$s" value="%2$s" class="button button-secondary" />',
					esc_attr($buttonId),
					esc_attr('Request Info')
				);
			}
			return $requestInfoButton;
		}

		protected function getUpdateFields() {
			return array_merge(
				parent::getUpdateFields(),
				array('homepage', 'upgrade_notice', 'tested',)
			);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\DebugBar\ThemePanel.php (594 bytes, 26 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

use YahnisElsts\PluginUpdateChecker\v5p6\Theme\UpdateChecker;

if ( !class_exists(ThemePanel::class, false) ):

	class ThemePanel extends Panel {
		/**
		 * @var UpdateChecker
		 */
		protected $updateChecker;

		protected function displayConfigHeader() {
			$this->row('Theme directory', esc_html($this->updateChecker->directoryName));
			parent::displayConfigHeader();
		}

		protected function getUpdateFields() {
			return array_merge(parent::getUpdateFields(), array('details_url'));
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Plugin\Package.php (5735 bytes, 189 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Plugin;

use YahnisElsts\PluginUpdateChecker\v5p6\InstalledPackage;
use YahnisElsts\PluginUpdateChecker\v5p6\PucFactory;

if ( !class_exists(Package::class, false) ):

	class Package extends InstalledPackage {
		/**
		 * @var UpdateChecker
		 */
		protected $updateChecker;

		/**
		 * @var string Full path of the main plugin file.
		 */
		protected $pluginAbsolutePath = '';

		/**
		 * @var string Plugin basename.
		 */
		private $pluginFile;

		/**
		 * @var string|null
		 */
		private $cachedInstalledVersion = null;

		public function __construct($pluginAbsolutePath, $updateChecker) {
			$this->pluginAbsolutePath = $pluginAbsolutePath;
			$this->pluginFile = plugin_basename($this->pluginAbsolutePath);

			parent::__construct($updateChecker);

			//Clear the version number cache when something - anything - is upgraded or WP clears the update cache.
			add_filter('upgrader_post_install', array($this, 'clearCachedVersion'));
			add_action('delete_site_transient_update_plugins', array($this, 'clearCachedVersion'));
		}

		public function getInstalledVersion() {
			if ( isset($this->cachedInstalledVersion) ) {
				return $this->cachedInstalledVersion;
			}

			$pluginHeader = $this->getPluginHeader();
			if ( isset($pluginHeader['Version']) ) {
				$this->cachedInstalledVersion = $pluginHeader['Version'];
				return $pluginHeader['Version'];
			} else {
				//This can happen if the filename points to something that is not a plugin.
				$this->updateChecker->triggerError(
					sprintf(
						"Cannot read the Version header for '%s'. The filename is incorrect or is not a plugin.",
						$this->updateChecker->pluginFile
					),
					E_USER_WARNING
				);
				return null;
			}
		}

		/**
		 * Clear the cached plugin version. This method can be set up as a filter (hook) and will
		 * return the filter argument unmodified.
		 *
		 * @param mixed $filterArgument
		 * @return mixed
		 */
		public function clearCachedVersion($filterArgument = null) {
			$this->cachedInstalledVersion = null;
			return $filterArgument;
		}

		public function getAbsoluteDirectoryPath() {
			return dirname($this->pluginAbsolutePath);
		}

		/**
		 * Get the value of a specific plugin or theme header.
		 *
		 * @param string $headerName
		 * @param string $defaultValue
		 * @return string Either the value of the header, or $defaultValue if the header doesn't exist or is empty.
		 */
		public function getHeaderValue($headerName, $defaultValue = '') {
			$headers = $this->getPluginHeader();
			if ( isset($headers[$headerName]) && ($headers[$headerName] !== '') ) {
				return $headers[$headerName];
			}
			return $defaultValue;
		}

		protected function getHeaderNames() {
			return array(
				'Name'              => 'Plugin Name',
				'PluginURI'         => 'Plugin URI',
				'Version'           => 'Version',
				'Description'       => 'Description',
				'Author'            => 'Author',
				'AuthorURI'         => 'Author URI',
				'TextDomain'        => 'Text Domain',
				'DomainPath'        => 'Domain Path',
				'Network'           => 'Network',

				//The newest WordPress version that this plugin requires or has been tested with.
				//We support several different formats for compatibility with other libraries.
				'Tested WP'         => 'Tested WP',
				'Requires WP'       => 'Requires WP',
				'Tested up to'      => 'Tested up to',
				'Requires at least' => 'Requires at least',
			);
		}

		/**
		 * Get the translated plugin title.
		 *
		 * @return string
		 */
		public function getPluginTitle() {
			$title = '';
			$header = $this->getPluginHeader();
			if ( $header && !empty($header['Name']) && isset($header['TextDomain']) ) {
				$title = translate($header['Name'], $header['TextDomain']);
			}
			return $title;
		}

		/**
		 * Get plugin's metadata from its file header.
		 *
		 * @return array
		 */
		public function getPluginHeader() {
			if ( !is_file($this->pluginAbsolutePath) ) {
				//This can happen if the plugin filename is wrong.
				$this->updateChecker->triggerError(
					sprintf(
						"Can't to read the plugin header for '%s'. The file does not exist.",
						$this->updateChecker->pluginFile
					),
					E_USER_WARNING
				);
				return array();
			}

			if ( !function_exists('get_plugin_data') ) {
				require_once(ABSPATH . '/wp-admin/includes/plugin.php');
			}
			return get_plugin_data($this->pluginAbsolutePath, false, false);
		}

		public function removeHooks() {
			remove_filter('upgrader_post_install', array($this, 'clearCachedVersion'));
			remove_action('delete_site_transient_update_plugins', array($this, 'clearCachedVersion'));
		}

		/**
		 * Check if the plugin file is inside the mu-plugins directory.
		 *
		 * @return bool
		 */
		public function isMuPlugin() {
			static $cachedResult = null;

			if ( $cachedResult === null ) {
				if ( !defined('WPMU_PLUGIN_DIR') || !is_string(WPMU_PLUGIN_DIR) ) {
					$cachedResult = false;
					return $cachedResult;
				}

				//Convert both paths to the canonical form before comparison.
				$muPluginDir = realpath(WPMU_PLUGIN_DIR);
				$pluginPath  = realpath($this->pluginAbsolutePath);
				//If realpath() fails, just normalize the syntax instead.
				if (($muPluginDir === false) || ($pluginPath === false)) {
					$muPluginDir = PucFactory::normalizePath(WPMU_PLUGIN_DIR);
					$pluginPath  = PucFactory::normalizePath($this->pluginAbsolutePath);
				}

				$cachedResult = (strpos($pluginPath, $muPluginDir) === 0);
			}

			return $cachedResult;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Plugin\PluginInfo.php (3973 bytes, 137 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Plugin;

use YahnisElsts\PluginUpdateChecker\v5p6\Metadata;

if ( !class_exists(PluginInfo::class, false) ):

	/**
	 * A container class for holding and transforming various plugin metadata.
	 *
	 * @author Janis Elsts
	 * @copyright 2016
	 * @access public
	 */
	class PluginInfo extends Metadata {
		//Most fields map directly to the contents of the plugin's info.json file.
		//See the relevant docs for a description of their meaning.
		public $name;
		public $slug;
		public $version;
		public $homepage;
		public $sections = array();
		public $download_url;

		public $banners;
		public $icons = array();
		public $translations = array();

		public $author;
		public $author_homepage;

		public $requires;
		public $tested;
		public $requires_php;
		public $upgrade_notice;

		public $rating;
		public $num_ratings;
		public $downloaded;
		public $active_installs;
		public $last_updated;

		public $id = 0; //The native WP.org API returns numeric plugin IDs, but they're not used for anything.

		public $filename; //Plugin filename relative to the plugins directory.

		/**
		 * Create a new instance of Plugin Info from JSON-encoded plugin info
		 * returned by an external update API.
		 *
		 * @param string $json Valid JSON string representing plugin info.
		 * @return self|null New instance of Plugin Info, or NULL on error.
		 */
		public static function fromJson($json){
			$instance = new self();

			if ( !parent::createFromJson($json, $instance) ) {
				return null;
			}

			//json_decode decodes assoc. arrays as objects. We want them as arrays.
			$instance->sections = (array)$instance->sections;
			$instance->icons = (array)$instance->icons;

			return $instance;
		}

		/**
		 * Very, very basic validation.
		 *
		 * @param \StdClass $apiResponse
		 * @return bool|\WP_Error
		 */
		protected function validateMetadata($apiResponse) {
			if (
				!isset($apiResponse->name, $apiResponse->version)
				|| empty($apiResponse->name)
				|| empty($apiResponse->version)
			) {
				return new \WP_Error(
					'puc-invalid-metadata',
					"The plugin metadata file does not contain the required 'name' and/or 'version' keys."
				);
			}
			return true;
		}


		/**
		 * Transform plugin info into the format used by the native WordPress.org API
		 *
		 * @return object
		 */
		public function toWpFormat(){
			$info = new \stdClass;

			//The custom update API is built so that many fields have the same name and format
			//as those returned by the native WordPress.org API. These can be assigned directly.
			$sameFormat = array(
				'name', 'slug', 'version', 'requires', 'tested', 'rating', 'upgrade_notice',
				'num_ratings', 'downloaded', 'active_installs', 'homepage', 'last_updated',
				'requires_php',
			);
			foreach($sameFormat as $field){
				if ( isset($this->$field) ) {
					$info->$field = $this->$field;
				} else {
					$info->$field = null;
				}
			}

			//Other fields need to be renamed and/or transformed.
			$info->download_link = $this->download_url;
			$info->author = $this->getFormattedAuthor();
			$info->sections = array_merge(array('description' => ''), $this->sections);

			if ( !empty($this->banners) ) {
				//WP expects an array with two keys: "high" and "low". Both are optional.
				//Docs: https://wordpress.org/plugins/about/faq/#banners
				$info->banners = is_object($this->banners) ? get_object_vars($this->banners) : $this->banners;
				$info->banners = array_intersect_key($info->banners, array('high' => true, 'low' => true));
			}

			return $info;
		}

		protected function getFormattedAuthor() {
			if ( !empty($this->author_homepage) ){
				/** @noinspection HtmlUnknownTarget */
				return sprintf('<a href="%s">%s</a>', $this->author_homepage, $this->author);
			}
			return $this->author;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Plugin\Ui.php (10719 bytes, 295 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Plugin;

if ( !class_exists(Ui::class, false) ):
	/**
	 * Additional UI elements for plugins.
	 */
	class Ui {
		private $updateChecker;
		private $manualCheckErrorTransient = '';

		/**
		 * @param UpdateChecker $updateChecker
		 */
		public function __construct($updateChecker) {
			$this->updateChecker = $updateChecker;
			$this->manualCheckErrorTransient = $this->updateChecker->getUniqueName('manual_check_errors');

			add_action('admin_init', array($this, 'onAdminInit'));
		}

		public function onAdminInit() {
			if ( $this->updateChecker->userCanInstallUpdates() ) {
				$this->handleManualCheck();

				add_filter('plugin_row_meta', array($this, 'addViewDetailsLink'), 10, 3);
				add_filter('plugin_row_meta', array($this, 'addCheckForUpdatesLink'), 10, 2);
				add_action('all_admin_notices', array($this, 'displayManualCheckResult'));
			}
		}

		/**
		 * Add a "View Details" link to the plugin row in the "Plugins" page. By default,
		 * the new link will appear before the "Visit plugin site" link (if present).
		 *
		 * You can change the link text by using the "puc_view_details_link-$slug" filter.
		 * Returning an empty string from the filter will disable the link.
		 *
		 * You can change the position of the link using the
		 * "puc_view_details_link_position-$slug" filter.
		 * Returning 'before' or 'after' will place the link immediately before/after
		 * the "Visit plugin site" link.
		 * Returning 'append' places the link after any existing links at the time of the hook.
		 * Returning 'replace' replaces the "Visit plugin site" link.
		 * Returning anything else disables the link when there is a "Visit plugin site" link.
		 *
		 * If there is no "Visit plugin site" link 'append' is always used!
		 *
		 * @param array $pluginMeta Array of meta links.
		 * @param string $pluginFile
		 * @param array $pluginData Array of plugin header data.
		 * @return array
		 */
		public function addViewDetailsLink($pluginMeta, $pluginFile, $pluginData = array()) {
			if ( $this->isMyPluginFile($pluginFile) && !isset($pluginData['slug']) ) {
				$linkText = apply_filters($this->updateChecker->getUniqueName('view_details_link'), __('View details'));
				if ( !empty($linkText) ) {
					$viewDetailsLinkPosition = 'append';

					//Find the "Visit plugin site" link (if present).
					$visitPluginSiteLinkIndex = count($pluginMeta) - 1;
					if ( $pluginData['PluginURI'] ) {
						$escapedPluginUri = esc_url($pluginData['PluginURI']);
						foreach ($pluginMeta as $linkIndex => $existingLink) {
							if ( strpos($existingLink, $escapedPluginUri) !== false ) {
								$visitPluginSiteLinkIndex = $linkIndex;
								$viewDetailsLinkPosition = apply_filters(
									$this->updateChecker->getUniqueName('view_details_link_position'),
									'before'
								);
								break;
							}
						}
					}

					$viewDetailsLink = sprintf('<a href="%s" class="thickbox open-plugin-details-modal" aria-label="%s" data-title="%s">%s</a>',
						esc_url(network_admin_url('plugin-install.php?tab=plugin-information&plugin=' . urlencode($this->updateChecker->slug) .
							'&TB_iframe=true&width=600&height=550')),
						esc_attr(sprintf(__('More information about %s'), $pluginData['Name'])),
						esc_attr($pluginData['Name']),
						$linkText
					);
					switch ($viewDetailsLinkPosition) {
						case 'before':
							array_splice($pluginMeta, $visitPluginSiteLinkIndex, 0, $viewDetailsLink);
							break;
						case 'after':
							array_splice($pluginMeta, $visitPluginSiteLinkIndex + 1, 0, $viewDetailsLink);
							break;
						case 'replace':
							$pluginMeta[$visitPluginSiteLinkIndex] = $viewDetailsLink;
							break;
						case 'append':
						default:
							$pluginMeta[] = $viewDetailsLink;
							break;
					}
				}
			}
			return $pluginMeta;
		}

		/**
		 * Add a "Check for updates" link to the plugin row in the "Plugins" page. By default,
		 * the new link will appear after the "Visit plugin site" link if present, otherwise
		 * after the "View plugin details" link.
		 *
		 * You can change the link text by using the "puc_manual_check_link-$slug" filter.
		 * Returning an empty string from the filter will disable the link.
		 *
		 * @param array $pluginMeta Array of meta links.
		 * @param string $pluginFile
		 * @return array
		 */
		public function addCheckForUpdatesLink($pluginMeta, $pluginFile) {
			if ( $this->isMyPluginFile($pluginFile) ) {
				$linkUrl = wp_nonce_url(
					add_query_arg(
						array(
							'puc_check_for_updates' => 1,
							'puc_slug'              => $this->updateChecker->slug,
						),
						self_admin_url('plugins.php')
					),
					'puc_check_for_updates'
				);

				$linkText = apply_filters(
					$this->updateChecker->getUniqueName('manual_check_link'),
					__('Check for updates', 'plugin-update-checker')
				);
				if ( !empty($linkText) ) {
					/** @noinspection HtmlUnknownTarget */
					$pluginMeta[] = sprintf('<a href="%s">%s</a>', esc_attr($linkUrl), $linkText);
				}
			}
			return $pluginMeta;
		}

		protected function isMyPluginFile($pluginFile) {
			return ($pluginFile == $this->updateChecker->pluginFile)
				|| (!empty($this->updateChecker->muPluginFile) && ($pluginFile == $this->updateChecker->muPluginFile));
		}

		/**
		 * Check for updates when the user clicks the "Check for updates" link.
		 *
		 * @see self::addCheckForUpdatesLink()
		 *
		 * @return void
		 */
		public function handleManualCheck() {
			$shouldCheck =
				isset($_GET['puc_check_for_updates'], $_GET['puc_slug'])
				&& $_GET['puc_slug'] == $this->updateChecker->slug
				&& check_admin_referer('puc_check_for_updates');

			if ( $shouldCheck ) {
				$update = $this->updateChecker->checkForUpdates();
				$status = ($update === null) ? 'no_update' : 'update_available';
				$lastRequestApiErrors = $this->updateChecker->getLastRequestApiErrors();

				if ( ($update === null) && !empty($lastRequestApiErrors) ) {
					//Some errors are not critical. For example, if PUC tries to retrieve the readme.txt
					//file from GitHub and gets a 404, that's an API error, but it doesn't prevent updates
					//from working. Maybe the plugin simply doesn't have a readme.
					//Let's only show important errors.
					$foundCriticalErrors = false;
					$questionableErrorCodes = array(
						'puc-github-http-error',
						'puc-gitlab-http-error',
						'puc-bitbucket-http-error',
					);

					foreach ($lastRequestApiErrors as $item) {
						$wpError = $item['error'];
						/** @var \WP_Error $wpError */
						if ( !in_array($wpError->get_error_code(), $questionableErrorCodes) ) {
							$foundCriticalErrors = true;
							break;
						}
					}

					if ( $foundCriticalErrors ) {
						$status = 'error';
						set_site_transient($this->manualCheckErrorTransient, $lastRequestApiErrors, 60);
					}
				}

				wp_safe_redirect(add_query_arg(
					array(
						'puc_update_check_result' => $status,
						'puc_slug'                => $this->updateChecker->slug,
					),
					self_admin_url('plugins.php')
				));
				exit;
			}
		}

		/**
		 * Display the results of a manual update check.
		 *
		 * @see self::handleManualCheck()
		 *
		 * You can change the result message by using the "puc_manual_check_message-$slug" filter.
		 */
		public function displayManualCheckResult() {
			//phpcs:disable WordPress.Security.NonceVerification.Recommended -- Just displaying a message.
			if ( isset($_GET['puc_update_check_result'], $_GET['puc_slug']) && ($_GET['puc_slug'] == $this->updateChecker->slug) ) {
				$status = sanitize_key($_GET['puc_update_check_result']);
				$title = $this->updateChecker->getInstalledPackage()->getPluginTitle();
				$noticeClass = 'updated notice-success';
				$details = '';

				if ( $status == 'no_update' ) {
					$message = sprintf(_x('The %s plugin is up to date.', 'the plugin title', 'plugin-update-checker'), $title);
				} else if ( $status == 'update_available' ) {
					$message = sprintf(_x('A new version of the %s plugin is available.', 'the plugin title', 'plugin-update-checker'), $title);
				} else if ( $status === 'error' ) {
					$message = sprintf(_x('Could not determine if updates are available for %s.', 'the plugin title', 'plugin-update-checker'), $title);
					$noticeClass = 'error notice-error';

					$details = $this->formatManualCheckErrors(get_site_transient($this->manualCheckErrorTransient));
					delete_site_transient($this->manualCheckErrorTransient);
				} else {
					$message = sprintf(__('Unknown update checker status "%s"', 'plugin-update-checker'), $status);
					$noticeClass = 'error notice-error';
				}

				$message = esc_html($message);

				//Plugins can replace the message with their own, including adding HTML.
				$message = apply_filters(
					$this->updateChecker->getUniqueName('manual_check_message'),
					$message,
					$status
				);

				printf(
					'<div class="notice %s is-dismissible"><p>%s</p>%s</div>',
					esc_attr($noticeClass),
					//phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- Was escaped above, and plugins can add HTML.
					$message,
					//phpcs:ignore WordPress.Security.EscapeOutput.OutputNotEscaped -- Contains HTML. Content should already be escaped.
					$details
				);
			}
			//phpcs:enable
		}

		/**
		 * Format the list of errors that were thrown during an update check.
		 *
		 * @param array $errors
		 * @return string
		 */
		protected function formatManualCheckErrors($errors) {
			if ( empty($errors) ) {
				return '';
			}
			$output = '';

			$showAsList = count($errors) > 1;
			if ( $showAsList ) {
				$output .= '<ol>';
				$formatString = '<li>%1$s <code>%2$s</code></li>';
			} else {
				$formatString = '<p>%1$s <code>%2$s</code></p>';
			}
			foreach ($errors as $item) {
				$wpError = $item['error'];
				/** @var \WP_Error $wpError */
				$output .= sprintf(
					$formatString,
					esc_html($wpError->get_error_message()),
					esc_html($wpError->get_error_code())
				);
			}
			if ( $showAsList ) {
				$output .= '</ol>';
			}

			return $output;
		}

		public function removeHooks() {
			remove_action('admin_init', array($this, 'onAdminInit'));
			remove_filter('plugin_row_meta', array($this, 'addViewDetailsLink'), 10);
			remove_filter('plugin_row_meta', array($this, 'addCheckForUpdatesLink'), 10);
			remove_action('all_admin_notices', array($this, 'displayManualCheckResult'));
		}
	}
endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Plugin\Update.php (3375 bytes, 117 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Plugin;

use YahnisElsts\PluginUpdateChecker\v5p6\Update as BaseUpdate;

if ( !class_exists(Update::class, false) ):

	/**
	 * A simple container class for holding information about an available update.
	 *
	 * @author Janis Elsts
	 * @copyright 2016
	 * @access public
	 */
	class Update extends BaseUpdate {
		public $id = 0;
		public $homepage;
		public $upgrade_notice;
		public $tested;
		public $requires_php = false;
		public $icons = array();
		public $filename; //Plugin filename relative to the plugins directory.

		protected static $extraFields = array(
			'id', 'homepage', 'tested', 'requires_php', 'upgrade_notice', 'icons', 'filename',
		);

		/**
		 * Create a new instance of PluginUpdate from its JSON-encoded representation.
		 *
		 * @param string $json
		 * @return self|null
		 */
		public static function fromJson($json){
			//Since update-related information is simply a subset of the full plugin info,
			//we can parse the update JSON as if it was a plugin info string, then copy over
			//the parts that we care about.
			$pluginInfo = PluginInfo::fromJson($json);
			if ( $pluginInfo !== null ) {
				return self::fromPluginInfo($pluginInfo);
			} else {
				return null;
			}
		}

		/**
		 * Create a new instance of PluginUpdate based on an instance of PluginInfo.
		 * Basically, this just copies a subset of fields from one object to another.
		 *
		 * @param PluginInfo $info
		 * @return static
		 */
		public static function fromPluginInfo($info){
			return static::fromObject($info);
		}

		/**
		 * Create a new instance by copying the necessary fields from another object.
		 *
		 * @param \StdClass|PluginInfo|self $object The source object.
		 * @return self The new copy.
		 */
		public static function fromObject($object) {
			$update = new self();
			$update->copyFields($object, $update);
			return $update;
		}

		/**
		 * @return string[]
		 */
		protected function getFieldNames() {
			return array_merge(parent::getFieldNames(), self::$extraFields);
		}

		/**
		 * Transform the update into the format used by WordPress native plugin API.
		 *
		 * @return object
		 */
		public function toWpFormat() {
			$update = parent::toWpFormat();

			$update->id = $this->id;
			$update->url = $this->homepage;
			$update->tested = $this->tested;
			$update->requires_php = $this->requires_php;
			$update->plugin = $this->filename;

			if ( !empty($this->upgrade_notice) ) {
				$update->upgrade_notice = $this->upgrade_notice;
			}

			if ( !empty($this->icons) && is_array($this->icons) ) {
				//This should be an array with up to 4 keys: 'svg', '1x', '2x' and 'default'.
				//Docs: https://developer.wordpress.org/plugins/wordpress-org/plugin-assets/#plugin-icons
				$icons = array_intersect_key(
					$this->icons,
					array('svg' => true, '1x' => true, '2x' => true, 'default' => true)
				);
				if ( !empty($icons) ) {
					$update->icons = $icons;

					//It appears that the 'default' icon isn't used anywhere in WordPress 4.9,
					//but lets set it just in case a future release needs it.
					if ( !isset($update->icons['default']) ) {
						$update->icons['default'] = current($update->icons);
					}
				}
			}

			return $update;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Plugin\UpdateChecker.php (13780 bytes, 426 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Plugin;

use YahnisElsts\PluginUpdateChecker\v5p6\InstalledPackage;
use YahnisElsts\PluginUpdateChecker\v5p6\UpdateChecker as BaseUpdateChecker;
use YahnisElsts\PluginUpdateChecker\v5p6\Scheduler;
use YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

if ( !class_exists(UpdateChecker::class, false) ):

	/**
	 * A custom plugin update checker.
	 *
	 * @author Janis Elsts
	 * @copyright 2018
	 * @access public
	 */
	class UpdateChecker extends BaseUpdateChecker {
		protected $updateTransient = 'update_plugins';
		protected $componentType = 'plugin';

		public $pluginAbsolutePath = ''; //Full path of the main plugin file.
		public $pluginFile = '';  //Plugin filename relative to the plugins directory. Many WP APIs use this to identify plugins.
		public $muPluginFile = ''; //For MU plugins, the plugin filename relative to the mu-plugins directory.

		/**
		 * @var Package
		 */
		protected $package;

		private $extraUi = null;

		/**
		 * Class constructor.
		 *
		 * @param string $metadataUrl The URL of the plugin's metadata file.
		 * @param string $pluginFile Fully qualified path to the main plugin file.
		 * @param string $slug The plugin's 'slug'. If not specified, the filename part of $pluginFile sans '.php' will be used as the slug.
		 * @param integer $checkPeriod How often to check for updates (in hours). Defaults to checking every 12 hours. Set to 0 to disable automatic update checks.
		 * @param string $optionName Where to store book-keeping info about update checks. Defaults to 'external_updates-$slug'.
		 * @param string $muPluginFile Optional. The plugin filename relative to the mu-plugins directory.
		 */
		public function __construct($metadataUrl, $pluginFile, $slug = '', $checkPeriod = 12, $optionName = '', $muPluginFile = ''){
			$this->pluginAbsolutePath = $pluginFile;
			$this->pluginFile = plugin_basename($this->pluginAbsolutePath);
			$this->muPluginFile = $muPluginFile;

			//If no slug is specified, use the name of the main plugin file as the slug.
			//For example, 'my-cool-plugin/cool-plugin.php' becomes 'cool-plugin'.
			if ( empty($slug) ){
				$slug = basename($this->pluginFile, '.php');
			}

			//Plugin slugs must be unique.
			$slugCheckFilter = 'puc_is_slug_in_use-' . $slug;
			$slugUsedBy = apply_filters($slugCheckFilter, false);
			if ( $slugUsedBy ) {
				$this->triggerError(sprintf(
					'Plugin slug "%s" is already in use by %s. Slugs must be unique.',
					$slug,
					$slugUsedBy
				), E_USER_ERROR);
			}
			add_filter($slugCheckFilter, array($this, 'getAbsolutePath'));

			parent::__construct($metadataUrl, dirname($this->pluginFile), $slug, $checkPeriod, $optionName);

			//Backwards compatibility: If the plugin is a mu-plugin but no $muPluginFile is specified, assume
			//it's the same as $pluginFile given that it's not in a subdirectory (WP only looks in the base dir).
			if ( (strpbrk($this->pluginFile, '/\\') === false) && $this->isUnknownMuPlugin() ) {
				$this->muPluginFile = $this->pluginFile;
			}

			//To prevent a crash during plugin uninstallation, remove updater hooks when the user removes the plugin.
			//Details: https://github.com/YahnisElsts/plugin-update-checker/issues/138#issuecomment-335590964
			add_action('uninstall_' . $this->pluginFile, array($this, 'removeHooks'));

			$this->extraUi = new Ui($this);
		}

		/**
		 * Create an instance of the scheduler.
		 *
		 * @param int $checkPeriod
		 * @return Scheduler
		 */
		protected function createScheduler($checkPeriod) {
			$scheduler = new Scheduler($this, $checkPeriod, array('load-plugins.php'));
			register_deactivation_hook($this->pluginFile, array($scheduler, 'removeUpdaterCron'));
			return $scheduler;
		}

		/**
		 * Install the hooks required to run periodic update checks and inject update info
		 * into WP data structures.
		 *
		 * @return void
		 */
		protected function installHooks(){
			//Override requests for plugin information
			add_filter('plugins_api', array($this, 'injectInfo'), 20, 3);

			parent::installHooks();
		}

		/**
		 * Remove update checker hooks.
		 *
		 * The intent is to prevent a fatal error that can happen if the plugin has an uninstall
		 * hook. During uninstallation, WP includes the main plugin file (which creates a PUC instance),
		 * the uninstall hook runs, WP deletes the plugin files and then updates some transients.
		 * If PUC hooks are still around at this time, they could throw an error while trying to
		 * autoload classes from files that no longer exist.
		 *
		 * The "site_transient_{$transient}" filter is the main problem here, but let's also remove
		 * most other PUC hooks to be safe.
		 *
		 * @internal
		 */
		public function removeHooks() {
			parent::removeHooks();
			$this->extraUi->removeHooks();
			$this->package->removeHooks();

			remove_filter('plugins_api', array($this, 'injectInfo'), 20);
		}

		/**
		 * Retrieve plugin info from the configured API endpoint.
		 *
		 * @uses wp_remote_get()
		 *
		 * @param array $queryArgs Additional query arguments to append to the request. Optional.
		 * @return PluginInfo
		 */
		public function requestInfo($queryArgs = array()) {
			list($pluginInfo, $result) = $this->requestMetadata(
				PluginInfo::class,
				'request_info',
				$queryArgs
			);

			if ( $pluginInfo !== null ) {
				/** @var PluginInfo $pluginInfo */
				$pluginInfo->filename = $this->pluginFile;
				$pluginInfo->slug = $this->slug;
			}

			$pluginInfo = apply_filters($this->getUniqueName('request_info_result'), $pluginInfo, $result);
			return $pluginInfo;
		}

		/**
		 * Retrieve the latest update (if any) from the configured API endpoint.
		 *
		 * @uses UpdateChecker::requestInfo()
		 *
		 * @return Update|null An instance of Plugin Update, or NULL when no updates are available.
		 */
		public function requestUpdate() {
			//For the sake of simplicity, this function just calls requestInfo()
			//and transforms the result accordingly.
			$pluginInfo = $this->requestInfo(array('checking_for_updates' => '1'));
			if ( $pluginInfo === null ){
				return null;
			}
			$update = Update::fromPluginInfo($pluginInfo);

			$update = $this->filterUpdateResult($update);

			return $update;
		}

		/**
		 * Intercept plugins_api() calls that request information about our plugin and
		 * use the configured API endpoint to satisfy them.
		 *
		 * @see plugins_api()
		 *
		 * @param mixed $result
		 * @param string $action
		 * @param array|object $args
		 * @return mixed
		 */
		public function injectInfo($result, $action = null, $args = null){
			$relevant = ($action == 'plugin_information') && isset($args->slug) && (
					($args->slug == $this->slug) || ($args->slug == dirname($this->pluginFile))
				);
			if ( !$relevant ) {
				return $result;
			}

			$pluginInfo = $this->requestInfo();
			$this->fixSupportedWordpressVersion($pluginInfo);

			$pluginInfo = apply_filters($this->getUniqueName('pre_inject_info'), $pluginInfo);
			if ( $pluginInfo ) {
				return $pluginInfo->toWpFormat();
			}

			return $result;
		}

		protected function shouldShowUpdates() {
			//No update notifications for mu-plugins unless explicitly enabled. The MU plugin file
			//is usually different from the main plugin file so the update wouldn't show up properly anyway.
			return !$this->isUnknownMuPlugin();
		}

		/**
		 * @param \stdClass|null $updates
		 * @param \stdClass $updateToAdd
		 * @return \stdClass
		 */
		protected function addUpdateToList($updates, $updateToAdd) {
			if ( $this->package->isMuPlugin() ) {
				//WP does not support automatic update installation for mu-plugins, but we can
				//still display a notice.
				$updateToAdd->package = null;
			}
			return parent::addUpdateToList($updates, $updateToAdd);
		}

		/**
		 * @param \stdClass|null $updates
		 * @return \stdClass|null
		 */
		protected function removeUpdateFromList($updates) {
			$updates = parent::removeUpdateFromList($updates);
			if ( !empty($this->muPluginFile) && isset($updates, $updates->response) ) {
				unset($updates->response[$this->muPluginFile]);
			}
			return $updates;
		}

		/**
		 * For plugins, the update array is indexed by the plugin filename relative to the "plugins"
		 * directory. Example: "plugin-name/plugin.php".
		 *
		 * @return string
		 */
		protected function getUpdateListKey() {
			if ( $this->package->isMuPlugin() ) {
				return $this->muPluginFile;
			}
			return $this->pluginFile;
		}

		protected function getNoUpdateItemFields() {
			return array_merge(
				parent::getNoUpdateItemFields(),
				array(
					'id'            => $this->pluginFile,
					'slug'          => $this->slug,
					'plugin'        => $this->pluginFile,
					'icons'         => array(),
					'banners'       => array(),
					'banners_rtl'   => array(),
					'tested'        => '',
					'compatibility' => new \stdClass(),
				)
			);
		}

		/**
		 * Alias for isBeingUpgraded().
		 *
		 * @deprecated
		 * @param \WP_Upgrader|null $upgrader The upgrader that's performing the current update.
		 * @return bool
		 */
		public function isPluginBeingUpgraded($upgrader = null) {
			return $this->isBeingUpgraded($upgrader);
		}

		/**
		 * Is there an update being installed for this plugin, right now?
		 *
		 * @param \WP_Upgrader|null $upgrader
		 * @return bool
		 */
		public function isBeingUpgraded($upgrader = null) {
			return $this->upgraderStatus->isPluginBeingUpgraded($this->pluginFile, $upgrader);
		}

		/**
		 * Get the details of the currently available update, if any.
		 *
		 * If no updates are available, or if the last known update version is below or equal
		 * to the currently installed version, this method will return NULL.
		 *
		 * Uses cached update data. To retrieve update information straight from
		 * the metadata URL, call requestUpdate() instead.
		 *
		 * @return Update|null
		 */
		public function getUpdate() {
			$update = parent::getUpdate();
			if ( isset($update) ) {
				/** @var Update $update */
				$update->filename = $this->pluginFile;
			}
			return $update;
		}

		/**
		 * Get the translated plugin title.
		 *
		 * @deprecated
		 * @return string
		 */
		public function getPluginTitle() {
			return $this->package->getPluginTitle();
		}

		/**
		 * Check if the current user has the required permissions to install updates.
		 *
		 * @return bool
		 */
		public function userCanInstallUpdates() {
			return current_user_can('update_plugins');
		}

		/**
		 * Check if the plugin file is inside the mu-plugins directory.
		 *
		 * @deprecated
		 * @return bool
		 */
		protected function isMuPlugin() {
			return $this->package->isMuPlugin();
		}

		/**
		 * MU plugins are partially supported, but only when we know which file in mu-plugins
		 * corresponds to this plugin.
		 *
		 * @return bool
		 */
		protected function isUnknownMuPlugin() {
			return empty($this->muPluginFile) && $this->package->isMuPlugin();
		}

		/**
		 * Get absolute path to the main plugin file.
		 *
		 * @return string
		 */
		public function getAbsolutePath() {
			return $this->pluginAbsolutePath;
		}

		/**
		 * Register a callback for filtering query arguments.
		 *
		 * The callback function should take one argument - an associative array of query arguments.
		 * It should return a modified array of query arguments.
		 *
		 * @uses add_filter() This method is a convenience wrapper for add_filter().
		 *
		 * @param callable $callback
		 * @return void
		 */
		public function addQueryArgFilter($callback){
			$this->addFilter('request_info_query_args', $callback);
		}

		/**
		 * Register a callback for filtering arguments passed to wp_remote_get().
		 *
		 * The callback function should take one argument - an associative array of arguments -
		 * and return a modified array or arguments. See the WP documentation on wp_remote_get()
		 * for details on what arguments are available and how they work.
		 *
		 * @uses add_filter() This method is a convenience wrapper for add_filter().
		 *
		 * @param callable $callback
		 * @return void
		 */
		public function addHttpRequestArgFilter($callback) {
			$this->addFilter('request_info_options', $callback);
		}

		/**
		 * Register a callback for filtering the plugin info retrieved from the external API.
		 *
		 * The callback function should take two arguments. If the plugin info was retrieved
		 * successfully, the first argument passed will be an instance of  PluginInfo. Otherwise,
		 * it will be NULL. The second argument will be the corresponding return value of
		 * wp_remote_get (see WP docs for details).
		 *
		 * The callback function should return a new or modified instance of PluginInfo or NULL.
		 *
		 * @uses add_filter() This method is a convenience wrapper for add_filter().
		 *
		 * @param callable $callback
		 * @return void
		 */
		public function addResultFilter($callback) {
			$this->addFilter('request_info_result', $callback, 10, 2);
		}

		protected function createDebugBarExtension() {
			return new DebugBar\PluginExtension($this);
		}

		/**
		 * Create a package instance that represents this plugin or theme.
		 *
		 * @return InstalledPackage
		 */
		protected function createInstalledPackage() {
			return new Package($this->pluginAbsolutePath, $this);
		}

		/**
		 * @return Package
		 */
		public function getInstalledPackage() {
			return $this->package;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Theme\Package.php (1898 bytes, 70 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Theme;

use YahnisElsts\PluginUpdateChecker\v5p6\InstalledPackage;

if ( !class_exists(Package::class, false) ):

	class Package extends InstalledPackage {
		/**
		 * @var string Theme directory name.
		 */
		protected $stylesheet;

		/**
		 * @var \WP_Theme Theme object.
		 */
		protected $theme;

		public function __construct($stylesheet, $updateChecker) {
			$this->stylesheet = $stylesheet;
			$this->theme = wp_get_theme($this->stylesheet);

			parent::__construct($updateChecker);
		}

		public function getInstalledVersion() {
			return $this->theme->get('Version');
		}

		public function getAbsoluteDirectoryPath() {
			if ( method_exists($this->theme, 'get_stylesheet_directory') ) {
				return $this->theme->get_stylesheet_directory(); //Available since WP 3.4.
			}
			return get_theme_root($this->stylesheet) . '/' . $this->stylesheet;
		}

		/**
		 * Get the value of a specific plugin or theme header.
		 *
		 * @param string $headerName
		 * @param string $defaultValue
		 * @return string Either the value of the header, or $defaultValue if the header doesn't exist or is empty.
		 */
		public function getHeaderValue($headerName, $defaultValue = '') {
			$value = $this->theme->get($headerName);
			if ( ($headerName === false) || ($headerName === '') ) {
				return $defaultValue;
			}
			return $value;
		}

		protected function getHeaderNames() {
			return array(
				'Name'        => 'Theme Name',
				'ThemeURI'    => 'Theme URI',
				'Description' => 'Description',
				'Author'      => 'Author',
				'AuthorURI'   => 'Author URI',
				'Version'     => 'Version',
				'Template'    => 'Template',
				'Status'      => 'Status',
				'Tags'        => 'Tags',
				'TextDomain'  => 'Text Domain',
				'DomainPath'  => 'Domain Path',
			);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Theme\Update.php (2299 bytes, 89 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Theme;

use YahnisElsts\PluginUpdateChecker\v5p6\Update as BaseUpdate;

if ( !class_exists(Update::class, false) ):

	class Update extends BaseUpdate {
		public $details_url = '';

		protected static $extraFields = array('details_url');

		/**
		 * Transform the metadata into the format used by WordPress core.
		 * Note the inconsistency: WP stores plugin updates as objects and theme updates as arrays.
		 *
		 * @return array
		 */
		public function toWpFormat() {
			$update = array(
				'theme' => $this->slug,
				'new_version' => $this->version,
				'url' => $this->details_url,
			);

			if ( !empty($this->download_url) ) {
				$update['package'] = $this->download_url;
			}

			return $update;
		}

		/**
		 * Create a new instance of Theme_Update from its JSON-encoded representation.
		 *
		 * @param string $json Valid JSON string representing a theme information object.
		 * @return self New instance of ThemeUpdate, or NULL on error.
		 */
		public static function fromJson($json) {
			$instance = new self();
			if ( !parent::createFromJson($json, $instance) ) {
				return null;
			}
			return $instance;
		}

		/**
		 * Create a new instance by copying the necessary fields from another object.
		 *
		 * @param \StdClass|self $object The source object.
		 * @return self The new copy.
		 */
		public static function fromObject($object) {
			$update = new self();
			$update->copyFields($object, $update);
			return $update;
		}

		/**
		 * Basic validation.
		 *
		 * @param \StdClass $apiResponse
		 * @return bool|\WP_Error
		 */
		protected function validateMetadata($apiResponse) {
			$required = array('version', 'details_url');
			foreach($required as $key) {
				if ( !isset($apiResponse->$key) || empty($apiResponse->$key) ) {
					return new \WP_Error(
						'tuc-invalid-metadata',
						sprintf('The theme metadata is missing the required "%s" key.', $key)
					);
				}
			}
			return true;
		}

		protected function getFieldNames() {
			return array_merge(parent::getFieldNames(), self::$extraFields);
		}

		protected function getPrefixedFilter($tag) {
			return parent::getPrefixedFilter($tag) . '_theme';
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Theme\UpdateChecker.php (4837 bytes, 160 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Theme;

use YahnisElsts\PluginUpdateChecker\v5p6\UpdateChecker as BaseUpdateChecker;
use YahnisElsts\PluginUpdateChecker\v5p6\InstalledPackage;
use YahnisElsts\PluginUpdateChecker\v5p6\Scheduler;
use YahnisElsts\PluginUpdateChecker\v5p6\DebugBar;

if ( !class_exists(UpdateChecker::class, false) ):

	class UpdateChecker extends BaseUpdateChecker {
		protected $filterSuffix = 'theme';
		protected $updateTransient = 'update_themes';
		protected $componentType = 'theme';

		/**
		 * @var string Theme directory name.
		 */
		protected $stylesheet;

		public function __construct($metadataUrl, $stylesheet = null, $customSlug = null, $checkPeriod = 12, $optionName = '') {
			if ( $stylesheet === null ) {
				$stylesheet = get_stylesheet();
			}
			$this->stylesheet = $stylesheet;

			parent::__construct(
				$metadataUrl,
				$stylesheet,
				$customSlug ? $customSlug : $stylesheet,
				$checkPeriod,
				$optionName
			);
		}

		/**
		 * For themes, the update array is indexed by theme directory name.
		 *
		 * @return string
		 */
		protected function getUpdateListKey() {
			return $this->directoryName;
		}

		/**
		 * Retrieve the latest update (if any) from the configured API endpoint.
		 *
		 * @return Update|null An instance of Update, or NULL when no updates are available.
		 */
		public function requestUpdate() {
			list($themeUpdate, $result) = $this->requestMetadata(Update::class, 'request_update');

			if ( $themeUpdate !== null ) {
				/** @var Update $themeUpdate */
				$themeUpdate->slug = $this->slug;
			}

			$themeUpdate = $this->filterUpdateResult($themeUpdate, $result);
			return $themeUpdate;
		}

		protected function getNoUpdateItemFields() {
			return array_merge(
				parent::getNoUpdateItemFields(),
				array(
					'theme'        => $this->directoryName,
					'requires'     => '',
				)
			);
		}

		public function userCanInstallUpdates() {
			return current_user_can('update_themes');
		}

		/**
		 * Create an instance of the scheduler.
		 *
		 * @param int $checkPeriod
		 * @return Scheduler
		 */
		protected function createScheduler($checkPeriod) {
			return new Scheduler($this, $checkPeriod, array('load-themes.php'));
		}

		/**
		 * Is there an update being installed right now for this theme?
		 *
		 * @param \WP_Upgrader|null $upgrader The upgrader that's performing the current update.
		 * @return bool
		 */
		public function isBeingUpgraded($upgrader = null) {
			return $this->upgraderStatus->isThemeBeingUpgraded($this->stylesheet, $upgrader);
		}

		protected function createDebugBarExtension() {
			return new DebugBar\Extension($this, DebugBar\ThemePanel::class);
		}

		/**
		 * Register a callback for filtering query arguments.
		 *
		 * The callback function should take one argument - an associative array of query arguments.
		 * It should return a modified array of query arguments.
		 *
		 * @param callable $callback
		 * @return void
		 */
		public function addQueryArgFilter($callback){
			$this->addFilter('request_update_query_args', $callback);
		}

		/**
		 * Register a callback for filtering arguments passed to wp_remote_get().
		 *
		 * The callback function should take one argument - an associative array of arguments -
		 * and return a modified array or arguments. See the WP documentation on wp_remote_get()
		 * for details on what arguments are available and how they work.
		 *
		 * @uses add_filter() This method is a convenience wrapper for add_filter().
		 *
		 * @param callable $callback
		 * @return void
		 */
		public function addHttpRequestArgFilter($callback) {
			$this->addFilter('request_update_options', $callback);
		}

		/**
		 * Register a callback for filtering theme updates retrieved from the external API.
		 *
		 * The callback function should take two arguments. If the theme update was retrieved
		 * successfully, the first argument passed will be an instance of Theme_Update. Otherwise,
		 * it will be NULL. The second argument will be the corresponding return value of
		 * wp_remote_get (see WP docs for details).
		 *
		 * The callback function should return a new or modified instance of Theme_Update or NULL.
		 *
		 * @uses add_filter() This method is a convenience wrapper for add_filter().
		 *
		 * @param callable $callback
		 * @return void
		 */
		public function addResultFilter($callback) {
			$this->addFilter('request_update_result', $callback, 10, 2);
		}

		/**
		 * Create a package instance that represents this plugin or theme.
		 *
		 * @return InstalledPackage
		 */
		protected function createInstalledPackage() {
			return new Package($this->stylesheet, $this);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\Api.php (10264 bytes, 380 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

use Parsedown;
use PucReadmeParser;

if ( !class_exists(Api::class, false) ):

	abstract class Api {
		const STRATEGY_LATEST_RELEASE = 'latest_release';
		const STRATEGY_LATEST_TAG = 'latest_tag';
		const STRATEGY_STABLE_TAG = 'stable_tag';
		const STRATEGY_BRANCH = 'branch';

		/**
		 * Consider all releases regardless of their version number or prerelease/upcoming
		 * release status.
		 */
		const RELEASE_FILTER_ALL = 3;

		/**
		 * Exclude releases that have the "prerelease" or "upcoming release" flag.
		 *
		 * This does *not* look for prerelease keywords like "beta" in the version number.
		 * It only uses the data provided by the API. For example, on GitHub, you can
		 * manually mark a release as a prerelease.
		 */
		const RELEASE_FILTER_SKIP_PRERELEASE = 1;

		/**
		 * If there are no release assets or none of them match the configured filter,
		 * fall back to the automatically generated source code archive.
		 */
		const PREFER_RELEASE_ASSETS = 1;
		/**
		 * Skip releases that don't have any matching release assets.
		 */
		const REQUIRE_RELEASE_ASSETS = 2;

		protected $tagNameProperty = 'name';
		protected $slug = '';

		/**
		 * @var string
		 */
		protected $repositoryUrl = '';

		/**
		 * @var mixed Authentication details for private repositories. Format depends on service.
		 */
		protected $credentials = null;

		/**
		 * @var string The filter tag that's used to filter options passed to wp_remote_get.
		 * For example, "puc_request_info_options-slug" or "puc_request_update_options_theme-slug".
		 */
		protected $httpFilterName = '';

		/**
		 * @var string The filter applied to the list of update detection strategies that
		 * are used to find the latest version.
		 */
		protected $strategyFilterName = '';

		/**
		 * @var string|null
		 */
		protected $localDirectory = null;

		/**
		 * Api constructor.
		 *
		 * @param string $repositoryUrl
		 * @param array|string|null $credentials
		 */
		public function __construct($repositoryUrl, $credentials = null) {
			$this->repositoryUrl = $repositoryUrl;
			$this->setAuthentication($credentials);
		}

		/**
		 * @return string
		 */
		public function getRepositoryUrl() {
			return $this->repositoryUrl;
		}

		/**
		 * Figure out which reference (i.e. tag or branch) contains the latest version.
		 *
		 * @param string $configBranch Start looking in this branch.
		 * @return null|Reference
		 */
		public function chooseReference($configBranch) {
			$strategies = $this->getUpdateDetectionStrategies($configBranch);

			if ( !empty($this->strategyFilterName) ) {
				$strategies = apply_filters(
					$this->strategyFilterName,
					$strategies,
					$this->slug
				);
			}

			foreach ($strategies as $strategy) {
				$reference = call_user_func($strategy);
				if ( !empty($reference) ) {
					return $reference;
				}
			}
			return null;
		}

		/**
		 * Get an ordered list of strategies that can be used to find the latest version.
		 *
		 * The update checker will try each strategy in order until one of them
		 * returns a valid reference.
		 *
		 * @param string $configBranch
		 * @return array<callable> Array of callables that return Vcs_Reference objects.
		 */
		abstract protected function getUpdateDetectionStrategies($configBranch);

		/**
		 * Get the readme.txt file from the remote repository and parse it
		 * according to the plugin readme standard.
		 *
		 * @param string $ref Tag or branch name.
		 * @return array Parsed readme.
		 */
		public function getRemoteReadme($ref = 'master') {
			$fileContents = $this->getRemoteFile($this->getLocalReadmeName(), $ref);
			if ( empty($fileContents) ) {
				return array();
			}

			$parser = new PucReadmeParser();
			return $parser->parse_readme_contents($fileContents);
		}

		/**
		 * Get the case-sensitive name of the local readme.txt file.
		 *
		 * In most cases it should just be called "readme.txt", but some plugins call it "README.txt",
		 * "README.TXT", or even "Readme.txt". Most VCS are case-sensitive so we need to know the correct
		 * capitalization.
		 *
		 * Defaults to "readme.txt" (all lowercase).
		 *
		 * @return string
		 */
		public function getLocalReadmeName() {
			static $fileName = null;
			if ( $fileName !== null ) {
				return $fileName;
			}

			$fileName = 'readme.txt';
			if ( isset($this->localDirectory) ) {
				$files = scandir($this->localDirectory);
				if ( !empty($files) ) {
					foreach ($files as $possibleFileName) {
						if ( strcasecmp($possibleFileName, 'readme.txt') === 0 ) {
							$fileName = $possibleFileName;
							break;
						}
					}
				}
			}
			return $fileName;
		}

		/**
		 * Get a branch.
		 *
		 * @param string $branchName
		 * @return Reference|null
		 */
		abstract public function getBranch($branchName);

		/**
		 * Get a specific tag.
		 *
		 * @param string $tagName
		 * @return Reference|null
		 */
		abstract public function getTag($tagName);

		/**
		 * Get the tag that looks like the highest version number.
		 * (Implementations should skip pre-release versions if possible.)
		 *
		 * @return Reference|null
		 */
		abstract public function getLatestTag();

		/**
		 * Check if a tag name string looks like a version number.
		 *
		 * @param string $name
		 * @return bool
		 */
		protected function looksLikeVersion($name) {
			//Tag names may be prefixed with "v", e.g. "v1.2.3".
			$name = ltrim($name, 'v');

			//The version string must start with a number.
			if ( !is_numeric(substr($name, 0, 1)) ) {
				return false;
			}

			//The goal is to accept any SemVer-compatible or "PHP-standardized" version number.
			return (preg_match('@^(\d{1,5}?)(\.\d{1,10}?){0,4}?($|[abrdp+_\-]|\s)@i', $name) === 1);
		}

		/**
		 * Check if a tag appears to be named like a version number.
		 *
		 * @param \stdClass $tag
		 * @return bool
		 */
		protected function isVersionTag($tag) {
			$property = $this->tagNameProperty;
			return isset($tag->$property) && $this->looksLikeVersion($tag->$property);
		}

		/**
		 * Sort a list of tags as if they were version numbers.
		 * Tags that don't look like version number will be removed.
		 *
		 * @param \stdClass[] $tags Array of tag objects.
		 * @return \stdClass[] Filtered array of tags sorted in descending order.
		 */
		protected function sortTagsByVersion($tags) {
			//Keep only those tags that look like version numbers.
			$versionTags = array_filter($tags, array($this, 'isVersionTag'));
			//Sort them in descending order.
			usort($versionTags, array($this, 'compareTagNames'));

			return $versionTags;
		}

		/**
		 * Compare two tags as if they were version number.
		 *
		 * @param \stdClass $tag1 Tag object.
		 * @param \stdClass $tag2 Another tag object.
		 * @return int
		 */
		protected function compareTagNames($tag1, $tag2) {
			$property = $this->tagNameProperty;
			if ( !isset($tag1->$property) ) {
				return 1;
			}
			if ( !isset($tag2->$property) ) {
				return -1;
			}
			return -version_compare(ltrim($tag1->$property, 'v'), ltrim($tag2->$property, 'v'));
		}

		/**
		 * Get the contents of a file from a specific branch or tag.
		 *
		 * @param string $path File name.
		 * @param string $ref
		 * @return null|string Either the contents of the file, or null if the file doesn't exist or there's an error.
		 */
		abstract public function getRemoteFile($path, $ref = 'master');

		/**
		 * Get the timestamp of the latest commit that changed the specified branch or tag.
		 *
		 * @param string $ref Reference name (e.g. branch or tag).
		 * @return string|null
		 */
		abstract public function getLatestCommitTime($ref);

		/**
		 * Get the contents of the changelog file from the repository.
		 *
		 * @param string $ref
		 * @param string $localDirectory Full path to the local plugin or theme directory.
		 * @return null|string The HTML contents of the changelog.
		 */
		public function getRemoteChangelog($ref, $localDirectory) {
			$filename = $this->findChangelogName($localDirectory);
			if ( empty($filename) ) {
				return null;
			}

			$changelog = $this->getRemoteFile($filename, $ref);
			if ( $changelog === null ) {
				return null;
			}

			return Parsedown::instance()->text($changelog);
		}

		/**
		 * Guess the name of the changelog file.
		 *
		 * @param string $directory
		 * @return string|null
		 */
		protected function findChangelogName($directory = null) {
			if ( !isset($directory) ) {
				$directory = $this->localDirectory;
			}
			if ( empty($directory) || !is_dir($directory) || ($directory === '.') ) {
				return null;
			}

			$possibleNames = array('CHANGES.md', 'CHANGELOG.md', 'changes.md', 'changelog.md');
			$files = scandir($directory);
			$foundNames = array_intersect($possibleNames, $files);

			if ( !empty($foundNames) ) {
				return reset($foundNames);
			}
			return null;
		}

		/**
		 * Set authentication credentials.
		 *
		 * @param $credentials
		 */
		public function setAuthentication($credentials) {
			$this->credentials = $credentials;
		}

		public function isAuthenticationEnabled() {
			return !empty($this->credentials);
		}

		/**
		 * @param string $url
		 * @return string
		 */
		public function signDownloadUrl($url) {
			return $url;
		}

		/**
		 * @param string $filterName
		 */
		public function setHttpFilterName($filterName) {
			$this->httpFilterName = $filterName;
		}

		/**
		 * @param string $filterName
		 */
		public function setStrategyFilterName($filterName) {
			$this->strategyFilterName = $filterName;
		}

		/**
		 * @param string $directory
		 */
		public function setLocalDirectory($directory) {
			if ( empty($directory) || !is_dir($directory) || ($directory === '.') ) {
				$this->localDirectory = null;
			} else {
				$this->localDirectory = $directory;
			}
		}

		/**
		 * @param string $slug
		 */
		public function setSlug($slug) {
			$this->slug = $slug;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\BaseChecker.php (576 bytes, 30 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !interface_exists(BaseChecker::class, false) ):

	interface BaseChecker {
		/**
		 * Set the repository branch to use for updates. Defaults to 'master'.
		 *
		 * @param string $branch
		 * @return $this
		 */
		public function setBranch($branch);

		/**
		 * Set authentication credentials.
		 *
		 * @param array|string $credentials
		 * @return $this
		 */
		public function setAuthentication($credentials);

		/**
		 * @return Api
		 */
		public function getVcsApi();
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\BitBucketApi.php (7626 bytes, 273 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

use YahnisElsts\PluginUpdateChecker\v5p6\OAuthSignature;
use YahnisElsts\PluginUpdateChecker\v5p6\Utils;

if ( !class_exists(BitBucketApi::class, false) ):

	class BitBucketApi extends Api {
		/**
		 * @var OAuthSignature
		 */
		private $oauth = null;

		/**
		 * @var string
		 */
		private $username;

		/**
		 * @var string
		 */
		private $repository;

		public function __construct($repositoryUrl, $credentials = array()) {
			$path = wp_parse_url($repositoryUrl, PHP_URL_PATH);
			if ( preg_match('@^/?(?P<username>[^/]+?)/(?P<repository>[^/#?&]+?)/?$@', $path, $matches) ) {
				$this->username = $matches['username'];
				$this->repository = $matches['repository'];
			} else {
				throw new \InvalidArgumentException('Invalid BitBucket repository URL: "' . $repositoryUrl . '"');
			}

			parent::__construct($repositoryUrl, $credentials);
		}

		protected function getUpdateDetectionStrategies($configBranch) {
			$strategies = array(
				self::STRATEGY_STABLE_TAG => function () use ($configBranch) {
					return $this->getStableTag($configBranch);
				},
			);

			if ( ($configBranch === 'master' || $configBranch === 'main') ) {
				$strategies[self::STRATEGY_LATEST_TAG] = array($this, 'getLatestTag');
			}

			$strategies[self::STRATEGY_BRANCH] = function () use ($configBranch) {
				return $this->getBranch($configBranch);
			};
			return $strategies;
		}

		public function getBranch($branchName) {
			$branch = $this->api('/refs/branches/' . $branchName);
			if ( is_wp_error($branch) || empty($branch) ) {
				return null;
			}

			//The "/src/{stuff}/{path}" endpoint doesn't seem to handle branch names that contain slashes.
			//If we don't encode the slash, we get a 404. If we encode it as "%2F", we get a 401.
			//To avoid issues, if the branch name is not URL-safe, let's use the commit hash instead.
			$ref = $branch->name;
			if ((urlencode($ref) !== $ref) && isset($branch->target->hash)) {
				$ref = $branch->target->hash;
			}

			return new Reference(array(
				'name' => $ref,
				'updated' => $branch->target->date,
				'downloadUrl' => $this->getDownloadUrl($branch->name),
			));
		}

		/**
		 * Get a specific tag.
		 *
		 * @param string $tagName
		 * @return Reference|null
		 */
		public function getTag($tagName) {
			$tag = $this->api('/refs/tags/' . $tagName);
			if ( is_wp_error($tag) || empty($tag) ) {
				return null;
			}

			return new Reference(array(
				'name' => $tag->name,
				'version' => ltrim($tag->name, 'v'),
				'updated' => $tag->target->date,
				'downloadUrl' => $this->getDownloadUrl($tag->name),
			));
		}

		/**
		 * Get the tag that looks like the highest version number.
		 *
		 * @return Reference|null
		 */
		public function getLatestTag() {
			$tags = $this->api('/refs/tags?sort=-target.date');
			if ( !isset($tags, $tags->values) || !is_array($tags->values) ) {
				return null;
			}

			//Filter and sort the list of tags.
			$versionTags = $this->sortTagsByVersion($tags->values);

			//Return the first result.
			if ( !empty($versionTags) ) {
				$tag = $versionTags[0];
				return new Reference(array(
					'name' => $tag->name,
					'version' => ltrim($tag->name, 'v'),
					'updated' => $tag->target->date,
					'downloadUrl' => $this->getDownloadUrl($tag->name),
				));
			}
			return null;
		}

		/**
		 * Get the tag/ref specified by the "Stable tag" header in the readme.txt of a given branch.
		 *
		 * @param string $branch
		 * @return null|Reference
		 */
		protected function getStableTag($branch) {
			$remoteReadme = $this->getRemoteReadme($branch);
			if ( !empty($remoteReadme['stable_tag']) ) {
				$tag = $remoteReadme['stable_tag'];

				//You can explicitly opt out of using tags by setting "Stable tag" to
				//"trunk" or the name of the current branch.
				if ( ($tag === $branch) || ($tag === 'trunk') ) {
					return $this->getBranch($branch);
				}

				return $this->getTag($tag);
			}

			return null;
		}

		/**
		 * @param string $ref
		 * @return string
		 */
		protected function getDownloadUrl($ref) {
			return sprintf(
				'https://bitbucket.org/%s/%s/get/%s.zip',
				$this->username,
				$this->repository,
				$ref
			);
		}

		/**
		 * Get the contents of a file from a specific branch or tag.
		 *
		 * @param string $path File name.
		 * @param string $ref
		 * @return null|string Either the contents of the file, or null if the file doesn't exist or there's an error.
		 */
		public function getRemoteFile($path, $ref = 'master') {
			$response = $this->api('src/' . $ref . '/' . ltrim($path));
			if ( is_wp_error($response) || !is_string($response) ) {
				return null;
			}
			return $response;
		}

		/**
		 * Get the timestamp of the latest commit that changed the specified branch or tag.
		 *
		 * @param string $ref Reference name (e.g. branch or tag).
		 * @return string|null
		 */
		public function getLatestCommitTime($ref) {
			$response = $this->api('commits/' . $ref);
			if ( isset($response->values, $response->values[0], $response->values[0]->date) ) {
				return $response->values[0]->date;
			}
			return null;
		}

		/**
		 * Perform a BitBucket API 2.0 request.
		 *
		 * @param string $url
		 * @param string $version
		 * @return mixed|\WP_Error
		 */
		public function api($url, $version = '2.0') {
			$url = ltrim($url, '/');
			$isSrcResource = Utils::startsWith($url, 'src/');

			$url = implode('/', array(
				'https://api.bitbucket.org',
				$version,
				'repositories',
				$this->username,
				$this->repository,
				$url
			));
			$baseUrl = $url;

			if ( $this->oauth ) {
				$url = $this->oauth->sign($url,'GET');
			}

			$options = array('timeout' => wp_doing_cron() ? 10 : 3);
			if ( !empty($this->httpFilterName) ) {
				$options = apply_filters($this->httpFilterName, $options);
			}
			$response = wp_remote_get($url, $options);
			if ( is_wp_error($response) ) {
				do_action('puc_api_error', $response, null, $url, $this->slug);
				return $response;
			}

			$code = wp_remote_retrieve_response_code($response);
			$body = wp_remote_retrieve_body($response);
			if ( $code === 200 ) {
				if ( $isSrcResource ) {
					//Most responses are JSON-encoded, but src resources just
					//return raw file contents.
					$document = $body;
				} else {
					$document = json_decode($body);
				}
				return $document;
			}

			$error = new \WP_Error(
				'puc-bitbucket-http-error',
				sprintf('BitBucket API error. Base URL: "%s",  HTTP status code: %d.', $baseUrl, $code)
			);
			do_action('puc_api_error', $error, $response, $url, $this->slug);

			return $error;
		}

		/**
		 * @param array $credentials
		 */
		public function setAuthentication($credentials) {
			parent::setAuthentication($credentials);

			if ( !empty($credentials) && !empty($credentials['consumer_key']) ) {
				$this->oauth = new OAuthSignature(
					$credentials['consumer_key'],
					$credentials['consumer_secret']
				);
			} else {
				$this->oauth = null;
			}
		}

		public function signDownloadUrl($url) {
			//Add authentication data to download URLs. Since OAuth signatures incorporate
			//timestamps, we have to do this immediately before inserting the update. Otherwise,
			//authentication could fail due to a stale timestamp.
			if ( $this->oauth ) {
				$url = $this->oauth->sign($url);
			}
			return $url;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\GitHubApi.php (14207 bytes, 468 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

use Parsedown;

if ( !class_exists(GitHubApi::class, false) ):

	class GitHubApi extends Api {
		use ReleaseAssetSupport;
		use ReleaseFilteringFeature;

		/**
		 * @var string GitHub username.
		 */
		protected $userName;
		/**
		 * @var string GitHub repository name.
		 */
		protected $repositoryName;

		/**
		 * @var string Either a fully qualified repository URL, or just "user/repo-name".
		 */
		protected $repositoryUrl;

		/**
		 * @var string GitHub authentication token. Optional.
		 */
		protected $accessToken;

		/**
		 * @var bool
		 */
		private $downloadFilterAdded = false;

		public function __construct($repositoryUrl, $accessToken = null) {
			$path = wp_parse_url($repositoryUrl, PHP_URL_PATH);
			if ( preg_match('@^/?(?P<username>[^/]+?)/(?P<repository>[^/#?&]+?)/?$@', $path, $matches) ) {
				$this->userName = $matches['username'];
				$this->repositoryName = $matches['repository'];
			} else {
				throw new \InvalidArgumentException('Invalid GitHub repository URL: "' . $repositoryUrl . '"');
			}

			parent::__construct($repositoryUrl, $accessToken);
		}

		/**
		 * Get the latest release from GitHub.
		 *
		 * @return Reference|null
		 */
		public function getLatestRelease() {
			//The "latest release" endpoint returns one release and always skips pre-releases,
			//so we can only use it if that's compatible with the current filter settings.
			if (
				$this->shouldSkipPreReleases()
				&& (
					($this->releaseFilterMaxReleases === 1) || !$this->hasCustomReleaseFilter()
				)
			) {
				//Just get the latest release.
				$release = $this->api('/repos/:user/:repo/releases/latest');
				if ( is_wp_error($release) || !is_object($release) || !isset($release->tag_name) ) {
					return null;
				}
				$foundReleases = array($release);
			} else {
				//Get a list of the most recent releases.
				$foundReleases = $this->api(
					'/repos/:user/:repo/releases',
					array('per_page' => $this->releaseFilterMaxReleases)
				);
				if ( is_wp_error($foundReleases) || !is_array($foundReleases) ) {
					return null;
				}
			}

			foreach ($foundReleases as $release) {
				//Always skip drafts.
				if ( isset($release->draft) && !empty($release->draft) ) {
					continue;
				}

				//Skip pre-releases unless specifically included.
				if (
					$this->shouldSkipPreReleases()
					&& isset($release->prerelease)
					&& !empty($release->prerelease)
				) {
					continue;
				}

				$versionNumber = ltrim($release->tag_name, 'v'); //Remove the "v" prefix from "v1.2.3".

				//Custom release filtering.
				if ( !$this->matchesCustomReleaseFilter($versionNumber, $release) ) {
					continue;
				}

				$reference = new Reference(array(
					'name'        => $release->tag_name,
					'version'     => $versionNumber,
					'downloadUrl' => $release->zipball_url,
					'updated'     => $release->created_at,
					'apiResponse' => $release,
				));

				if ( isset($release->assets[0]) ) {
					$reference->downloadCount = $release->assets[0]->download_count;
				}

				if ( $this->releaseAssetsEnabled ) {
					//Use the first release asset that matches the specified regular expression.
					if ( isset($release->assets, $release->assets[0]) ) {
						$matchingAssets = array_values(array_filter($release->assets, array($this, 'matchesAssetFilter')));
					} else {
						$matchingAssets = array();
					}

					if ( !empty($matchingAssets) ) {
						if ( $this->isAuthenticationEnabled() ) {
							/**
							 * Keep in mind that we'll need to add an "Accept" header to download this asset.
							 *
							 * @see setUpdateDownloadHeaders()
							 */
							$reference->downloadUrl = $matchingAssets[0]->url;
						} else {
							//It seems that browser_download_url only works for public repositories.
							//Using an access_token doesn't help. Maybe OAuth would work?
							$reference->downloadUrl = $matchingAssets[0]->browser_download_url;
						}

						$reference->downloadCount = $matchingAssets[0]->download_count;
					} else if ( $this->releaseAssetPreference === Api::REQUIRE_RELEASE_ASSETS ) {
						//None of the assets match the filter, and we're not allowed
						//to fall back to the auto-generated source ZIP.
						return null;
					}
				}

				if ( !empty($release->body) ) {
					$reference->changelog = Parsedown::instance()->text($release->body);
				}

				return $reference;
			}

			return null;
		}

		/**
		 * Get the tag that looks like the highest version number.
		 *
		 * @return Reference|null
		 */
		public function getLatestTag() {
			$tags = $this->api('/repos/:user/:repo/tags');

			if ( is_wp_error($tags) || !is_array($tags) ) {
				return null;
			}

			$versionTags = $this->sortTagsByVersion($tags);
			if ( empty($versionTags) ) {
				return null;
			}

			$tag = $versionTags[0];
			return new Reference(array(
				'name'        => $tag->name,
				'version'     => ltrim($tag->name, 'v'),
				'downloadUrl' => $tag->zipball_url,
				'apiResponse' => $tag,
			));
		}

		/**
		 * Get a branch by name.
		 *
		 * @param string $branchName
		 * @return null|Reference
		 */
		public function getBranch($branchName) {
			$branch = $this->api('/repos/:user/:repo/branches/' . $branchName);
			if ( is_wp_error($branch) || empty($branch) ) {
				return null;
			}

			$reference = new Reference(array(
				'name'        => $branch->name,
				'downloadUrl' => $this->buildArchiveDownloadUrl($branch->name),
				'apiResponse' => $branch,
			));

			if ( isset($branch->commit, $branch->commit->commit, $branch->commit->commit->author->date) ) {
				$reference->updated = $branch->commit->commit->author->date;
			}

			return $reference;
		}

		/**
		 * Get the latest commit that changed the specified file.
		 *
		 * @param string $filename
		 * @param string $ref Reference name (e.g. branch or tag).
		 * @return \StdClass|null
		 */
		public function getLatestCommit($filename, $ref = 'master') {
			$commits = $this->api(
				'/repos/:user/:repo/commits',
				array(
					'path' => $filename,
					'sha'  => $ref,
				)
			);
			if ( !is_wp_error($commits) && isset($commits[0]) ) {
				return $commits[0];
			}
			return null;
		}

		/**
		 * Get the timestamp of the latest commit that changed the specified branch or tag.
		 *
		 * @param string $ref Reference name (e.g. branch or tag).
		 * @return string|null
		 */
		public function getLatestCommitTime($ref) {
			$commits = $this->api('/repos/:user/:repo/commits', array('sha' => $ref));
			if ( !is_wp_error($commits) && isset($commits[0]) ) {
				return $commits[0]->commit->author->date;
			}
			return null;
		}

		/**
		 * Perform a GitHub API request.
		 *
		 * @param string $url
		 * @param array $queryParams
		 * @return mixed|\WP_Error
		 */
		protected function api($url, $queryParams = array()) {
			$baseUrl = $url;
			$url = $this->buildApiUrl($url, $queryParams);

			$options = array('timeout' => wp_doing_cron() ? 10 : 3);
			if ( $this->isAuthenticationEnabled() ) {
				$options['headers'] = array('Authorization' => $this->getAuthorizationHeader());
			}

			if ( !empty($this->httpFilterName) ) {
				$options = apply_filters($this->httpFilterName, $options);
			}
			$response = wp_remote_get($url, $options);
			if ( is_wp_error($response) ) {
				do_action('puc_api_error', $response, null, $url, $this->slug);
				return $response;
			}

			$code = wp_remote_retrieve_response_code($response);
			$body = wp_remote_retrieve_body($response);
			if ( $code === 200 ) {
				$document = json_decode($body);
				return $document;
			}

			$error = new \WP_Error(
				'puc-github-http-error',
				sprintf('GitHub API error. Base URL: "%s",  HTTP status code: %d.', $baseUrl, $code)
			);
			do_action('puc_api_error', $error, $response, $url, $this->slug);

			return $error;
		}

		/**
		 * Build a fully qualified URL for an API request.
		 *
		 * @param string $url
		 * @param array $queryParams
		 * @return string
		 */
		protected function buildApiUrl($url, $queryParams) {
			$variables = array(
				'user' => $this->userName,
				'repo' => $this->repositoryName,
			);
			foreach ($variables as $name => $value) {
				$url = str_replace('/:' . $name, '/' . urlencode($value), $url);
			}
			$url = 'https://api.github.com' . $url;

			if ( !empty($queryParams) ) {
				$url = add_query_arg($queryParams, $url);
			}

			return $url;
		}

		/**
		 * Get the contents of a file from a specific branch or tag.
		 *
		 * @param string $path File name.
		 * @param string $ref
		 * @return null|string Either the contents of the file, or null if the file doesn't exist or there's an error.
		 */
		public function getRemoteFile($path, $ref = 'master') {
			$apiUrl = '/repos/:user/:repo/contents/' . $path;
			$response = $this->api($apiUrl, array('ref' => $ref));

			if ( is_wp_error($response) || !isset($response->content) || ($response->encoding !== 'base64') ) {
				return null;
			}
			return base64_decode($response->content);
		}

		/**
		 * Generate a URL to download a ZIP archive of the specified branch/tag/etc.
		 *
		 * @param string $ref
		 * @return string
		 */
		public function buildArchiveDownloadUrl($ref = 'master') {
			$url = sprintf(
				'https://api.github.com/repos/%1$s/%2$s/zipball/%3$s',
				urlencode($this->userName),
				urlencode($this->repositoryName),
				urlencode($ref)
			);
			return $url;
		}

		/**
		 * Get a specific tag.
		 *
		 * @param string $tagName
		 * @return void
		 */
		public function getTag($tagName) {
			//The current GitHub update checker doesn't use getTag, so I didn't bother to implement it.
			throw new \LogicException('The ' . __METHOD__ . ' method is not implemented and should not be used.');
		}

		public function setAuthentication($credentials) {
			parent::setAuthentication($credentials);
			$this->accessToken = is_string($credentials) ? $credentials : null;

			//Optimization: Instead of filtering all HTTP requests, let's do it only when
			//WordPress is about to download an update.
			add_filter('upgrader_pre_download', array($this, 'addHttpRequestFilter'), 10, 1); //WP 3.7+
		}

		protected function getUpdateDetectionStrategies($configBranch) {
			$strategies = array();

			if ( $configBranch === 'master' || $configBranch === 'main') {
				//Use the latest release.
				$strategies[self::STRATEGY_LATEST_RELEASE] = array($this, 'getLatestRelease');
				//Failing that, use the tag with the highest version number.
				$strategies[self::STRATEGY_LATEST_TAG] = array($this, 'getLatestTag');
			}

			//Alternatively, just use the branch itself.
			$strategies[self::STRATEGY_BRANCH] = function () use ($configBranch) {
				return $this->getBranch($configBranch);
			};

			return $strategies;
		}

		/**
		 * Get the unchanging part of a release asset URL. Used to identify download attempts.
		 *
		 * @return string
		 */
		protected function getAssetApiBaseUrl() {
			return sprintf(
				'//api.github.com/repos/%1$s/%2$s/releases/assets/',
				$this->userName,
				$this->repositoryName
			);
		}

		protected function getFilterableAssetName($releaseAsset) {
			if ( isset($releaseAsset->name) ) {
				return $releaseAsset->name;
			}
			return null;
		}

		/**
		 * @param bool $result
		 * @return bool
		 * @internal
		 */
		public function addHttpRequestFilter($result) {
			if ( !$this->downloadFilterAdded && $this->isAuthenticationEnabled() ) {
				//phpcs:ignore WordPressVIPMinimum.Hooks.RestrictedHooks.http_request_args -- The callback doesn't change the timeout.
				add_filter('http_request_args', array($this, 'setUpdateDownloadHeaders'), 10, 2);
				add_action('requests-requests.before_redirect', array($this, 'removeAuthHeaderFromRedirects'), 10, 4);
				$this->downloadFilterAdded = true;
			}
			return $result;
		}

		/**
		 * Set the HTTP headers that are necessary to download updates from private repositories.
		 *
		 * See GitHub docs:
		 *
		 * @link https://developer.github.com/v3/repos/releases/#get-a-single-release-asset
		 * @link https://developer.github.com/v3/auth/#basic-authentication
		 *
		 * @internal
		 * @param array $requestArgs
		 * @param string $url
		 * @return array
		 */
		public function setUpdateDownloadHeaders($requestArgs, $url = '') {
			//Is WordPress trying to download one of our release assets?
			if ( $this->releaseAssetsEnabled && (strpos($url, $this->getAssetApiBaseUrl()) !== false) ) {
				$requestArgs['headers']['Accept'] = 'application/octet-stream';
			}
			//Use Basic authentication, but only if the download is from our repository.
			$repoApiBaseUrl = $this->buildApiUrl('/repos/:user/:repo/', array());
			if ( $this->isAuthenticationEnabled() && (strpos($url, $repoApiBaseUrl)) === 0 ) {
				$requestArgs['headers']['Authorization'] = $this->getAuthorizationHeader();
			}
			return $requestArgs;
		}

		/**
		 * When following a redirect, the Requests library will automatically forward
		 * the authorization header to other hosts. We don't want that because it breaks
		 * AWS downloads and can leak authorization information.
		 *
		 * @param string $location
		 * @param array $headers
		 * @internal
		 */
		public function removeAuthHeaderFromRedirects(&$location, &$headers) {
			$repoApiBaseUrl = $this->buildApiUrl('/repos/:user/:repo/', array());
			if ( strpos($location, $repoApiBaseUrl) === 0 ) {
				return; //This request is going to GitHub, so it's fine.
			}
			//Remove the header.
			if ( isset($headers['Authorization']) ) {
				unset($headers['Authorization']);
			}
		}

		/**
		 * Generate the value of the "Authorization" header.
		 *
		 * @return string
		 */
		protected function getAuthorizationHeader() {
			return 'Basic ' . base64_encode($this->userName . ':' . $this->accessToken);
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\GitLabApi.php (12135 bytes, 415 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !class_exists(GitLabApi::class, false) ):

	class GitLabApi extends Api {
		use ReleaseAssetSupport;
		use ReleaseFilteringFeature;

		/**
		 * @var string GitLab username.
		 */
		protected $userName;

		/**
		 * @var string GitLab server host.
		 */
		protected $repositoryHost;

		/**
		 * @var string Protocol used by this GitLab server: "http" or "https".
		 */
		protected $repositoryProtocol = 'https';

		/**
		 * @var string GitLab repository name.
		 */
		protected $repositoryName;

		/**
		 * @var string GitLab authentication token. Optional.
		 */
		protected $accessToken;

		/**
		 * @deprecated
		 * @var bool No longer used.
		 */
		protected $releasePackageEnabled = false;

		public function __construct($repositoryUrl, $accessToken = null, $subgroup = null) {
			//Parse the repository host to support custom hosts.
			$port = wp_parse_url($repositoryUrl, PHP_URL_PORT);
			if ( !empty($port) ) {
				$port = ':' . $port;
			}
			$this->repositoryHost = wp_parse_url($repositoryUrl, PHP_URL_HOST) . $port;

			if ( $this->repositoryHost !== 'gitlab.com' ) {
				$this->repositoryProtocol = wp_parse_url($repositoryUrl, PHP_URL_SCHEME);
			}

			//Find the repository information
			$path = wp_parse_url($repositoryUrl, PHP_URL_PATH);
			if ( preg_match('@^/?(?P<username>[^/]+?)/(?P<repository>[^/#?&]+?)/?$@', $path, $matches) ) {
				$this->userName = $matches['username'];
				$this->repositoryName = $matches['repository'];
			} elseif ( ($this->repositoryHost === 'gitlab.com') ) {
				//This is probably a repository in a subgroup, e.g. "/organization/category/repo".
				$parts = explode('/', trim($path, '/'));
				if ( count($parts) < 3 ) {
					throw new \InvalidArgumentException('Invalid GitLab.com repository URL: "' . $repositoryUrl . '"');
				}
				$lastPart = array_pop($parts);
				$this->userName = implode('/', $parts);
				$this->repositoryName = $lastPart;
			} else {
				//There could be subgroups in the URL:  gitlab.domain.com/group/subgroup/subgroup2/repository
				if ( $subgroup !== null ) {
					$path = str_replace(trailingslashit($subgroup), '', $path);
				}

				//This is not a traditional url, it could be gitlab is in a deeper subdirectory.
				//Get the path segments.
				$segments = explode('/', untrailingslashit(ltrim($path, '/')));

				//We need at least /user-name/repository-name/
				if ( count($segments) < 2 ) {
					throw new \InvalidArgumentException('Invalid GitLab repository URL: "' . $repositoryUrl . '"');
				}

				//Get the username and repository name.
				$usernameRepo = array_splice($segments, -2, 2);
				$this->userName = $usernameRepo[0];
				$this->repositoryName = $usernameRepo[1];

				//Append the remaining segments to the host if there are segments left.
				if ( count($segments) > 0 ) {
					$this->repositoryHost = trailingslashit($this->repositoryHost) . implode('/', $segments);
				}

				//Add subgroups to username.
				if ( $subgroup !== null ) {
					$this->userName = $usernameRepo[0] . '/' . untrailingslashit($subgroup);
				}
			}

			parent::__construct($repositoryUrl, $accessToken);
		}

		/**
		 * Get the latest release from GitLab.
		 *
		 * @return Reference|null
		 */
		public function getLatestRelease() {
			$releases = $this->api('/:id/releases', array('per_page' => $this->releaseFilterMaxReleases));
			if ( is_wp_error($releases) || empty($releases) || !is_array($releases) ) {
				return null;
			}

			foreach ($releases as $release) {
				if (
					//Skip invalid/unsupported releases.
					!is_object($release)
					|| !isset($release->tag_name)
					//Skip upcoming releases.
					|| (
						!empty($release->upcoming_release)
						&& $this->shouldSkipPreReleases()
					)
				) {
					continue;
				}

				$versionNumber = ltrim($release->tag_name, 'v'); //Remove the "v" prefix from "v1.2.3".

				//Apply custom filters.
				if ( !$this->matchesCustomReleaseFilter($versionNumber, $release) ) {
					continue;
				}

				$downloadUrl = $this->findReleaseDownloadUrl($release);
				if ( empty($downloadUrl) ) {
					//The latest release doesn't have valid download URL.
					return null;
				}

				if ( !empty($this->accessToken) ) {
					$downloadUrl = add_query_arg('private_token', $this->accessToken, $downloadUrl);
				}

				return new Reference(array(
					'name'        => $release->tag_name,
					'version'     => $versionNumber,
					'downloadUrl' => $downloadUrl,
					'updated'     => $release->released_at,
					'apiResponse' => $release,
				));
			}

			return null;
		}

		/**
		 * @param object $release
		 * @return string|null
		 */
		protected function findReleaseDownloadUrl($release) {
			if ( $this->releaseAssetsEnabled ) {
				if ( isset($release->assets, $release->assets->links) ) {
					//Use the first asset link where the URL matches the filter.
					foreach ($release->assets->links as $link) {
						if ( $this->matchesAssetFilter($link) ) {
							return $link->url;
						}
					}
				}

				if ( $this->releaseAssetPreference === Api::REQUIRE_RELEASE_ASSETS ) {
					//Falling back to source archives is not allowed, so give up.
					return null;
				}
			}

			//Use the first source code archive that's in ZIP format.
			foreach ($release->assets->sources as $source) {
				if ( isset($source->format) && ($source->format === 'zip') ) {
					return $source->url;
				}
			}

			return null;
		}

		/**
		 * Get the tag that looks like the highest version number.
		 *
		 * @return Reference|null
		 */
		public function getLatestTag() {
			$tags = $this->api('/:id/repository/tags');
			if ( is_wp_error($tags) || empty($tags) || !is_array($tags) ) {
				return null;
			}

			$versionTags = $this->sortTagsByVersion($tags);
			if ( empty($versionTags) ) {
				return null;
			}

			$tag = $versionTags[0];
			return new Reference(array(
				'name'        => $tag->name,
				'version'     => ltrim($tag->name, 'v'),
				'downloadUrl' => $this->buildArchiveDownloadUrl($tag->name),
				'apiResponse' => $tag,
			));
		}

		/**
		 * Get a branch by name.
		 *
		 * @param string $branchName
		 * @return null|Reference
		 */
		public function getBranch($branchName) {
			$branch = $this->api('/:id/repository/branches/' . $branchName);
			if ( is_wp_error($branch) || empty($branch) ) {
				return null;
			}

			$reference = new Reference(array(
				'name'        => $branch->name,
				'downloadUrl' => $this->buildArchiveDownloadUrl($branch->name),
				'apiResponse' => $branch,
			));

			if ( isset($branch->commit, $branch->commit->committed_date) ) {
				$reference->updated = $branch->commit->committed_date;
			}

			return $reference;
		}

		/**
		 * Get the timestamp of the latest commit that changed the specified branch or tag.
		 *
		 * @param string $ref Reference name (e.g. branch or tag).
		 * @return string|null
		 */
		public function getLatestCommitTime($ref) {
			$commits = $this->api('/:id/repository/commits/', array('ref_name' => $ref));
			if ( is_wp_error($commits) || !is_array($commits) || !isset($commits[0]) ) {
				return null;
			}

			return $commits[0]->committed_date;
		}

		/**
		 * Perform a GitLab API request.
		 *
		 * @param string $url
		 * @param array $queryParams
		 * @return mixed|\WP_Error
		 */
		protected function api($url, $queryParams = array()) {
			$baseUrl = $url;
			$url = $this->buildApiUrl($url, $queryParams);

			$options = array('timeout' => wp_doing_cron() ? 10 : 3);
			if ( !empty($this->httpFilterName) ) {
				$options = apply_filters($this->httpFilterName, $options);
			}

			$response = wp_remote_get($url, $options);
			if ( is_wp_error($response) ) {
				do_action('puc_api_error', $response, null, $url, $this->slug);
				return $response;
			}

			$code = wp_remote_retrieve_response_code($response);
			$body = wp_remote_retrieve_body($response);
			if ( $code === 200 ) {
				return json_decode($body);
			}

			$error = new \WP_Error(
				'puc-gitlab-http-error',
				sprintf('GitLab API error. URL: "%s",  HTTP status code: %d.', $baseUrl, $code)
			);
			do_action('puc_api_error', $error, $response, $url, $this->slug);

			return $error;
		}

		/**
		 * Build a fully qualified URL for an API request.
		 *
		 * @param string $url
		 * @param array $queryParams
		 * @return string
		 */
		protected function buildApiUrl($url, $queryParams) {
			$variables = array(
				'user' => $this->userName,
				'repo' => $this->repositoryName,
				'id'   => $this->userName . '/' . $this->repositoryName,
			);

			foreach ($variables as $name => $value) {
				$url = str_replace("/:{$name}", '/' . urlencode($value), $url);
			}

			$url = substr($url, 1);
			$url = sprintf('%1$s://%2$s/api/v4/projects/%3$s', $this->repositoryProtocol, $this->repositoryHost, $url);

			if ( !empty($this->accessToken) ) {
				$queryParams['private_token'] = $this->accessToken;
			}

			if ( !empty($queryParams) ) {
				$url = add_query_arg($queryParams, $url);
			}

			return $url;
		}

		/**
		 * Get the contents of a file from a specific branch or tag.
		 *
		 * @param string $path File name.
		 * @param string $ref
		 * @return null|string Either the contents of the file, or null if the file doesn't exist or there's an error.
		 */
		public function getRemoteFile($path, $ref = 'master') {
			$response = $this->api('/:id/repository/files/' . $path, array('ref' => $ref));
			if ( is_wp_error($response) || !isset($response->content) || $response->encoding !== 'base64' ) {
				return null;
			}

			return base64_decode($response->content);
		}

		/**
		 * Generate a URL to download a ZIP archive of the specified branch/tag/etc.
		 *
		 * @param string $ref
		 * @return string
		 */
		public function buildArchiveDownloadUrl($ref = 'master') {
			$url = sprintf(
				'%1$s://%2$s/api/v4/projects/%3$s/repository/archive.zip',
				$this->repositoryProtocol,
				$this->repositoryHost,
				urlencode($this->userName . '/' . $this->repositoryName)
			);
			$url = add_query_arg('sha', urlencode($ref), $url);

			if ( !empty($this->accessToken) ) {
				$url = add_query_arg('private_token', $this->accessToken, $url);
			}

			return $url;
		}

		/**
		 * Get a specific tag.
		 *
		 * @param string $tagName
		 * @return void
		 */
		public function getTag($tagName) {
			throw new \LogicException('The ' . __METHOD__ . ' method is not implemented and should not be used.');
		}

		protected function getUpdateDetectionStrategies($configBranch) {
			$strategies = array();

			if ( ($configBranch === 'main') || ($configBranch === 'master') ) {
				$strategies[self::STRATEGY_LATEST_RELEASE] = array($this, 'getLatestRelease');
				$strategies[self::STRATEGY_LATEST_TAG] = array($this, 'getLatestTag');
			}

			$strategies[self::STRATEGY_BRANCH] = function () use ($configBranch) {
				return $this->getBranch($configBranch);
			};

			return $strategies;
		}

		public function setAuthentication($credentials) {
			parent::setAuthentication($credentials);
			$this->accessToken = is_string($credentials) ? $credentials : null;
		}

		/**
		 * Use release assets that link to GitLab generic packages (e.g. .zip files)
		 * instead of automatically generated source archives.
		 *
		 * This is included for backwards compatibility with older versions of PUC.
		 *
		 * @return void
		 * @deprecated   Use enableReleaseAssets() instead.
		 * @noinspection PhpUnused -- Public API
		 */
		public function enableReleasePackages() {
			$this->enableReleaseAssets(
			/** @lang RegExp */ '/\.zip($|[?&#])/i',
				Api::REQUIRE_RELEASE_ASSETS
			);
		}

		protected function getFilterableAssetName($releaseAsset) {
			if ( isset($releaseAsset->url) ) {
				return $releaseAsset->url;
			}
			return null;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\PluginUpdateChecker.php (9381 bytes, 276 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

use YahnisElsts\PluginUpdateChecker\v5p6\Plugin;

if ( !class_exists(PluginUpdateChecker::class, false) ):

	class PluginUpdateChecker extends Plugin\UpdateChecker implements BaseChecker {
		use VcsCheckerMethods;

		/**
		 * PluginUpdateChecker constructor.
		 *
		 * @param Api $api
		 * @param string $pluginFile
		 * @param string $slug
		 * @param int $checkPeriod
		 * @param string $optionName
		 * @param string $muPluginFile
		 */
		public function __construct($api, $pluginFile, $slug = '', $checkPeriod = 12, $optionName = '', $muPluginFile = '') {
			$this->api = $api;

			parent::__construct($api->getRepositoryUrl(), $pluginFile, $slug, $checkPeriod, $optionName, $muPluginFile);

			$this->api->setHttpFilterName($this->getUniqueName('request_info_options'));
			$this->api->setStrategyFilterName($this->getUniqueName('vcs_update_detection_strategies'));
			$this->api->setSlug($this->slug);
		}

		public function requestInfo($unusedParameter = null) {
			//We have to make several remote API requests to gather all the necessary info
			//which can take a while on slow networks.
			if ( function_exists('set_time_limit') ) {
				@set_time_limit(60);
			}

			$api = $this->api;
			$api->setLocalDirectory($this->package->getAbsoluteDirectoryPath());

			$info = new Plugin\PluginInfo();
			$info->filename = $this->pluginFile;
			$info->slug = $this->slug;

			$this->setInfoFromHeader($this->package->getPluginHeader(), $info);
			$this->setIconsFromLocalAssets($info);
			$this->setBannersFromLocalAssets($info);

			//Pick a branch or tag.
			$updateSource = $api->chooseReference($this->branch);
			if ( $updateSource ) {
				$ref = $updateSource->name;
				$info->version = $updateSource->version;
				$info->last_updated = $updateSource->updated;
				$info->download_url = $updateSource->downloadUrl;

				if ( !empty($updateSource->changelog) ) {
					$info->sections['changelog'] = $updateSource->changelog;
				}
				if ( isset($updateSource->downloadCount) ) {
					$info->downloaded = $updateSource->downloadCount;
				}
			} else {
				//There's probably a network problem or an authentication error.
				do_action(
					'puc_api_error',
					new \WP_Error(
						'puc-no-update-source',
						'Could not retrieve version information from the repository. '
						. 'This usually means that the update checker either can\'t connect '
						. 'to the repository or it\'s configured incorrectly.'
					),
					null, null, $this->slug
				);
				return null;
			}

			//Get headers from the main plugin file in this branch/tag. Its "Version" header and other metadata
			//are what the WordPress install will actually see after upgrading, so they take precedence over releases/tags.
			$mainPluginFile = basename($this->pluginFile);
			$remotePlugin = $api->getRemoteFile($mainPluginFile, $ref);
			if ( !empty($remotePlugin) ) {
				$remoteHeader = $this->package->getFileHeader($remotePlugin);
				$this->setInfoFromHeader($remoteHeader, $info);
			}

			//Sanity check: Reject updates that don't have a version number.
			//This can happen when we're using a branch, and we either fail to retrieve the main plugin
			//file or the file doesn't have a "Version" header.
			if ( empty($info->version) ) {
				do_action(
					'puc_api_error',
					new \WP_Error(
						'puc-no-plugin-version',
						'Could not find the version number in the repository.'
					),
					null, null, $this->slug
				);
				return null;
			}

			//Try parsing readme.txt. If it's formatted according to WordPress.org standards, it will contain
			//a lot of useful information like the required/tested WP version, changelog, and so on.
			if ( $this->readmeTxtExistsLocally() ) {
				$this->setInfoFromRemoteReadme($ref, $info);
			}

			//The changelog might be in a separate file.
			if ( empty($info->sections['changelog']) ) {
				$info->sections['changelog'] = $api->getRemoteChangelog($ref, $this->package->getAbsoluteDirectoryPath());
				if ( empty($info->sections['changelog']) ) {
					$info->sections['changelog'] = __('There is no changelog available.', 'plugin-update-checker');
				}
			}

			if ( empty($info->last_updated) ) {
				//Fetch the latest commit that changed the tag or branch and use it as the "last_updated" date.
				$latestCommitTime = $api->getLatestCommitTime($ref);
				if ( $latestCommitTime !== null ) {
					$info->last_updated = $latestCommitTime;
				}
			}

			$info = apply_filters($this->getUniqueName('request_info_result'), $info, null);
			return $info;
		}

		/**
		 * Check if the currently installed version has a readme.txt file.
		 *
		 * @return bool
		 */
		protected function readmeTxtExistsLocally() {
			return $this->package->fileExists($this->api->getLocalReadmeName());
		}

		/**
		 * Copy plugin metadata from a file header to a Plugin Info object.
		 *
		 * @param array $fileHeader
		 * @param Plugin\PluginInfo $pluginInfo
		 */
		protected function setInfoFromHeader($fileHeader, $pluginInfo) {
			$headerToPropertyMap = array(
				'Version' => 'version',
				'Name' => 'name',
				'PluginURI' => 'homepage',
				'Author' => 'author',
				'AuthorName' => 'author',
				'AuthorURI' => 'author_homepage',

				'Requires WP' => 'requires',
				'Tested WP' => 'tested',
				'Requires at least' => 'requires',
				'Tested up to' => 'tested',

				'Requires PHP' => 'requires_php',
			);
			foreach ($headerToPropertyMap as $headerName => $property) {
				if ( isset($fileHeader[$headerName]) && !empty($fileHeader[$headerName]) ) {
					$pluginInfo->$property = $fileHeader[$headerName];
				}
			}

			if ( !empty($fileHeader['Description']) ) {
				$pluginInfo->sections['description'] = $fileHeader['Description'];
			}
		}

		/**
		 * Copy plugin metadata from the remote readme.txt file.
		 *
		 * @param string $ref GitHub tag or branch where to look for the readme.
		 * @param Plugin\PluginInfo $pluginInfo
		 */
		protected function setInfoFromRemoteReadme($ref, $pluginInfo) {
			$readme = $this->api->getRemoteReadme($ref);
			if ( empty($readme) ) {
				return;
			}

			if ( isset($readme['sections']) ) {
				$pluginInfo->sections = array_merge($pluginInfo->sections, $readme['sections']);
			}
			if ( !empty($readme['tested_up_to']) ) {
				$pluginInfo->tested = $readme['tested_up_to'];
			}
			if ( !empty($readme['requires_at_least']) ) {
				$pluginInfo->requires = $readme['requires_at_least'];
			}
			if ( !empty($readme['requires_php']) ) {
				$pluginInfo->requires_php = $readme['requires_php'];
			}

			if ( isset($readme['upgrade_notice'], $readme['upgrade_notice'][$pluginInfo->version]) ) {
				$pluginInfo->upgrade_notice = $readme['upgrade_notice'][$pluginInfo->version];
			}
		}

		/**
		 * Add icons from the currently installed version to a Plugin Info object.
		 *
		 * The icons should be in a subdirectory named "assets". Supported image formats
		 * and file names are described here:
		 * @link https://developer.wordpress.org/plugins/wordpress-org/plugin-assets/#plugin-icons
		 *
		 * @param Plugin\PluginInfo $pluginInfo
		 */
		protected function setIconsFromLocalAssets($pluginInfo) {
			$icons = $this->getLocalAssetUrls(array(
				'icon.svg'         => 'svg',
				'icon-256x256.png' => '2x',
				'icon-256x256.jpg' => '2x',
				'icon-128x128.png' => '1x',
				'icon-128x128.jpg' => '1x',
			));

			if ( !empty($icons) ) {
				//The "default" key seems to be used only as last-resort fallback in WP core (5.8/5.9),
				//but we'll set it anyway in case some code somewhere needs it.
				reset($icons);
				$firstKey = key($icons);
				$icons['default'] = $icons[$firstKey];

				$pluginInfo->icons = $icons;
			}
		}

		/**
		 * Add banners from the currently installed version to a Plugin Info object.
		 *
		 * The banners should be in a subdirectory named "assets". Supported image formats
		 * and file names are described here:
		 * @link https://developer.wordpress.org/plugins/wordpress-org/plugin-assets/#plugin-headers
		 *
		 * @param Plugin\PluginInfo $pluginInfo
		 */
		protected function setBannersFromLocalAssets($pluginInfo) {
			$banners = $this->getLocalAssetUrls(array(
				'banner-772x250.png' => 'high',
				'banner-772x250.jpg' => 'high',
				'banner-1544x500.png' => 'low',
				'banner-1544x500.jpg' => 'low',
			));

			if ( !empty($banners) ) {
				$pluginInfo->banners = $banners;
			}
		}

		/**
		 * @param array<string, string> $filesToKeys
		 * @return array<string, string>
		 */
		protected function getLocalAssetUrls($filesToKeys) {
			$assetDirectory = $this->package->getAbsoluteDirectoryPath() . DIRECTORY_SEPARATOR . 'assets';
			if ( !is_dir($assetDirectory) ) {
				return array();
			}
			$assetBaseUrl = trailingslashit(plugins_url('', $assetDirectory . '/imaginary.file'));

			$foundAssets = array();
			foreach ($filesToKeys as $fileName => $key) {
				$fullBannerPath = $assetDirectory . DIRECTORY_SEPARATOR . $fileName;
				if ( !isset($icons[$key]) && is_file($fullBannerPath) ) {
					$foundAssets[$key] = $assetBaseUrl . $fileName;
				}
			}

			return $foundAssets;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\Reference.php (1173 bytes, 52 lines) =====
`$ext
<?php
namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !class_exists(Reference::class, false) ):

	/**
	 * This class represents a VCS branch or tag. It's intended as a read only, short-lived container
	 * that only exists to provide a limited degree of type checking.
	 *
	 * @property string $name
	 * @property string|null version
	 * @property string $downloadUrl
	 * @property string $updated
	 *
	 * @property string|null $changelog
	 * @property int|null $downloadCount
	 */
	class Reference {
		private $properties = array();

		public function __construct($properties = array()) {
			$this->properties = $properties;
		}

		/**
		 * @param string $name
		 * @return mixed|null
		 */
		public function __get($name) {
			return array_key_exists($name, $this->properties) ? $this->properties[$name] : null;
		}

		/**
		 * @param string $name
		 * @param mixed $value
		 */
		public function __set($name, $value) {
			$this->properties[$name] = $value;
		}

		/**
		 * @param string $name
		 * @return bool
		 */
		public function __isset($name) {
			return isset($this->properties[$name]);
		}

	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\ReleaseAssetSupport.php (2465 bytes, 83 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !trait_exists(ReleaseAssetSupport::class, false) ) :

	trait ReleaseAssetSupport {
		/**
		 * @var bool Whether to download release assets instead of the auto-generated
		 *           source code archives.
		 */
		protected $releaseAssetsEnabled = false;

		/**
		 * @var string|null Regular expression that's used to filter release assets
		 *                  by file name or URL. Optional.
		 */
		protected $assetFilterRegex = null;

		/**
		 * How to handle releases that don't have any matching release assets.
		 *
		 * @var int
		 */
		protected $releaseAssetPreference = Api::PREFER_RELEASE_ASSETS;

		/**
		 * Enable updating via release assets.
		 *
		 * If the latest release contains no usable assets, the update checker
		 * will fall back to using the automatically generated ZIP archive.
		 *
		 * @param string|null $nameRegex Optional. Use only those assets where
		 *                               the file name or URL matches this regex.
		 * @param int $preference Optional. How to handle releases that don't have
		 *                        any matching release assets.
		 */
		public function enableReleaseAssets($nameRegex = null, $preference = Api::PREFER_RELEASE_ASSETS) {
			$this->releaseAssetsEnabled = true;
			$this->assetFilterRegex = $nameRegex;
			$this->releaseAssetPreference = $preference;
		}

		/**
		 * Disable release assets.
		 *
		 * @return void
		 * @noinspection PhpUnused -- Public API
		 */
		public function disableReleaseAssets() {
			$this->releaseAssetsEnabled = false;
			$this->assetFilterRegex = null;
		}

		/**
		 * Does the specified asset match the name regex?
		 *
		 * @param mixed $releaseAsset Data type and structure depend on the host/API.
		 * @return bool
		 */
		protected function matchesAssetFilter($releaseAsset) {
			if ( $this->assetFilterRegex === null ) {
				//The default is to accept all assets.
				return true;
			}

			$name = $this->getFilterableAssetName($releaseAsset);
			if ( !is_string($name) ) {
				return false;
			}
			return (bool)preg_match($this->assetFilterRegex, $releaseAsset->name);
		}

		/**
		 * Get the part of asset data that will be checked against the filter regex.
		 *
		 * @param mixed $releaseAsset
		 * @return string|null
		 */
		abstract protected function getFilterableAssetName($releaseAsset);
	}

endif;
`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\ReleaseFilteringFeature.php (3287 bytes, 108 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !trait_exists(ReleaseFilteringFeature::class, false) ) :

	trait ReleaseFilteringFeature {
		/**
		 * @var callable|null
		 */
		protected $releaseFilterCallback = null;
		/**
		 * @var int
		 */
		protected $releaseFilterMaxReleases = 1;
		/**
		 * @var string One of the Api::RELEASE_FILTER_* constants.
		 */
		protected $releaseFilterByType = Api::RELEASE_FILTER_SKIP_PRERELEASE;

		/**
		 * Set a custom release filter.
		 *
		 * Setting a new filter will override the old filter, if any.
		 *
		 * @param callable $callback A callback that accepts a version number and a release
		 *                           object, and returns a boolean.
		 * @param int $releaseTypes  One of the Api::RELEASE_FILTER_* constants.
		 * @param int $maxReleases   Optional. The maximum number of recent releases to examine
		 *                           when trying to find a release that matches the filter. 1 to 100.
		 * @return $this
		 */
		public function setReleaseFilter(
			$callback,
			$releaseTypes = Api::RELEASE_FILTER_SKIP_PRERELEASE,
			$maxReleases = 20
		) {
			if ( $maxReleases > 100 ) {
				throw new \InvalidArgumentException(sprintf(
					'The max number of releases is too high (%d). It must be 100 or less.',
					$maxReleases
				));
			} else if ( $maxReleases < 1 ) {
				throw new \InvalidArgumentException(sprintf(
					'The max number of releases is too low (%d). It must be at least 1.',
					$maxReleases
				));
			}

			$this->releaseFilterCallback = $callback;
			$this->releaseFilterByType = $releaseTypes;
			$this->releaseFilterMaxReleases = $maxReleases;
			return $this;
		}

		/**
		 * Filter releases by their version number.
		 *
		 * @param string $regex A regular expression. The release version number must match this regex.
		 * @param int $releaseTypes
		 * @param int $maxReleasesToExamine
		 * @return $this
		 * @noinspection PhpUnused -- Public API
		 */
		public function setReleaseVersionFilter(
			$regex,
			$releaseTypes = Api::RELEASE_FILTER_SKIP_PRERELEASE,
			$maxReleasesToExamine = 20
		) {
			return $this->setReleaseFilter(
				function ($versionNumber) use ($regex) {
					return (preg_match($regex, $versionNumber) === 1);
				},
				$releaseTypes,
				$maxReleasesToExamine
			);
		}

		/**
		 * @param string $versionNumber The detected release version number.
		 * @param object $releaseObject Varies depending on the host/API.
		 * @return bool
		 */
		protected function matchesCustomReleaseFilter($versionNumber, $releaseObject) {
			if ( !is_callable($this->releaseFilterCallback) ) {
				return true; //No custom filter.
			}
			return call_user_func($this->releaseFilterCallback, $versionNumber, $releaseObject);
		}

		/**
		 * @return bool
		 */
		protected function shouldSkipPreReleases() {
			//Maybe this could be a bitfield in the future, if we need to support
			//more release types.
			return ($this->releaseFilterByType !== Api::RELEASE_FILTER_ALL);
		}

		/**
		 * @return bool
		 */
		protected function hasCustomReleaseFilter() {
			return isset($this->releaseFilterCallback) && is_callable($this->releaseFilterCallback);
		}
	}

endif;
`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\ThemeUpdateChecker.php (2786 bytes, 84 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

use YahnisElsts\PluginUpdateChecker\v5p6\Theme;
use YahnisElsts\PluginUpdateChecker\v5p6\Utils;

if ( !class_exists(ThemeUpdateChecker::class, false) ):

	class ThemeUpdateChecker extends Theme\UpdateChecker implements BaseChecker {
		use VcsCheckerMethods;

		/**
		 * ThemeUpdateChecker constructor.
		 *
		 * @param Api $api
		 * @param null $stylesheet
		 * @param null $customSlug
		 * @param int $checkPeriod
		 * @param string $optionName
		 */
		public function __construct($api, $stylesheet = null, $customSlug = null, $checkPeriod = 12, $optionName = '') {
			$this->api = $api;

			parent::__construct($api->getRepositoryUrl(), $stylesheet, $customSlug, $checkPeriod, $optionName);

			$this->api->setHttpFilterName($this->getUniqueName('request_update_options'));
			$this->api->setStrategyFilterName($this->getUniqueName('vcs_update_detection_strategies'));
			$this->api->setSlug($this->slug);
		}

		public function requestUpdate() {
			$api = $this->api;
			$api->setLocalDirectory($this->package->getAbsoluteDirectoryPath());

			$update = new Theme\Update();
			$update->slug = $this->slug;

			//Figure out which reference (tag or branch) we'll use to get the latest version of the theme.
			$updateSource = $api->chooseReference($this->branch);
			if ( $updateSource ) {
				$ref = $updateSource->name;
				$update->download_url = $updateSource->downloadUrl;
			} else {
				do_action(
					'puc_api_error',
					new \WP_Error(
						'puc-no-update-source',
						'Could not retrieve version information from the repository. '
						. 'This usually means that the update checker either can\'t connect '
						. 'to the repository or it\'s configured incorrectly.'
					),
					null, null, $this->slug
				);
				$ref = $this->branch;
			}

			//Get headers from the main stylesheet in this branch/tag. Its "Version" header and other metadata
			//are what the WordPress install will actually see after upgrading, so they take precedence over releases/tags.
			$remoteHeader = $this->package->getFileHeader($api->getRemoteFile('style.css', $ref));
			$update->version = Utils::findNotEmpty(array(
				$remoteHeader['Version'],
				Utils::get($updateSource, 'version'),
			));

			//The details URL defaults to the Theme URI header or the repository URL.
			$update->details_url = Utils::findNotEmpty(array(
				$remoteHeader['ThemeURI'],
				$this->package->getHeaderValue('ThemeURI'),
				$this->metadataUrl,
			));

			if ( empty($update->version) ) {
				//It looks like we didn't find a valid update after all.
				$update = null;
			}

			$update = $this->filterUpdateResult($update);
			return $update;
		}
	}

endif;

`$nl
===== FILE: berrywalk-feedback\plugin-update-checker\Puc\v5p6\Vcs\VcsCheckerMethods.php (1344 bytes, 59 lines) =====
`$ext
<?php

namespace YahnisElsts\PluginUpdateChecker\v5p6\Vcs;

if ( !trait_exists(VcsCheckerMethods::class, false) ) :

	trait VcsCheckerMethods {
		/**
		 * @var string The branch where to look for updates. Defaults to "master".
		 */
		protected $branch = 'master';

		/**
		 * @var Api Repository API client.
		 */
		protected $api = null;

		public function setBranch($branch) {
			$this->branch = $branch;
			return $this;
		}

		/**
		 * Set authentication credentials.
		 *
		 * @param array|string $credentials
		 * @return $this
		 */
		public function setAuthentication($credentials) {
			$this->api->setAuthentication($credentials);
			return $this;
		}

		/**
		 * @return Api
		 */
		public function getVcsApi() {
			return $this->api;
		}

		public function getUpdate() {
			$update = parent::getUpdate();

			if ( isset($update) && !empty($update->download_url) ) {
				$update->download_url = $this->api->signDownloadUrl($update->download_url);
			}

			return $update;
		}

		public function onDisplayConfiguration($panel) {
			parent::onDisplayConfiguration($panel);
			$panel->row('Branch', $this->branch);
			$panel->row('Authentication enabled', $this->api->isAuthenticationEnabled() ? 'Yes' : 'No');
			$panel->row('API client', get_class($this->api));
		}
	}

endif;
`$nl
===== FILE: berrywalk-feedback\public\css\style.css (20714 bytes, 345 lines) =====
`$ext
/* =======================================================================================
   Berrywalk Feedback - Global Form Styles  (네임스페이스: .bwf-*)
   목적: 플러그인 전역 폼 스타일 공통 규격 + 대표 질문지 전용 오버라이드
   사용 원칙
   - 전역 규칙은 .bwf-* 클래스로 한정(테마에 영향 최소화)
   - 대표 질문지 화면은 .bwf-owner 클래스 하위에서만 오버라이드
   - 하단의 v2 오버라이드가 앞선 규칙보다 우선(캐스케이딩)
   ======================================================================================= */


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Design tokens]  테마 색·간격 토큰 (필요 시 여기만 바꿔 전역 톤 조절)
   ────────────────────────────────────────────────────────────────────────────────────── */
:root{
  --bwf-accent1:#0ea5e9;   /* 주요 그라데이션 1 (하늘색) */
  --bwf-accent2:#6366f1;   /* 주요 그라데이션 2 (인디고) */
  --bwf-success:#16a34a;   /* 성공/충족(OK) 색 */
  --bwf-danger:#ef4444;    /* 오류/경고 색 */
  --bwf-text:#0f172a;      /* 본문 텍스트 기본 */
  --bwf-muted:#f3f4f6;     /* 옅은 배경 */
  --bwf-muted-2:#eef2f7;   /* 진행바 등 보조 배경 */
  --bwf-border:#e5e7eb;    /* 경계선 색 */
  --bwf-label:#475569;     /* 라벨/보조 텍스트 */
}


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Layout / Typography]  폼 컨테이너 및 기본 타이포
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-form{
  /* 컨테이너 박스 */
  box-sizing:border-box;
  max-width:880px;
  margin:24px auto 56px;
  padding:24px;
  background:#fff;
  border-radius:16px;
  box-shadow:0 6px 20px rgba(0,0,0,.06);

  /* 폰트/가독성 */
  font-family:"Pretendard","Apple SD Gothic Neo",system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
  font-size:16.5px; line-height:1.7; color:var(--bwf-text);
}

.bwf-title{
  /* 페이지/폼 타이틀 */
  text-align:center; margin:4px 0 10px;
  font-weight:800; letter-spacing:-.2px;
}

.bwf-required-note{ /* “* 표시는 필수 입력” 안내 라인 */
  text-align:center; color:#6b7280; margin:0 0 14px;
}

/* 2열 그리드(회원가입 등) */
.bwf-grid{ display:grid; grid-template-columns:1fr 1fr; gap:14px; }
.bwf-col-full{ grid-column:1 / -1; } /* 그리드 전체 폭 차지 */
@media (max-width:768px){
  .bwf-grid{ grid-template-columns:1fr; } /* 모바일 1열 */
}

/* 기본 제목/라벨 */
.bwf-form h2,.bwf-form h3{ margin:32px 0 14px; }
.bwf-form h3{ font-size:28px; font-weight:800; margin:8px 0 18px; }
.bwf-form label{
  display:block; font-size:16px; font-weight:700;
  margin:16px 0 8px; color:var(--bwf-label);
}
.bwf-help{ font-size:13.5px; color:#64748b; margin:6px 0 10px; } /* 안내문 */
.bwf-required{ color:var(--bwf-danger); } /* 라벨 옆 * 색상 */


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Inputs]  입력 필드 공통 규격
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-form input,
.bwf-form select,
.bwf-form textarea{
  width:100%; box-sizing:border-box;
  padding:12px 14px;                    /* 손가락 터치 간격 확보 */
  border:1px solid #d1d5db;
  border-radius:10px;
  font-size:15px;
  background:#fff;
  transition:border-color .2s, box-shadow .2s; /* 포커스 부드럽게 */
}
.bwf-form textarea{ min-height:120px; resize:vertical; } /* 내용영역 */
.bwf-form input:focus,
.bwf-form select:focus,
.bwf-form textarea:focus{
  /* 접근성 고려 포커스 링 */
  border-color:var(--bwf-accent2);
  box-shadow:0 0 0 3px rgba(99,102,241,.2);
  outline:0;
}


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Actions / Buttons]  제출/보조 버튼
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-actions{ display:flex; justify-content:center; gap:10px; margin-top:18px; }
.bwf-btn, .bwf-btn-secondary, .bwf-form button[type="submit"]{
  display:inline-flex; justify-content:center; align-items:center;
  min-width:200px; height:52px; padding:0 22px;
  border-radius:12px; border:1px solid transparent; cursor:pointer;
  font-weight:700; line-height:1; text-decoration:none;
}
.bwf-btn, .bwf-form button[type="submit"]{
  background:linear-gradient(90deg,var(--bwf-accent2),var(--bwf-accent1));
  color:#fff; border-color:transparent;
}
.bwf-btn:hover, .bwf-form button[type="submit"]{ filter:brightness(.98); }
.bwf-btn-secondary{
  background:#f3f4f6; color:#111827; border-color:#e5e7eb;
  min-width:auto; height:40px; padding:0 12px;
}
.bwf-btn-secondary:hover{ background:#e5e7eb; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Divider]  섹션 구분선
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-form hr{ border:0; border-top:1px solid #eee; margin:8px 0; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Progress]  질문 폼 진행 현황(상단 스티키 바)
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-sticky{ position:sticky; top:0; background:#fff; z-index:40; padding:12px 0 8px; }
.bwf-topcount{ display:flex; justify-content:flex-end; margin:0 0 6px; font-size:12px; color:#6b7280; }
#bwf-progress{ position:relative; height:10px; background:var(--bwf-muted-2); border-radius:999px; overflow:hidden; }
#bwf-progress .bar{ position:absolute; left:0; top:0; height:100%; width:0%; background:linear-gradient(90deg,var(--bwf-accent1),var(--bwf-accent2)); }
#bwf-progress .label{ position:absolute; top:-22px; right:10px; font-size:12px; color:#64748b; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Helper]  글자수 카운터/OK 상태
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-helper{
  display:flex; justify-content:space-between; align-items:center;
  gap:8px; margin-top:6px; font-size:12px; color:#64748b;
}
.bwf-helper .bwf-counter{ font-variant-numeric:tabular-nums; } /* 숫자 폭 고정 */
.bwf-helper.ok{ color:var(--bwf-success); } /* 충족 시 녹색 */


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Validation / Error]  유효성 시각 피드백
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-invalid, .bwf-form [aria-invalid="true"]{
  border-color:var(--bwf-danger) !important;
  box-shadow:0 0 0 3px rgba(239,68,68,.15) !important;
}
.bwf-error{ color:var(--bwf-danger); margin-top:4px; width:100%; }
.bwf-error-text{ color:var(--bwf-danger); margin-bottom:8px; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Modal]  클라이언트/서버 검증 에러 팝업
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-modal{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; background:rgba(0,0,0,.35); z-index:10000; }
.bwf-modal.is-open{ display:flex; }
.bwf-modal__card{ width:min(440px,92vw); background:#fff; border:1px solid var(--bwf-border); border-radius:16px; padding:18px; }
.bwf-modal__card h3{ margin:0 0 8px; font-size:18px; }
.bwf-modal__msg{ color:#475569; margin:0 0 12px; }
.bwf-modal__actions{ text-align:right; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Lists]  마이페이지 리스트/카드
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-list{ list-style:none; padding:0; margin:12px 0; display:flex; flex-direction:column; gap:10px; }
.bwf-list li{ display:flex; gap:10px; align-items:center; border:1px solid #e2e8f0; border-radius:8px; padding:10px 12px; }
.bwf-list .bwf-time{ color:#64748b; min-width:170px; }
.bwf-list .bwf-sum{ flex:1; color:#0f172a; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

/* Pagination(목록 하단) */
.bwf-pager{ display:flex; gap:8px; align-items:center; justify-content:center; margin-top:10px; }
.bwf-pager .bwf-page{ color:#475569; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [View Wrapper]  상세보기 카드 + 푸터 간섭 방지
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-view{ box-sizing:border-box; max-width:880px; margin:24px auto 56px; padding:0 12px; }
.bwf-card{ background:#fff; border:1px solid var(--bwf-border); border-radius:12px; padding:16px 18px; margin-bottom:16px; }
.bwf-kv{ list-style:none; padding:0; margin:0; }
.bwf-kv li{ display:flex; gap:12px; padding:6px 0; border-bottom:1px dashed #e5e7eb; }
.bwf-kv b{ min-width:110px; color:#64748b; }
.bwf-bullets{ list-style:disc; padding-left:18px; margin:0; }


/* ──────────────────────────────────────────────────────────────────────────────────────
   [Signup Only]  회원가입 폼(.bwf-grid)에서만 진행바 숨김/버튼 크기
   ────────────────────────────────────────────────────────────────────────────────────── */
.bwf-form.bwf-grid .bwf-topcount,
.bwf-form.bwf-grid #bwf-progress{ display:none !important; } /* 질문 폼엔 영향 없음 */

.bwf-form.bwf-grid .bwf-actions{ margin:28px 0 8px; }
.bwf-form.bwf-grid .bwf-actions button{
  width:100%; max-width:440px; height:56px; font-size:18px; border-radius:14px;
}

/* 링크형 중립 버튼 줄바꿈 방지 */
a.bwf-btn-secondary{ white-space:nowrap; }

/* 스몰 유틸 */
.bwf-hidden{ display:none !important; }



/* =======================================================================================
   대표 질문지 전용 오버라이드 (.bwf-owner)
   목적
   - 1열 레이아웃 유지
   - 진행바/카운터 강제 노출
   - 설명/예시 타이포를 폼과 분리된 톤으로 정리
   주의: 아래 블록은 “대표 질문지 페이지”에서만 적용됨
   ======================================================================================= */

/* [Top Sticky] 진행바 래퍼 */
.bwf-owner { padding-top: 10px; }
.bwf-owner .bwf-topwrap{
  position: sticky; top: 0; z-index: 40;
  background:#fff; padding:12px 14px 16px;
  border-bottom:1px solid #eee; margin:0 0 18px;
}
.bwf-owner .bwf-top-title{ font-weight:700; margin-bottom:8px; }

/* 진행바 그래픽 */
.bwf-owner #bwf-progress{ position:relative; height:10px; background:#f1f5f9; border-radius:999px; overflow:hidden; }
.bwf-owner #bwf-progress .bar{ position:absolute; left:0; top:0; height:100%; width:0%; background:linear-gradient(90deg,#0ea5e9,#6366f1); }
.bwf-owner #bwf-progress .label{ position:absolute; right:10px; top:-22px; font-size:12px; color:#64748b; }
.bwf-owner .bwf-topwrap .done, .bwf-owner .bwf-topwrap .total { font-variant-numeric: tabular-nums; }

/* 질문 섹션 박스/타이포 */
.bwf-owner .bwf-field{ margin-bottom:22px; }
.bwf-owner .bwf-field label{
  display:block; font-size:18px; font-weight:800; margin:12px 0 8px; color:#111827;
}
.bwf-owner .bwf-desc{ font-size:14.5px; color:#475569; margin:-2px 0 8px; } /* 설명문 */
.bwf-owner .bwf-examples{
  /* 예시 박스: 옅은 톤 + 둥근 모서리 */
  background:#fafafa; border:1px solid #eef2f7; border-radius:10px;
  padding:10px 12px; margin:4px 0 10px;
}
.bwf-owner .bwf-examples strong{ color:#0f172a; }
.bwf-owner .bwf-examples ul{ margin:6px 0 0 18px; }
.bwf-owner .bwf-examples ol{ margin:6px 0 0 18px; }

/* 입력 필드(대표폼) */
.bwf-owner textarea,
.bwf-owner input[type="text"]{
  width:100%; padding:12px 14px; font-size:16px; line-height:1.6;
}

/* 글자수 헬퍼 */
.bwf-owner .bwf-helper{ display:flex; justify-content:flex-end; gap:8px; font-size:12px; color:#64748b; margin-top:6px; }
.bwf-owner .bwf-helper.ok{ color:var(--bwf-success); }

/* 모바일(대표폼)에서 제목/예시 크기 보정 */
@media (max-width:768px){
  .bwf-owner .bwf-title{ font-size:22px; }
  .bwf-owner .bwf-examples{ font-size:14px; }
}

/* 다른 곳에서 진행바를 숨겼다면 대표폼에서는 강제 노출 */
.bwf-owner #bwf-progress,
.bwf-owner .bwf-topwrap,
.bwf-owner .bwf-topcount{ display:block !important; }



/* =======================================================================================
   대표 질문지 오버라이드 v2 (시각 톤 업그레이드)
   - 타이틀 크기/질문 라벨을 4번 섹션 톤에 맞춰 상향
   - 예시 박스는 더 작고 차분하게 (모바일 여백 축소)
   - 위 블록보다 아래에 있어 우선 적용됨
   ======================================================================================= */

/* [Title] 페이지 타이틀 크게 */
.bwf-owner .bwf-title{ font-size:30px; font-weight:900; letter-spacing:-.2px; }
@media (max-width:768px){ .bwf-owner .bwf-title{ font-size:24px; } }

/* [Section] 문항 간격 + 라벨 통일(굵고 큼) */
.bwf-owner .bwf-field{ margin-bottom:22px; }
.bwf-owner .bwf-field label{ display:block; font-size:20px; font-weight:800; margin:6px 0 8px; color:#111827; } /* 모든 문항 타이틀 크기 통일 */
.bwf-owner .bwf-h3{ font-size:20px; font-weight:800; margin:18px 0 8px; } /* 그룹 섹션 제목 */

/* [Copy] 설명/예시(더 작게) */
.bwf-owner .bwf-desc{ font-size:14.5px; color:#475569; margin:0 0 8px; }
.bwf-owner .bwf-examples{
  background:#f8fafc; border:1px solid #e2e8f0; border-radius:10px;
  padding:10px 12px; margin:6px 0 10px;
}
.bwf-owner .bwf-examples p,
.bwf-owner .bwf-examples ul,
.bwf-owner .bwf-examples ol{ margin:6px 0; }
.bwf-owner .bwf-examples ul,
.bwf-owner .bwf-examples ol{ padding-left:18px; }

/* 모바일에서 예시 여백/글자 약간 더 줄임 */
@media (max-width:768px){
  .bwf-owner .bwf-examples{ padding:8px 10px; margin:6px 0 8px; }
  .bwf-owner .bwf-desc{ font-size:14px; }
}

/* [Inputs/Helper] (대표폼 전용) */
.bwf-owner textarea{ width:100%; padding:12px 14px; font-size:16px; line-height:1.6; }
.bwf-owner .bwf-helper{ display:flex; justify-content:flex-end; gap:8px; font-size:12px; color:#64748b; margin-top:6px; }
.bwf-owner .bwf-helper.ok{ color:var(--bwf-success); }

/* [Progress] 상단 진행바(항상 노출) */
.bwf-owner .bwf-topwrap{ position:sticky; top:0; z-index:40; background:#fff; padding:12px 14px 14px; border-bottom:1px solid #eee; margin:0 0 16px; }
.bwf-owner .bwf-top-title{ font-weight:700; margin-bottom:8px; }
.bwf-owner #bwf-progress{ position:relative; height:10px; background:#eef2f7; border-radius:999px; overflow:hidden; }
.bwf-owner #bwf-progress .bar{ height:100%; width:0%; background:linear-gradient(90deg,#0ea5e9,#6366f1); }
.bwf-owner #bwf-progress .label{ position:absolute; right:0; top:-22px; font-size:12px; color:#475569; }

/* [Reset] 혹시 다른 CSS가 숨겼을 경우 강제 노출 */
.bwf-owner #bwf-progress, .bwf-owner .bwf-topwrap, .bwf-owner .bwf-topcount{ display:block !important; }


.bwf-modal.is-open { display:block; }

.bwf-topwrap{position:sticky;top:72px;z-index:10;background:#fff;padding:12px 0 8px}
#bwf-progress{height:10px;background:#f1f5f9;border-radius:999px;overflow:hidden}
#bwf-progress .bar{height:100%;width:0%}
.bwf-field{margin:18px 0}
.bwf-field.bwf-error textarea{border:2px solid #ef4444 !important; outline:none}

.bwf-actions{margin-top:20px}
.bwf-modal{display:none;position:fixed;inset:0;background:rgba(0,0,0,.3)}
.bwf-modal__card{max-width:420px;margin:10vh auto;background:#fff;padding:20px;border-radius:12px}

/* 폼 내 안내/카운터 영역 전체 숨김 */
.bwf-owner .bwf-helper,
.bwf-owner .bwf-min-note { display:none !important; }

/* 에러는 textarea만 빨갛게 */
.bwf-owner .bwf-field.bwf-error textarea{ border:2px solid #ef4444 !important; outline:0; }

.bwf-owner #bwf-progress{height:10px;background:#e5e7eb;border-radius:999px;overflow:hidden}
.bwf-owner #bwf-progress .bar{height:100%;width:0;transition:width .2s}

`$nl
===== FILE: berrywalk-feedback\public\js\feedback.js (10996 bytes, 290 lines) =====
`$ext
jQuery(function($){
  // 글자수 + 진행도(그룹) ------------------------------------
  function computeProgress(){
    // 문항 묶음: ask3 그룹(고객에게 물어보고 싶은 3가지)은 하나로 카운트
    const $targets = $('textarea[data-minlength]');
    const groups = {};         // {groupKey: [textarea, ...]}
    const single = [];         // 비그룹 항목

    $targets.each(function(){
      const $t = $(this);
      const g = $t.data('group') || null;
      if (g) {
        if (!groups[g]) groups[g] = [];
        groups[g].push($t);
      } else {
        single.push($t);
      }
      // 글자수 카운터 갱신
      const cur = $t.val().length;
      const min = parseInt($t.data('minlength'), 10) || 0;
      $t.siblings('.bwf-helper').find('.bwf-counter').text(`${cur}/${min}`);
    });

    // 총 문항 수 = 비그룹 개수 + 그룹 수
    const total = single.length + Object.keys(groups).length;

    // 완료 수 계산(비그룹은 개별, 그룹은 전원 충족 시 1)
    let done = 0;
    single.forEach($t=>{
      const cur = $t.val().length, min = parseInt($t.data('minlength'),10)||0;
      if (cur >= min) done++;
    });
    Object.values(groups).forEach(list=>{
      const allOk = list.every($t => ($t.val().length >= (parseInt($t.data('minlength'),10)||0)));
      if (allOk) done++;
    });

    const pct = total ? Math.round((done/total)*100) : 0;
    $('.bwf-topcount .done').text(done);
    $('.bwf-topcount .total').text(total);
    $('#bwf-progress .bar').css('width', pct+'%');
    $('#bwf-progress .label').text(pct+'%');
  }

  // 입력 시 즉시 반영
  $(document).on('input', 'textarea[data-minlength]', computeProgress);

  // 제출 검증 -------------------------------------------------
  $('form.bwf-form').on('submit', function(e){
    let ok = true, firstBad = null;

    // 필수 input/select
    $(this).find('[required]').each(function(){
      const el = this;
      if (!el.value || (el.tagName==='SELECT' && !el.value)) {
        ok = false;
        $(el).addClass('bwf-invalid');
        if (!firstBad) firstBad = el;
      } else {
        $(el).removeClass('bwf-invalid');
      }
    });

    // 텍스트영역: 100자 최소
    $(this).find('textarea[data-minlength]').each(function(){
      const $t = $(this);
      const min = parseInt($t.data('minlength'),10) || 0;
      if ($t.val().length < min) {
        ok = false;
        $t.addClass('bwf-invalid');
        if (!firstBad) firstBad = $t[0];
      } else {
        $t.removeClass('bwf-invalid');
      }
    });

    if (!ok) {
      e.preventDefault();
      const $p = $(firstBad).closest('.bwf-field, div');
      if ($p.length) $('html,body').animate({scrollTop: $p.offset().top - 100}, 300);
      alert('필수 항목이 누락되었거나 최소 글자 수를 만족하지 못했습니다. 빨간 표시 항목을 확인해 주세요.');
    }
  });

  // “알게 된 경로 = 기타” 토글(대표/회원가입 공통)
  function toggleEtc(){
    const $sel = $('#bwf-source');
    const $etc = $('#bwf-source-etc');
    if ($sel.length && $etc.length) {
      $etc.toggle($sel.val()==='etc');
    }
  }
  $(document).on('change','#bwf-source', toggleEtc);
  toggleEtc();

  // 초기 계산
  computeProgress();
});
document.addEventListener('DOMContentLoaded', () => {
  const phone = document.getElementById('bwf-phone');
  if (phone) {
    const fmt010 = (v) => {
      const d = v.replace(/\D/g,'').slice(0, 11);
      if (!d.startsWith('010')) return d;                 // 010 이외는 입력 자체를 막고 싶다면 여길 강제 리턴 처리
      if (d.length <= 3) return d;
      if (d.length <= 7) return d.slice(0,3) + '-' + d.slice(3);
      return d.slice(0,3) + '-' + d.slice(3,7) + '-' + d.slice(7,11);
    };
    const validate = () => {
      const ok = /^010-\d{4}-\d{4}$/.test(phone.value);
      phone.setCustomValidity(ok ? '' : '010-1234-5678 형식으로 입력해주세요');
    };

    ['input','paste','blur','change'].forEach(ev=>{
      phone.addEventListener(ev, () => {
        const pos = phone.selectionStart;
        phone.value = fmt010(phone.value);
        validate();
      }, {passive:true});
    });
  }
});

document.addEventListener('DOMContentLoaded', () => {
  const form = document.querySelector('.bwf-form');
  if (!form) return;

  // 대표 질문지 6문항 규칙: [problem, value, ideal_customer, (q1+q2+q3 그룹), one_question, competitors]
  const fields = {
    problem:          form.querySelector('textarea[name="problem"]'),
    value:            form.querySelector('textarea[name="value"]'),
    ideal:            form.querySelector('textarea[name="ideal_customer"]'),
    ask3:             form.querySelectorAll('textarea[data-group="ask3"]'),
    one:              form.querySelector('input[name="one_question"]'),
    diff:             form.querySelector('textarea[name="competitors"]'),
  };

  const topCountEl = form.querySelector('.bwf-topcount .done') || form.querySelector('#bwf-answered');
  const topTotalEl = form.querySelector('.bwf-topcount .total') || form.querySelector('#bwf-total');
  const progress   = document.getElementById('bwf-progress');
  const bar        = progress ? progress.querySelector('.bar') : null;
  const label      = progress ? progress.querySelector('.label') : null;

  const MIN = 50;       // 대표질문지 최소 글자수
  const TOTAL = 6;

  if (topTotalEl) topTotalEl.textContent = TOTAL;

  const len = el => (el?.value || '').trim().length;
  const okText = el => el && len(el) >= (parseInt(el.dataset.minlength || MIN,10));
  const okAsk3 = () => {
    let okAll = true;
    (fields.ask3 || []).forEach(t => { if (!okText(t)) okAll = false; });
    return okAll;
  };
  const okOne = () => (fields.one?.value || '').trim().length > 0;

  const updateCounters = () => {
    let done = 0;
    if (okText(fields.problem)) done++;
    if (okText(fields.value)) done++;
    if (okText(fields.ideal)) done++;
    if (okAsk3()) done++;
    if (okOne()) done++;
    if (okText(fields.diff)) done++;

    if (topCountEl) topCountEl.textContent = done;
    if (bar)   bar.style.width = (done / TOTAL * 100).toFixed(0) + '%';
    if (label) label.textContent = `진행률 ${Math.round(done/TOTAL*100)}%`;

    // 각 textarea 하단 글자수 표시
    form.querySelectorAll('textarea').forEach(t=>{
      const hc = t.parentElement.querySelector('.bwf-counter');
      if (hc) hc.textContent = `${len(t)}자`;
    });
  };

  // 이벤트 바인딩
  form.querySelectorAll('textarea, input[type="text"]').forEach(el=>{
    el.addEventListener('input', updateCounters, {passive:true});
    el.addEventListener('change', updateCounters, {passive:true});
  });

  updateCounters(); // 초기 렌더
});

document.addEventListener('DOMContentLoaded', () => {
  const phs = [document.getElementById('bwf-phone'), document.getElementById('bwf-phone-admin')].filter(Boolean);
  phs.forEach(phone=>{
    const fmt = v => {
      const d = v.replace(/\D/g,'').slice(0,11);
      if (!d.startsWith('010')) return d;
      if (d.length <= 3) return d;
      if (d.length <= 7) return d.slice(0,3)+'-'+d.slice(3);
      return d.slice(0,3)+'-'+d.slice(3,7)+'-'+d.slice(7);
    };
    const validate = () => {
      const ok = /^010-\d{4}-\d{4}$/.test(phone.value);
      phone.setCustomValidity(ok ? '' : '010-1234-5678 형식만 허용됩니다.');
    };
    ['input','paste','blur','change'].forEach(ev=>{
      phone.addEventListener(ev, ()=>{
        phone.value = fmt(phone.value);
        validate();
      }, {passive:true});
    });
  });
});

document.addEventListener('DOMContentLoaded', () => {
  const form = document.querySelector('.bwf-form');
  if (!form) return;

  // 진행바가 없으면 주입
  if (!form.querySelector('.bwf-topwrap')) {
    const box = document.createElement('div');
    box.className = 'bwf-topwrap';
    box.innerHTML = `
      <div class="bwf-top-title">진행 현황</div>
      <div id="bwf-progress"><span class="bar"></span><span class="label"></span></div>
      <div class="bwf-helper">작성 <b class="done">0</b>/<b class="total">6</b> 문항 <span class="hint">각 문항 최소 50자</span></div>
    `;
    form.prepend(box);
  }

  // 필드 수집(6문항 규칙)
  const F = {
    problem: form.querySelector('textarea[name="problem"]'),
    value: form.querySelector('textarea[name="value"]'),
    ideal: form.querySelector('textarea[name="ideal_customer"]'),
    ask3: form.querySelectorAll('textarea[data-group="ask3"]'), // q1 q2 q3
    one: form.querySelector('input[name="one_question"]'),
    diff: form.querySelector('textarea[name="competitors"]')
  };

  // 각 textarea 하단에 글자수 메타 주입
  form.querySelectorAll('textarea').forEach(t=>{
    if (!t.parentElement.querySelector('.bwf-count')) {
      const m = document.createElement('div');
      m.className = 'bwf-count';
      m.innerHTML = `<span class="now">0자</span><span class="need">50자 이상</span>`;
      t.parentElement.appendChild(m);
    }
  });

  const top = form.querySelector('.bwf-topwrap');
  const doneEl = top.querySelector('.done');
  const totalEl = top.querySelector('.total'); totalEl.textContent = '6';
  const bar = top.querySelector('.bar'); const label = top.querySelector('.label');
  const MIN = 50;

  const len = el => (el?.value || '').trim().length;
  const okT = el => el && len(el) >= (parseInt(el.dataset.minlength || MIN,10));
  const okAsk3 = () => { let ok=true; F.ask3.forEach(t=>{ if(!okT(t)) ok=false; }); return ok; };
  const okOne = () => (F.one?.value || '').trim().length>0;

  const update = () => {
    // ①②③ + ④(ask3합) + ⑤(one) + ⑥(diff)
    let done=0;
    if (okT(F.problem)) done++;
    if (okT(F.value)) done++;
    if (okT(F.ideal)) done++;
    if (okAsk3()) done++;
    if (okOne()) done++;
    if (okT(F.diff)) done++;

    doneEl.textContent = done;
    const p = Math.round(done/6*100);
    bar.style.width = p+'%';
    label.textContent = `진행률 ${p}%`;

    // 글자수 표시/남은 글자
    form.querySelectorAll('textarea').forEach(t=>{
      const n = len(t), min = parseInt(t.dataset.minlength || MIN,10);
      const wrap = t.parentElement.querySelector('.bwf-count');
      if (wrap) {
        wrap.querySelector('.now').textContent = `${n}자`;
        wrap.querySelector('.need').textContent = n>=min ? '충분합니다' : `+${min-n}자 더 입력`;
      }
    });
  };

  form.querySelectorAll('textarea,input[type="text"]').forEach(el=>{
    el.addEventListener('input', update, {passive:true});
    el.addEventListener('change', update, {passive:true});
  });

  update(); // 초기 렌더
});

`$nl
